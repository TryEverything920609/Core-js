// Generated by LiveScript 1.3.1
(function(){
  var module, test, this$ = this;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('ArrayBuffer', function(assert){
    var b;
    assert.isFunction(ArrayBuffer);
    assert.arity(ArrayBuffer, 1);
    assert.name(ArrayBuffer, 'ArrayBuffer');
    assert.looksNative(ArrayBuffer);
    b = new ArrayBuffer(123);
    assert.same(b.byteLength, 123, 'length');
    assert.throws(function(){
      new ArrayBuffer(-1);
    }, RangeError, 'negative length');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, this$ = this;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('DataView', function(assert){
    var d;
    assert.isFunction(DataView);
    assert.arity(DataView, 3);
    assert.name(DataView, 'DataView');
    assert.looksNative(DataView);
    d = new DataView(new ArrayBuffer(8));
    d.setUint32(0, 0x12345678);
    assert.same(d.getUint32(0), 0x12345678, 'big endian/big endian');
    d.setUint32(0, 0x12345678, true);
    assert.same(d.getUint32(0, true), 0x12345678, 'little endian/little endian');
    d.setUint32(0, 0x12345678, true);
    assert.same(d.getUint32(0), 0x78563412, 'little endian/big endian');
    d.setUint32(0, 0x12345678);
    assert.same(d.getUint32(0, true), 0x78563412, 'big endian/little endian');
    assert.throws(function(){
      return new DataView({});
    }, 'non-ArrayBuffer argument');
    assert.throws(function(){
      return new DataView('bogus');
    }, TypeError, 'non-ArrayBuffer argument');
  });
  test('DataView accessors', function(assert){
    var u, d;
    u = new Uint8Array(8);
    d = new DataView(u.buffer);
    assert.arrayEqual(u, [0, 0, 0, 0, 0, 0, 0, 0]);
    d.setUint8(0, 255);
    assert.arrayEqual(u, [0xff, 0, 0, 0, 0, 0, 0, 0]);
    d.setInt8(1, -1);
    assert.arrayEqual(u, [0xff, 0xff, 0, 0, 0, 0, 0, 0]);
    d.setUint16(2, 0x1234);
    assert.arrayEqual(u, [0xff, 0xff, 0x12, 0x34, 0, 0, 0, 0]);
    d.setInt16(4, -1);
    assert.arrayEqual(u, [0xff, 0xff, 0x12, 0x34, 0xff, 0xff, 0, 0]);
    d.setUint32(1, 0x12345678);
    assert.arrayEqual(u, [0xff, 0x12, 0x34, 0x56, 0x78, 0xff, 0, 0]);
    d.setInt32(4, -2023406815);
    assert.arrayEqual(u, [0xff, 0x12, 0x34, 0x56, 0x87, 0x65, 0x43, 0x21]);
    d.setFloat32(2, 1.2e+38);
    assert.arrayEqual(u, [0xff, 0x12, 0x7e, 0xb4, 0x8e, 0x52, 0x43, 0x21]);
    d.setFloat64(0, -1.2345678e+301);
    assert.arrayEqual(u, [0xfe, 0x72, 0x6f, 0x51, 0x5f, 0x61, 0x77, 0xe5]);
    u.set([0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87]);
    assert.same(d.getUint8(0), 128);
    assert.same(d.getInt8(1), -127);
    assert.same(d.getUint16(2), 33411);
    assert.same(d.getInt16(3), -31868);
    assert.same(d.getUint32(4), 2223343239);
    assert.same(d.getInt32(2), -2105310075);
    assert.same(d.getFloat32(2), -1.932478247535851e-37);
    assert.same(d.getFloat64(0), -3.116851295377095e-306);
  });
  test('DataView endian', function(assert){
    var rawbuf, d;
    rawbuf = new Uint8Array([0, 1, 2, 3, 4, 5, 6, 7]).buffer;
    d = new DataView(rawbuf);
    assert.same(d.byteLength, 8, 'buffer');
    assert.same(d.byteOffset, 0, 'buffer');
    assert.throws(function(){
      return d.getUint8(-2);
    });
    assert.throws(function(){
      return d.getUint8(8);
    }, 'bounds for buffer');
    assert.throws(function(){
      return d.setUint8(-2, 0);
    }, 'bounds for buffer');
    assert.throws(function(){
      return d.setUint8(8, 0);
    }, 'bounds for buffer');
    d = new DataView(rawbuf, 2);
    assert.same(d.byteLength, 6, 'buffer, byteOffset');
    assert.same(d.byteOffset, 2, 'buffer, byteOffset');
    assert.same(d.getUint8(5), 7, 'buffer, byteOffset');
    assert.throws(function(){
      return d.getUint8(-2);
    }, 'bounds for buffer, byteOffset');
    assert.throws(function(){
      return d.getUint8(6);
    }, 'bounds for buffer, byteOffset');
    assert.throws(function(){
      return d.setUint8(-2, 0);
    }, 'bounds for buffer, byteOffset');
    assert.throws(function(){
      return d.setUint8(6, 0);
    }, 'bounds for buffer, byteOffset');
    d = new DataView(rawbuf, 8);
    assert.same(d.byteLength, 0, 'buffer, byteOffset');
    assert.throws(function(){
      return new DataView(rawbuf, -1);
    }, 'invalid byteOffset');
    assert.throws(function(){
      return new DataView(rawbuf, 9);
    }, 'invalid byteOffset');
    d = new DataView(rawbuf, 2, 4);
    assert.same(d.byteLength, 4, 'buffer, byteOffset, length');
    assert.same(d.byteOffset, 2, 'buffer, byteOffset, length');
    assert.same(d.getUint8(3), 5, 'buffer, byteOffset, length');
    assert.throws(function(){
      return d.getUint8(-2);
    }, 'bounds for buffer, byteOffset, length');
    assert.throws(function(){
      return d.getUint8(4);
    }, 'bounds for buffer, byteOffset, length');
    assert.throws(function(){
      return d.setUint8(-2, 0);
    }, 'bounds for buffer, byteOffset, length');
    assert.throws(function(){
      return d.setUint8(4, 0);
    }, 'bounds for buffer, byteOffset, length');
    assert.throws(function(){
      return new DataView(rawbuf, 0, 9);
    }, 'invalid byteOffset+length');
    assert.throws(function(){
      return new DataView(rawbuf, 8, 1);
    }, 'invalid byteOffset+length');
    assert.throws(function(){
      return new DataView(rawbuf, 9, -1);
    }, 'invalid byteOffset+length');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, this$ = this;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Float32Array', function(assert){
    var a;
    assert.isFunction(Float32Array);
    assert.arity(Float32Array, 3);
    assert.name(Float32Array, 'Float32Array');
    assert.looksNative(Float32Array);
    assert.same(Float32Array.BYTES_PER_ELEMENT, 4, '%TypedArray%.BYTES_PER_ELEMENT');
    a = new Float32Array([1, 2, 3, 4, 5, 6, 7, 8]);
    assert.same(a.BYTES_PER_ELEMENT, 4, '%TypedArray%#BYTES_PER_ELEMENT');
    assert.same(a.byteOffset, 0, '%TypedArray%#byteOffset');
    assert.same(a.byteLength, 32, '%TypedArray%#byteLength');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, this$ = this;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Float64Array', function(assert){
    var a;
    assert.isFunction(Float64Array);
    assert.arity(Float64Array, 3);
    assert.name(Float64Array, 'Float64Array');
    assert.looksNative(Float64Array);
    assert.same(Float64Array.BYTES_PER_ELEMENT, 8, '%TypedArray%.BYTES_PER_ELEMENT');
    a = new Float64Array([1, 2, 3, 4, 5, 6, 7, 8]);
    assert.same(a.BYTES_PER_ELEMENT, 8, '%TypedArray%#BYTES_PER_ELEMENT');
    assert.same(a.byteOffset, 0, '%TypedArray%#byteOffset');
    assert.same(a.byteLength, 64, '%TypedArray%#byteLength');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, this$ = this;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Int16Array', function(assert){
    var a;
    assert.isFunction(Int16Array);
    assert.arity(Int16Array, 3);
    assert.name(Int16Array, 'Int16Array');
    assert.looksNative(Int16Array);
    assert.same(Int16Array.BYTES_PER_ELEMENT, 2, '%TypedArray%.BYTES_PER_ELEMENT');
    a = new Int16Array([1, 2, 3, 4, 5, 6, 7, 8]);
    assert.same(a.BYTES_PER_ELEMENT, 2, '%TypedArray%#BYTES_PER_ELEMENT');
    assert.same(a.byteOffset, 0, '%TypedArray%#byteOffset');
    assert.same(a.byteLength, 16, '%TypedArray%#byteLength');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, this$ = this;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Int32Array', function(assert){
    var a;
    assert.isFunction(Int32Array);
    assert.arity(Int32Array, 3);
    assert.name(Int32Array, 'Int32Array');
    assert.looksNative(Int32Array);
    assert.same(Int32Array.BYTES_PER_ELEMENT, 4, '%TypedArray%.BYTES_PER_ELEMENT');
    a = new Int32Array([1, 2, 3, 4, 5, 6, 7, 8]);
    assert.same(a.BYTES_PER_ELEMENT, 4, '%TypedArray%#BYTES_PER_ELEMENT');
    assert.same(a.byteOffset, 0, '%TypedArray%#byteOffset');
    assert.same(a.byteLength, 32, '%TypedArray%#byteLength');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, this$ = this;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Int8Array', function(assert){
    var a;
    assert.isFunction(Int8Array);
    assert.arity(Int8Array, 3);
    assert.name(Int8Array, 'Int8Array');
    assert.looksNative(Int8Array);
    assert.same(Int8Array.BYTES_PER_ELEMENT, 1, '%TypedArray%.BYTES_PER_ELEMENT');
    a = new Int8Array([1, 2, 3, 4, 5, 6, 7, 8]);
    assert.same(a.BYTES_PER_ELEMENT, 1, '%TypedArray%#BYTES_PER_ELEMENT');
    assert.same(a.byteOffset, 0, '%TypedArray%#byteOffset');
    assert.same(a.byteLength, 8, '%TypedArray%#byteLength');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, this$ = this;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Uint16Array', function(assert){
    var a;
    assert.isFunction(Uint16Array);
    assert.arity(Uint16Array, 3);
    assert.name(Uint16Array, 'Uint16Array');
    assert.looksNative(Uint16Array);
    assert.same(Uint16Array.BYTES_PER_ELEMENT, 2, '%TypedArray%.BYTES_PER_ELEMENT');
    a = new Uint16Array([1, 2, 3, 4, 5, 6, 7, 8]);
    assert.same(a.BYTES_PER_ELEMENT, 2, '%TypedArray%#BYTES_PER_ELEMENT');
    assert.same(a.byteOffset, 0, '%TypedArray%#byteOffset');
    assert.same(a.byteLength, 16, '%TypedArray%#byteLength');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, this$ = this;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Uint32Array', function(assert){
    var a;
    assert.isFunction(Uint32Array);
    assert.arity(Uint32Array, 3);
    assert.name(Uint32Array, 'Uint32Array');
    assert.looksNative(Uint32Array);
    assert.same(Uint32Array.BYTES_PER_ELEMENT, 4, '%TypedArray%.BYTES_PER_ELEMENT');
    a = new Uint32Array([1, 2, 3, 4, 5, 6, 7, 8]);
    assert.same(a.BYTES_PER_ELEMENT, 4, '%TypedArray%#BYTES_PER_ELEMENT');
    assert.same(a.byteOffset, 0, '%TypedArray%#byteOffset');
    assert.same(a.byteLength, 32, '%TypedArray%#byteLength');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, this$ = this;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Uint8Array', function(assert){
    var a;
    assert.isFunction(Uint8Array);
    assert.arity(Uint8Array, 3);
    assert.name(Uint8Array, 'Uint8Array');
    assert.looksNative(Uint8Array);
    assert.same(Uint8Array.BYTES_PER_ELEMENT, 1, '%TypedArray%.BYTES_PER_ELEMENT');
    a = new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8]);
    assert.same(a.BYTES_PER_ELEMENT, 1, '%TypedArray%#BYTES_PER_ELEMENT');
    assert.same(a.byteOffset, 0, '%TypedArray%#byteOffset');
    assert.same(a.byteLength, 8, '%TypedArray%#byteLength');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, this$ = this;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Uint8ClampedArray', function(assert){
    var a, source, expected, array, i$, to$, i;
    assert.isFunction(Uint8ClampedArray);
    assert.arity(Uint8ClampedArray, 3);
    assert.name(Uint8ClampedArray, 'Uint8ClampedArray');
    assert.looksNative(Uint8ClampedArray);
    assert.same(Uint8ClampedArray.BYTES_PER_ELEMENT, 1, '%TypedArray%.BYTES_PER_ELEMENT');
    a = new Uint8ClampedArray([1, 2, 3, 4, 5, 6, 7, 8]);
    assert.same(a.BYTES_PER_ELEMENT, 1, '%TypedArray%#BYTES_PER_ELEMENT');
    assert.same(a.byteOffset, 0, '%TypedArray%#byteOffset');
    assert.same(a.byteLength, 8, '%TypedArray%#byteLength');
    source = [-Infinity, -Number.MAX_VALUE, -1, -Number.MIN_VALUE, -0, 0, Number.MIN_VALUE, 1, 1.1, 1.9, 255, 255.1, 255.9, 256, Number.MAX_VALUE, Infinity, NaN];
    expected = [0, 0, 0, 0, 0, 0, 0, 1, 1, 2, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0];
    assert.arrayEqual(new Uint8ClampedArray(source), expected, 'conversion, constructor <- array');
    array = new Uint8ClampedArray(1);
    for (i$ = 0, to$ = source.length; i$ < to$; ++i$) {
      i = i$;
      array[0] = source[i];
      assert.same(array[0], expected[i], 'conversion, setter');
    }
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, this$ = this;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('%TypedArray%.from', function(assert){
    var global, i$, x$, ref$, len$, Typed, inst, O;
    global = Function('return this')();
    for (i$ = 0, len$ = (ref$ = ['Float32Array', 'Float64Array', 'Int8Array', 'Int16Array', 'Int32Array', 'Uint8Array', 'Uint16Array', 'Uint32Array', 'Uint8ClampedArray']).length; i$ < len$; ++i$) {
      x$ = ref$[i$];
      Typed = global[x$];
      assert.isFunction(Typed.from, x$ + ".from is function");
      assert.arity(Typed.from, 1, x$ + ".from arity is 1");
      assert.name(Typed.from, 'from', x$ + ".from name is 'from'");
      assert.looksNative(Typed.from, x$ + ".from looks native");
      inst = Typed.from([1, 2, 3]);
      assert.ok(inst instanceof Typed, 'correct instance with array');
      assert.arrayEqual(inst, [1, 2, 3], 'correct elements with array');
      inst = Typed.from({
        0: 1,
        1: 2,
        2: 3,
        length: 3
      });
      assert.ok(inst instanceof Typed, 'correct instance with array-like');
      assert.arrayEqual(inst, [1, 2, 3], 'correct elements with array-like');
      inst = Typed.from(createIterable([1, 2, 3]));
      assert.ok(inst instanceof Typed, 'correct instance with iterable');
      assert.arrayEqual(inst, [1, 2, 3], 'correct elements with iterable');
      assert.arrayEqual(Typed.from([1, 2, 3], fn$), [1, 4, 9], 'accept callback');
      Typed.from([1], fn1$, O = {});
      assert.throws(fn2$, "isn't generic");
    }
    function fn$(it){
      return it * it;
    }
    function fn1$(a, b){
      assert.same(arguments.length, 2, 'correct number of callback arguments');
      assert.same(a, 1, 'correct value in callback');
      assert.same(b, 0, 'correct index in callback');
      return assert.same(this, O, 'correct callback context');
    }
    function fn2$(){
      Typed.from.call(Array, []);
    }
  });
}).call(this);
