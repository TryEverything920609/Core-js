// Generated by LiveScript 1.3.1
(function(){
  var module, test, this$ = this;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('ArrayBuffer', function(assert){
    var b;
    assert.isFunction(ArrayBuffer);
    assert.arity(ArrayBuffer, 1);
    assert.name(ArrayBuffer, 'ArrayBuffer');
    assert.looksNative(ArrayBuffer);
    b = new ArrayBuffer(123);
    assert.same(b.byteLength, 123, 'length');
    assert.throws(function(){
      new ArrayBuffer(-1);
    }, RangeError, 'negative length');
    (typeof NATIVE != 'undefined' && NATIVE !== null) && assert.throws(function(){
      new ArrayBuffer();
    }, RangeError, 'missed length');
    (typeof NATIVE != 'undefined' && NATIVE !== null) && assert.throws(function(){
      new ArrayBuffer(Number.MAX_SAFE_INTEGER + 1);
    }, RangeError, 'absurd length');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, this$ = this;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('DataView', function(assert){
    var d;
    assert.isFunction(DataView);
    assert.arity(DataView, 3);
    assert.name(DataView, 'DataView');
    assert.looksNative(DataView);
    d = new DataView(new ArrayBuffer(8));
    d.setUint32(0, 0x12345678);
    assert.same(d.getUint32(0), 0x12345678, 'big endian/big endian');
    d.setUint32(0, 0x12345678, true);
    assert.same(d.getUint32(0, true), 0x12345678, 'little endian/little endian');
    d.setUint32(0, 0x12345678, true);
    assert.same(d.getUint32(0), 0x78563412, 'little endian/big endian');
    d.setUint32(0, 0x12345678);
    assert.same(d.getUint32(0, true), 0x78563412, 'big endian/little endian');
    assert.throws(function(){
      return new DataView({});
    }, 'non-ArrayBuffer argument');
    assert.throws(function(){
      return new DataView('bogus');
    }, TypeError, 'non-ArrayBuffer argument');
  });
  test('DataView accessors', function(assert){
    var u, d;
    u = new Uint8Array(8);
    d = new DataView(u.buffer);
    assert.arrayEqual(u, [0, 0, 0, 0, 0, 0, 0, 0]);
    d.setUint8(0, 255);
    assert.arrayEqual(u, [0xff, 0, 0, 0, 0, 0, 0, 0]);
    d.setInt8(1, -1);
    assert.arrayEqual(u, [0xff, 0xff, 0, 0, 0, 0, 0, 0]);
    d.setUint16(2, 0x1234);
    assert.arrayEqual(u, [0xff, 0xff, 0x12, 0x34, 0, 0, 0, 0]);
    d.setInt16(4, -1);
    assert.arrayEqual(u, [0xff, 0xff, 0x12, 0x34, 0xff, 0xff, 0, 0]);
    d.setUint32(1, 0x12345678);
    assert.arrayEqual(u, [0xff, 0x12, 0x34, 0x56, 0x78, 0xff, 0, 0]);
    d.setInt32(4, -2023406815);
    assert.arrayEqual(u, [0xff, 0x12, 0x34, 0x56, 0x87, 0x65, 0x43, 0x21]);
    d.setFloat32(2, 1.2e+38);
    assert.arrayEqual(u, [0xff, 0x12, 0x7e, 0xb4, 0x8e, 0x52, 0x43, 0x21]);
    d.setFloat64(0, -1.2345678e+301);
    assert.arrayEqual(u, [0xfe, 0x72, 0x6f, 0x51, 0x5f, 0x61, 0x77, 0xe5]);
    u.set([0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87]);
    assert.same(d.getUint8(0), 128);
    assert.same(d.getInt8(1), -127);
    assert.same(d.getUint16(2), 33411);
    assert.same(d.getInt16(3), -31868);
    assert.same(d.getUint32(4), 2223343239);
    assert.same(d.getInt32(2), -2105310075);
    assert.same(d.getFloat32(2), -1.932478247535851e-37);
    assert.same(d.getFloat64(0), -3.116851295377095e-306);
  });
  test('DataView endian', function(assert){
    var rawbuf, d;
    rawbuf = new Uint8Array([0, 1, 2, 3, 4, 5, 6, 7]).buffer;
    d = new DataView(rawbuf);
    assert.same(d.byteLength, 8, 'buffer');
    assert.same(d.byteOffset, 0, 'buffer');
    assert.throws(function(){
      return d.getUint8(-2);
    });
    assert.throws(function(){
      return d.getUint8(8);
    }, 'bounds for buffer');
    assert.throws(function(){
      return d.setUint8(-2, 0);
    }, 'bounds for buffer');
    assert.throws(function(){
      return d.setUint8(8, 0);
    }, 'bounds for buffer');
    d = new DataView(rawbuf, 2);
    assert.same(d.byteLength, 6, 'buffer, byteOffset');
    assert.same(d.byteOffset, 2, 'buffer, byteOffset');
    assert.same(d.getUint8(5), 7, 'buffer, byteOffset');
    assert.throws(function(){
      return d.getUint8(-2);
    }, 'bounds for buffer, byteOffset');
    assert.throws(function(){
      return d.getUint8(6);
    }, 'bounds for buffer, byteOffset');
    assert.throws(function(){
      return d.setUint8(-2, 0);
    }, 'bounds for buffer, byteOffset');
    assert.throws(function(){
      return d.setUint8(6, 0);
    }, 'bounds for buffer, byteOffset');
    d = new DataView(rawbuf, 8);
    assert.same(d.byteLength, 0, 'buffer, byteOffset');
    assert.throws(function(){
      return new DataView(rawbuf, -1);
    }, 'invalid byteOffset');
    assert.throws(function(){
      return new DataView(rawbuf, 9);
    }, 'invalid byteOffset');
    d = new DataView(rawbuf, 2, 4);
    assert.same(d.byteLength, 4, 'buffer, byteOffset, length');
    assert.same(d.byteOffset, 2, 'buffer, byteOffset, length');
    assert.same(d.getUint8(3), 5, 'buffer, byteOffset, length');
    assert.throws(function(){
      return d.getUint8(-2);
    }, 'bounds for buffer, byteOffset, length');
    assert.throws(function(){
      return d.getUint8(4);
    }, 'bounds for buffer, byteOffset, length');
    assert.throws(function(){
      return d.setUint8(-2, 0);
    }, 'bounds for buffer, byteOffset, length');
    assert.throws(function(){
      return d.setUint8(4, 0);
    }, 'bounds for buffer, byteOffset, length');
    assert.throws(function(){
      return new DataView(rawbuf, 0, 9);
    }, 'invalid byteOffset+length');
    assert.throws(function(){
      return new DataView(rawbuf, 8, 1);
    }, 'invalid byteOffset+length');
    assert.throws(function(){
      return new DataView(rawbuf, 9, -1);
    }, 'invalid byteOffset+length');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, this$ = this;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Float32Array', function(assert){
    var a;
    assert.isFunction(Float32Array);
    assert.arity(Float32Array, 3);
    assert.name(Float32Array, 'Float32Array');
    assert.looksNative(Float32Array);
    assert.same(Float32Array.BYTES_PER_ELEMENT, 4, '%TypedArray%.BYTES_PER_ELEMENT');
    a = new Float32Array([1, 2, 3, 4, 5, 6, 7, 8]);
    assert.same(a.BYTES_PER_ELEMENT, 4, '%TypedArray%#BYTES_PER_ELEMENT');
    assert.same(a.byteOffset, 0, '%TypedArray%#byteOffset');
    assert.same(a.byteLength, 32, '%TypedArray%#byteLength');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, this$ = this;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Float64Array', function(assert){
    var a;
    assert.isFunction(Float64Array);
    assert.arity(Float64Array, 3);
    assert.name(Float64Array, 'Float64Array');
    assert.looksNative(Float64Array);
    assert.same(Float64Array.BYTES_PER_ELEMENT, 8, '%TypedArray%.BYTES_PER_ELEMENT');
    a = new Float64Array([1, 2, 3, 4, 5, 6, 7, 8]);
    assert.same(a.BYTES_PER_ELEMENT, 8, '%TypedArray%#BYTES_PER_ELEMENT');
    assert.same(a.byteOffset, 0, '%TypedArray%#byteOffset');
    assert.same(a.byteLength, 64, '%TypedArray%#byteLength');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, this$ = this;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Int16Array', function(assert){
    var a;
    assert.isFunction(Int16Array);
    assert.arity(Int16Array, 3);
    assert.name(Int16Array, 'Int16Array');
    assert.looksNative(Int16Array);
    assert.same(Int16Array.BYTES_PER_ELEMENT, 2, '%TypedArray%.BYTES_PER_ELEMENT');
    a = new Int16Array([1, 2, 3, 4, 5, 6, 7, 8]);
    assert.same(a.BYTES_PER_ELEMENT, 2, '%TypedArray%#BYTES_PER_ELEMENT');
    assert.same(a.byteOffset, 0, '%TypedArray%#byteOffset');
    assert.same(a.byteLength, 16, '%TypedArray%#byteLength');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, this$ = this;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Int32Array', function(assert){
    var a;
    assert.isFunction(Int32Array);
    assert.arity(Int32Array, 3);
    assert.name(Int32Array, 'Int32Array');
    assert.looksNative(Int32Array);
    assert.same(Int32Array.BYTES_PER_ELEMENT, 4, '%TypedArray%.BYTES_PER_ELEMENT');
    a = new Int32Array([1, 2, 3, 4, 5, 6, 7, 8]);
    assert.same(a.BYTES_PER_ELEMENT, 4, '%TypedArray%#BYTES_PER_ELEMENT');
    assert.same(a.byteOffset, 0, '%TypedArray%#byteOffset');
    assert.same(a.byteLength, 32, '%TypedArray%#byteLength');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, this$ = this;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Int8Array', function(assert){
    var a;
    assert.isFunction(Int8Array);
    assert.arity(Int8Array, 3);
    assert.name(Int8Array, 'Int8Array');
    assert.looksNative(Int8Array);
    assert.same(Int8Array.BYTES_PER_ELEMENT, 1, '%TypedArray%.BYTES_PER_ELEMENT');
    a = new Int8Array([1, 2, 3, 4, 5, 6, 7, 8]);
    assert.same(a.BYTES_PER_ELEMENT, 1, '%TypedArray%#BYTES_PER_ELEMENT');
    assert.same(a.byteOffset, 0, '%TypedArray%#byteOffset');
    assert.same(a.byteLength, 8, '%TypedArray%#byteLength');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, this$ = this;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Uint16Array', function(assert){
    var a;
    assert.isFunction(Uint16Array);
    assert.arity(Uint16Array, 3);
    assert.name(Uint16Array, 'Uint16Array');
    assert.looksNative(Uint16Array);
    assert.same(Uint16Array.BYTES_PER_ELEMENT, 2, '%TypedArray%.BYTES_PER_ELEMENT');
    a = new Uint16Array([1, 2, 3, 4, 5, 6, 7, 8]);
    assert.same(a.BYTES_PER_ELEMENT, 2, '%TypedArray%#BYTES_PER_ELEMENT');
    assert.same(a.byteOffset, 0, '%TypedArray%#byteOffset');
    assert.same(a.byteLength, 16, '%TypedArray%#byteLength');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, this$ = this;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Uint32Array', function(assert){
    var a;
    assert.isFunction(Uint32Array);
    assert.arity(Uint32Array, 3);
    assert.name(Uint32Array, 'Uint32Array');
    assert.looksNative(Uint32Array);
    assert.same(Uint32Array.BYTES_PER_ELEMENT, 4, '%TypedArray%.BYTES_PER_ELEMENT');
    a = new Uint32Array([1, 2, 3, 4, 5, 6, 7, 8]);
    assert.same(a.BYTES_PER_ELEMENT, 4, '%TypedArray%#BYTES_PER_ELEMENT');
    assert.same(a.byteOffset, 0, '%TypedArray%#byteOffset');
    assert.same(a.byteLength, 32, '%TypedArray%#byteLength');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, this$ = this;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Uint8Array', function(assert){
    var a;
    assert.isFunction(Uint8Array);
    assert.arity(Uint8Array, 3);
    assert.name(Uint8Array, 'Uint8Array');
    assert.looksNative(Uint8Array);
    assert.same(Uint8Array.BYTES_PER_ELEMENT, 1, '%TypedArray%.BYTES_PER_ELEMENT');
    a = new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8]);
    assert.same(a.BYTES_PER_ELEMENT, 1, '%TypedArray%#BYTES_PER_ELEMENT');
    assert.same(a.byteOffset, 0, '%TypedArray%#byteOffset');
    assert.same(a.byteLength, 8, '%TypedArray%#byteLength');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, this$ = this;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Uint8ClampedArray', function(assert){
    var a, source, expected, array, i$, to$, i;
    assert.isFunction(Uint8ClampedArray);
    assert.arity(Uint8ClampedArray, 3);
    assert.name(Uint8ClampedArray, 'Uint8ClampedArray');
    assert.looksNative(Uint8ClampedArray);
    assert.same(Uint8ClampedArray.BYTES_PER_ELEMENT, 1, '%TypedArray%.BYTES_PER_ELEMENT');
    a = new Uint8ClampedArray([1, 2, 3, 4, 5, 6, 7, 8]);
    assert.same(a.BYTES_PER_ELEMENT, 1, '%TypedArray%#BYTES_PER_ELEMENT');
    assert.same(a.byteOffset, 0, '%TypedArray%#byteOffset');
    assert.same(a.byteLength, 8, '%TypedArray%#byteLength');
    source = [-Infinity, -Number.MAX_VALUE, -1, -Number.MIN_VALUE, -0, 0, Number.MIN_VALUE, 1, 1.1, 1.9, 255, 255.1, 255.9, 256, Number.MAX_VALUE, Infinity, NaN];
    expected = [0, 0, 0, 0, 0, 0, 0, 1, 1, 2, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0];
    assert.arrayEqual(new Uint8ClampedArray(source), expected, 'conversion, constructor <- array');
    array = new Uint8ClampedArray(1);
    for (i$ = 0, to$ = source.length; i$ < to$; ++i$) {
      i = i$;
      array[0] = source[i];
      assert.same(array[0], expected[i], 'conversion, setter');
    }
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, this$ = this;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('%TypedArrayPrototype%.copyWithin', function(assert){
    var global, i$, x$, ref$, len$, Typed, a;
    global = Function('return this')();
    for (i$ = 0, len$ = (ref$ = ['Float32Array', 'Float64Array', 'Int8Array', 'Int16Array', 'Int32Array', 'Uint8Array', 'Uint16Array', 'Uint32Array', 'Uint8ClampedArray']).length; i$ < len$; ++i$) {
      x$ = ref$[i$];
      Typed = global[x$];
      assert.isFunction(Typed.prototype.copyWithin, x$ + "::copyWithin is function");
      assert.arity(Typed.prototype.copyWithin, 2, x$ + "::copyWithin arity is 2");
      assert.name(Typed.prototype.copyWithin, 'copyWithin', x$ + "::copyWithin name is 'copyWithin'");
      assert.looksNative(Typed.prototype.copyWithin, x$ + "::copyWithin looks native");
      assert.strictEqual(a = new Typed(5).copyWithin(0), a, 'return this');
      assert.arrayEqual(new Typed([1, 2, 3, 4, 5]).copyWithin(0, 3), [4, 5, 3, 4, 5]);
      assert.arrayEqual(new Typed([1, 2, 3, 4, 5]).copyWithin(1, 3), [1, 4, 5, 4, 5]);
      assert.arrayEqual(new Typed([1, 2, 3, 4, 5]).copyWithin(1, 2), [1, 3, 4, 5, 5]);
      assert.arrayEqual(new Typed([1, 2, 3, 4, 5]).copyWithin(2, 2), [1, 2, 3, 4, 5]);
      assert.arrayEqual(new Typed([1, 2, 3, 4, 5]).copyWithin(0, 3, 4), [4, 2, 3, 4, 5]);
      assert.arrayEqual(new Typed([1, 2, 3, 4, 5]).copyWithin(1, 3, 4), [1, 4, 3, 4, 5]);
      assert.arrayEqual(new Typed([1, 2, 3, 4, 5]).copyWithin(1, 2, 4), [1, 3, 4, 4, 5]);
      assert.arrayEqual(new Typed([1, 2, 3, 4, 5]).copyWithin(0, -2), [4, 5, 3, 4, 5]);
      assert.arrayEqual(new Typed([1, 2, 3, 4, 5]).copyWithin(0, -2, -1), [4, 2, 3, 4, 5]);
      assert.arrayEqual(new Typed([1, 2, 3, 4, 5]).copyWithin(-4, -3, -2), [1, 3, 3, 4, 5]);
      assert.arrayEqual(new Typed([1, 2, 3, 4, 5]).copyWithin(-4, -3, -1), [1, 3, 4, 4, 5]);
      assert.arrayEqual(new Typed([1, 2, 3, 4, 5]).copyWithin(-4, -3), [1, 3, 4, 5, 5]);
      assert.throws(fn$, "isn't generic");
    }
    function fn$(){
      Typed.prototype.fill.call([0], 1);
    }
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, this$ = this;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('%TypedArrayPrototype%.every', function(assert){
    var global, i$, x$, ref$, len$, Typed, a, ctx, v, k, arr;
    global = Function('return this')();
    for (i$ = 0, len$ = (ref$ = ['Float32Array', 'Float64Array', 'Int8Array', 'Int16Array', 'Int32Array', 'Uint8Array', 'Uint16Array', 'Uint32Array', 'Uint8ClampedArray']).length; i$ < len$; ++i$) {
      x$ = ref$[i$];
      Typed = global[x$];
      assert.isFunction(Typed.prototype.every, x$ + "::every is function");
      assert.arity(Typed.prototype.every, 1, x$ + "::every arity is 1");
      assert.name(Typed.prototype.every, 'every', x$ + "::every name is 'every'");
      assert.looksNative(Typed.prototype.every, x$ + "::every looks native");
      (a = new Typed([1])).every(fn$, ctx = {});
      assert.ok(new Typed([1, 2, 3]).every(fn1$));
      assert.ok(new Typed([1, 2, 3]).every((fn2$)));
      assert.ok(!new Typed([1, 2, 3]).every((fn3$)));
      assert.ok(!new Typed([1, 2, 3]).every(fn4$));
      assert.ok(new Typed([1, 2, 3]).every(fn5$, 1));
      v = '';
      k = '';
      new Typed([1, 2, 3]).every(fn6$);
      assert.same(v, '123');
      assert.same(k, '012');
      assert.ok((arr = new Typed([1, 2, 3])).every(fn7$));
      assert.throws(fn8$, "isn't generic");
    }
    function fn$(val, key, that){
      assert.same(arguments.length, 3, 'correct number of callback arguments');
      assert.same(val, 1, 'correct value in callback');
      assert.same(key, 0, 'correct index in callback');
      assert.same(that, a, 'correct link to array in callback');
      return assert.same(this, ctx, 'correct callback context');
    }
    function fn1$(it){
      return typeof it === 'number';
    }
    function fn2$(it){
      return it < 4;
    }
    function fn3$(it){
      return it < 3;
    }
    function fn4$(it){
      return typeof it === 'string';
    }
    function fn5$(){
      return +this === 1;
    }
    function fn6$(a, b){
      v += a;
      k += b;
      return true;
    }
    function fn7$(){
      return arguments[2] === arr;
    }
    function fn8$(){
      Typed.prototype.every.call([0], function(){
        return true;
      });
    }
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, this$ = this;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('%TypedArrayPrototype%.fill', function(assert){
    var global, i$, x$, ref$, len$, Typed, a;
    global = Function('return this')();
    for (i$ = 0, len$ = (ref$ = ['Float32Array', 'Float64Array', 'Int8Array', 'Int16Array', 'Int32Array', 'Uint8Array', 'Uint16Array', 'Uint32Array', 'Uint8ClampedArray']).length; i$ < len$; ++i$) {
      x$ = ref$[i$];
      Typed = global[x$];
      assert.isFunction(Typed.prototype.fill, x$ + "::fill is function");
      assert.arity(Typed.prototype.fill, 1, x$ + "::fill arity is 1");
      assert.name(Typed.prototype.fill, 'fill', x$ + "::fill name is 'fill'");
      assert.looksNative(Typed.prototype.fill, x$ + "::fill looks native");
      assert.strictEqual(a = new Typed(5).fill(5), a, 'return this');
      assert.arrayEqual(new Typed(5).fill(5), [5, 5, 5, 5, 5], 'basic');
      assert.arrayEqual(new Typed(5).fill(5, 1), [0, 5, 5, 5, 5], 'start index');
      assert.arrayEqual(new Typed(5).fill(5, 1, 4), [0, 5, 5, 5, 0], 'end index');
      assert.arrayEqual(new Typed(5).fill(5, 6, 1), [0, 0, 0, 0, 0], 'start > end');
      assert.arrayEqual(new Typed(5).fill(5, -3, 4), [0, 0, 5, 5, 0], 'negative start index');
      assert.throws(fn$, "isn't generic");
    }
    function fn$(){
      Typed.prototype.fill.call([0], 1);
    }
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, this$ = this;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('%TypedArrayPrototype%.filter', function(assert){
    var global, i$, x$, ref$, len$, Typed, a, ctx, instance, v, k;
    global = Function('return this')();
    for (i$ = 0, len$ = (ref$ = ['Float32Array', 'Float64Array', 'Int8Array', 'Int16Array', 'Int32Array', 'Uint8Array', 'Uint16Array', 'Uint32Array', 'Uint8ClampedArray']).length; i$ < len$; ++i$) {
      x$ = ref$[i$];
      Typed = global[x$];
      assert.isFunction(Typed.prototype.filter, x$ + "::filter is function");
      assert.arity(Typed.prototype.filter, 1, x$ + "::filter arity is 1");
      assert.name(Typed.prototype.filter, 'filter', x$ + "::filter name is 'filter'");
      assert.looksNative(Typed.prototype.filter, x$ + "::filter looks native");
      (a = new Typed([1])).filter(fn$, ctx = {});
      instance = new Typed([1, 2, 3, 4, 5, 6, 7, 8, 9]).filter((fn1$));
      assert.ok(instance instanceof Typed, 'correct instance');
      assert.arrayEqual(instance, [1, 3, 5, 7, 9], 'works');
      v = '';
      k = '';
      new Typed([1, 2, 3]).filter(fn2$);
      assert.same(v, '123');
      assert.same(k, '012');
      assert.throws(fn3$, "isn't generic");
    }
    function fn$(val, key, that){
      assert.same(arguments.length, 3, 'correct number of callback arguments');
      assert.same(val, 1, 'correct value in callback');
      assert.same(key, 0, 'correct index in callback');
      assert.same(that, a, 'correct link to array in callback');
      return assert.same(this, ctx, 'correct callback context');
    }
    function fn1$(it){
      return it % 2;
    }
    function fn2$(a, b){
      v += a;
      k += b;
    }
    function fn3$(){
      Typed.prototype.filter.call([0], function(){
        return true;
      });
    }
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, this$ = this;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('%TypedArrayPrototype%.findIndex', function(assert){
    var global, i$, x$, ref$, len$, Typed, a, ctx, v, k;
    global = Function('return this')();
    for (i$ = 0, len$ = (ref$ = ['Float32Array', 'Float64Array', 'Int8Array', 'Int16Array', 'Int32Array', 'Uint8Array', 'Uint16Array', 'Uint32Array', 'Uint8ClampedArray']).length; i$ < len$; ++i$) {
      x$ = ref$[i$];
      Typed = global[x$];
      assert.isFunction(Typed.prototype.findIndex, x$ + "::findIndex is function");
      assert.arity(Typed.prototype.findIndex, 1, x$ + "::findIndex arity is 1");
      assert.name(Typed.prototype.findIndex, 'findIndex', x$ + "::findIndex name is 'findIndex'");
      assert.looksNative(Typed.prototype.findIndex, x$ + "::findIndex looks native");
      (a = new Typed([1])).findIndex(fn$, ctx = {});
      assert.same(new Typed([1, 2, 3]).findIndex(fn1$), 1);
      assert.same(new Typed([1, 2, 3]).findIndex((fn2$)), -1);
      v = '';
      k = '';
      new Typed([1, 2, 3]).findIndex(fn3$);
      assert.same(v, '123');
      assert.same(k, '012');
      assert.throws(fn4$, "isn't generic");
    }
    function fn$(val, key, that){
      assert.same(arguments.length, 3, 'correct number of callback arguments');
      assert.same(val, 1, 'correct value in callback');
      assert.same(key, 0, 'correct index in callback');
      assert.same(that, a, 'correct link to array in callback');
      return assert.same(this, ctx, 'correct callback context');
    }
    function fn1$(it){
      return !(it % 2);
    }
    function fn2$(it){
      return it === 4;
    }
    function fn3$(a, b){
      v += a;
      k += b;
    }
    function fn4$(){
      Typed.prototype.findIndex.call([0], function(){
        return true;
      });
    }
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, this$ = this;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('%TypedArrayPrototype%.find', function(assert){
    var global, i$, x$, ref$, len$, Typed, a, ctx, v, k;
    global = Function('return this')();
    for (i$ = 0, len$ = (ref$ = ['Float32Array', 'Float64Array', 'Int8Array', 'Int16Array', 'Int32Array', 'Uint8Array', 'Uint16Array', 'Uint32Array', 'Uint8ClampedArray']).length; i$ < len$; ++i$) {
      x$ = ref$[i$];
      Typed = global[x$];
      assert.isFunction(Typed.prototype.find, x$ + "::find is function");
      assert.arity(Typed.prototype.find, 1, x$ + "::find arity is 1");
      assert.name(Typed.prototype.find, 'find', x$ + "::find name is 'find'");
      assert.looksNative(Typed.prototype.find, x$ + "::find looks native");
      (a = new Typed([1])).find(fn$, ctx = {});
      assert.same(new Typed([1, 2, 3]).find(fn1$), 2);
      assert.same(new Typed([1, 2, 3]).find((fn2$)), void 8);
      v = '';
      k = '';
      new Typed([1, 2, 3]).find(fn3$);
      assert.same(v, '123');
      assert.same(k, '012');
      assert.throws(fn4$, "isn't generic");
    }
    function fn$(val, key, that){
      assert.same(arguments.length, 3, 'correct number of callback arguments');
      assert.same(val, 1, 'correct value in callback');
      assert.same(key, 0, 'correct index in callback');
      assert.same(that, a, 'correct link to array in callback');
      return assert.same(this, ctx, 'correct callback context');
    }
    function fn1$(it){
      return !(it % 2);
    }
    function fn2$(it){
      return it === 4;
    }
    function fn3$(a, b){
      v += a;
      k += b;
    }
    function fn4$(){
      Typed.prototype.find.call([0], function(){
        return true;
      });
    }
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, this$ = this;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('%TypedArrayPrototype%.forEach', function(assert){
    var global, i$, x$, ref$, len$, Typed, a, ctx, v, k;
    global = Function('return this')();
    for (i$ = 0, len$ = (ref$ = ['Float32Array', 'Float64Array', 'Int8Array', 'Int16Array', 'Int32Array', 'Uint8Array', 'Uint16Array', 'Uint32Array', 'Uint8ClampedArray']).length; i$ < len$; ++i$) {
      x$ = ref$[i$];
      Typed = global[x$];
      assert.isFunction(Typed.prototype.forEach, x$ + "::forEach is function");
      assert.arity(Typed.prototype.forEach, 1, x$ + "::forEach arity is 1");
      assert.name(Typed.prototype.forEach, 'forEach', x$ + "::forEach name is 'forEach'");
      assert.looksNative(Typed.prototype.forEach, x$ + "::forEach looks native");
      assert.same(new Typed([1]).forEach(fn$), void 8, 'void');
      (a = new Typed([1])).forEach(fn1$, ctx = {});
      v = '';
      k = '';
      new Typed([1, 2, 3]).forEach(fn2$);
      assert.same(v, '123');
      assert.same(k, '012');
      assert.throws(fn3$, "isn't generic");
    }
    function fn$(){}
    function fn1$(val, key, that){
      assert.same(arguments.length, 3, 'correct number of callback arguments');
      assert.same(val, 1, 'correct value in callback');
      assert.same(key, 0, 'correct index in callback');
      assert.same(that, a, 'correct link to array in callback');
      return assert.same(this, ctx, 'correct callback context');
    }
    function fn2$(a, b){
      v += a;
      k += b;
    }
    function fn3$(){
      Typed.prototype.forEach.call([0], function(){
        return true;
      });
    }
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, this$ = this;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('%TypedArray%.from', function(assert){
    var global, i$, x$, ref$, len$, Typed, inst, O;
    global = Function('return this')();
    for (i$ = 0, len$ = (ref$ = ['Float32Array', 'Float64Array', 'Int8Array', 'Int16Array', 'Int32Array', 'Uint8Array', 'Uint16Array', 'Uint32Array', 'Uint8ClampedArray']).length; i$ < len$; ++i$) {
      x$ = ref$[i$];
      Typed = global[x$];
      assert.isFunction(Typed.from, x$ + ".from is function");
      assert.arity(Typed.from, 1, x$ + ".from arity is 1");
      assert.name(Typed.from, 'from', x$ + ".from name is 'from'");
      assert.looksNative(Typed.from, x$ + ".from looks native");
      inst = Typed.from([1, 2, 3]);
      assert.ok(inst instanceof Typed, 'correct instance with array');
      assert.arrayEqual(inst, [1, 2, 3], 'correct elements with array');
      inst = Typed.from({
        0: 1,
        1: 2,
        2: 3,
        length: 3
      });
      assert.ok(inst instanceof Typed, 'correct instance with array-like');
      assert.arrayEqual(inst, [1, 2, 3], 'correct elements with array-like');
      inst = Typed.from(createIterable([1, 2, 3]));
      assert.ok(inst instanceof Typed, 'correct instance with iterable');
      assert.arrayEqual(inst, [1, 2, 3], 'correct elements with iterable');
      assert.arrayEqual(Typed.from([1, 2, 3], fn$), [1, 4, 9], 'accept callback');
      Typed.from([1], fn1$, O = {});
      assert.throws(fn2$, "isn't generic #1");
      if (typeof NATIVE != 'undefined' && NATIVE !== null) {
        assert.throws(fn3$, "isn't generic #2");
        assert.ok((fn4$()), 'uses ToLength');
      }
    }
    function fn$(it){
      return it * it;
    }
    function fn1$(a, b){
      assert.same(arguments.length, 2, 'correct number of callback arguments');
      assert.same(a, 1, 'correct value in callback');
      assert.same(b, 0, 'correct index in callback');
      return assert.same(this, O, 'correct callback context');
    }
    function fn2$(){
      Typed.from.call(void 8, []);
    }
    function fn3$(){
      Typed.from.call(Array, []);
    }
    function fn4$(){
      try {
        return Typed.from({
          length: -1,
          0: 1
        }, function(){
          throw 42;
        });
      } catch (e$) {}
    }
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, this$ = this;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('%TypedArrayPrototype%.indexOf', function(assert){
    var global, i$, x$, ref$, len$, Typed;
    global = Function('return this')();
    for (i$ = 0, len$ = (ref$ = ['Float32Array', 'Float64Array', 'Int8Array', 'Int16Array', 'Int32Array', 'Uint8Array', 'Uint16Array', 'Uint32Array', 'Uint8ClampedArray']).length; i$ < len$; ++i$) {
      x$ = ref$[i$];
      Typed = global[x$];
      assert.isFunction(Typed.prototype.indexOf, x$ + "::indexOf is function");
      assert.arity(Typed.prototype.indexOf, 1, x$ + "::indexOf arity is 1");
      assert.name(Typed.prototype.indexOf, 'indexOf', x$ + "::indexOf name is 'indexOf'");
      assert.looksNative(Typed.prototype.indexOf, x$ + "::indexOf looks native");
      assert.same(new Typed([1, 1, 1]).indexOf(1), 0);
      assert.same(new Typed([1, 2, 3]).indexOf(1, 1), -1);
      assert.same(new Typed([1, 2, 3]).indexOf(2, 1), 1);
      assert.same(new Typed([1, 2, 3]).indexOf(2, -1), -1);
      assert.same(new Typed([1, 2, 3]).indexOf(2, -2), 1);
      assert.throws(fn$, "isn't generic");
    }
    function fn$(){
      Typed.prototype.indexOf.call([1, 2], 1);
    }
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, global, arrays;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  global = Function('return this')();
  arrays = ['Float32Array', 'Float64Array', 'Int8Array', 'Int16Array', 'Int32Array', 'Uint8Array', 'Uint16Array', 'Uint32Array', 'Uint8ClampedArray'];
  test('%TypedArrayPrototype%.keys', function(assert){
    var i$, x$, ref$, len$, Typed, iter;
    for (i$ = 0, len$ = (ref$ = arrays).length; i$ < len$; ++i$) {
      x$ = ref$[i$];
      Typed = global[x$];
      assert.isFunction(Typed.prototype.keys, x$ + "::keys is function");
      assert.arity(Typed.prototype.keys, 0, x$ + "::keys arity is 0");
      assert.name(Typed.prototype.keys, 'keys', x$ + "::keys name is 'keys'");
      assert.looksNative(Typed.prototype.keys, x$ + "::keys looks native");
      iter = new Typed([1, 2, 3]).keys();
      assert.isIterator(iter);
      assert.isIterable(iter);
      assert.strictEqual(iter[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.toStringTag : void 8], 'Array Iterator');
      assert.deepEqual(iter.next(), {
        value: 0,
        done: false
      }, 'step 1');
      assert.deepEqual(iter.next(), {
        value: 1,
        done: false
      }, 'step 2');
      assert.deepEqual(iter.next(), {
        value: 2,
        done: false
      }, 'step 3');
      assert.deepEqual(iter.next(), {
        value: void 8,
        done: true
      }, 'done');
      (typeof NATIVE != 'undefined' && NATIVE !== null) && assert.throws(fn$, "isn't generic");
    }
    function fn$(){
      Typed.prototype.keys.call([1, 2]);
    }
  });
  test('%TypedArrayPrototype%.values', function(assert){
    var i$, x$, ref$, len$, Typed, iter;
    for (i$ = 0, len$ = (ref$ = arrays).length; i$ < len$; ++i$) {
      x$ = ref$[i$];
      Typed = global[x$];
      assert.isFunction(Typed.prototype.values, x$ + "::values is function");
      assert.arity(Typed.prototype.values, 0, x$ + "::values arity is 0");
      assert.name(Typed.prototype.values, 'values', x$ + "::values name is 'values'");
      assert.looksNative(Typed.prototype.values, x$ + "::values looks native");
      iter = new Typed([1, 2, 3]).values();
      assert.isIterator(iter);
      assert.isIterable(iter);
      assert.strictEqual(iter[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.toStringTag : void 8], 'Array Iterator');
      assert.deepEqual(iter.next(), {
        value: 1,
        done: false
      }, 'step 1');
      assert.deepEqual(iter.next(), {
        value: 2,
        done: false
      }, 'step 2');
      assert.deepEqual(iter.next(), {
        value: 3,
        done: false
      }, 'step 3');
      assert.deepEqual(iter.next(), {
        value: void 8,
        done: true
      }, 'done');
      (typeof NATIVE != 'undefined' && NATIVE !== null) && assert.throws(fn$, "isn't generic");
    }
    function fn$(){
      Typed.prototype.values.call([1, 2]);
    }
  });
  test('%TypedArrayPrototype%.entries', function(assert){
    var i$, x$, ref$, len$, Typed, iter;
    for (i$ = 0, len$ = (ref$ = arrays).length; i$ < len$; ++i$) {
      x$ = ref$[i$];
      Typed = global[x$];
      assert.isFunction(Typed.prototype.entries, x$ + "::entries is function");
      assert.arity(Typed.prototype.entries, 0, x$ + "::entries arity is 0");
      assert.name(Typed.prototype.entries, 'entries', x$ + "::entries name is 'entries'");
      assert.looksNative(Typed.prototype.entries, x$ + "::entries looks native");
      iter = new Typed([1, 2, 3]).entries();
      assert.isIterator(iter);
      assert.isIterable(iter);
      assert.strictEqual(iter[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.toStringTag : void 8], 'Array Iterator');
      assert.deepEqual(iter.next(), {
        value: [0, 1],
        done: false
      }, 'step 1');
      assert.deepEqual(iter.next(), {
        value: [1, 2],
        done: false
      }, 'step 2');
      assert.deepEqual(iter.next(), {
        value: [2, 3],
        done: false
      }, 'step 3');
      assert.deepEqual(iter.next(), {
        value: void 8,
        done: true
      }, 'done');
      (typeof NATIVE != 'undefined' && NATIVE !== null) && assert.throws(fn$, "isn't generic");
    }
    function fn$(){
      Typed.prototype.entries.call([1, 2]);
    }
  });
  test('%TypedArrayPrototype%.@@iterator', function(assert){
    var i$, x$, ref$, len$, Typed, iter;
    for (i$ = 0, len$ = (ref$ = arrays).length; i$ < len$; ++i$) {
      x$ = ref$[i$];
      Typed = global[x$];
      assert.isIterable(Typed.prototype, x$ + " is itrable");
      assert.arity(Typed.prototype[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.iterator : void 8], 0, x$ + "::@@iterator arity is 0");
      assert.name(Typed.prototype[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.iterator : void 8], 'values', x$ + "::@@iterator name is 'values'");
      assert.looksNative(Typed.prototype[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.iterator : void 8], x$ + "::@@iterator looks native");
      assert.strictEqual(Typed.prototype[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.iterator : void 8], Typed.prototype.values);
      iter = new Typed([1, 2, 3])[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.iterator : void 8]();
      assert.isIterator(iter);
      assert.isIterable(iter);
      assert.strictEqual(iter[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.toStringTag : void 8], 'Array Iterator');
      assert.deepEqual(iter.next(), {
        value: 1,
        done: false
      }, 'step 1');
      assert.deepEqual(iter.next(), {
        value: 2,
        done: false
      }, 'step 2');
      assert.deepEqual(iter.next(), {
        value: 3,
        done: false
      }, 'step 3');
      assert.deepEqual(iter.next(), {
        value: void 8,
        done: true
      }, 'done');
      (typeof NATIVE != 'undefined' && NATIVE !== null) && assert.throws(fn$, "isn't generic");
    }
    function fn$(){
      Typed.prototype[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.iterator : void 8].call([1, 2]);
    }
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, this$ = this;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('%TypedArrayPrototype%.join', function(assert){
    var global, i$, x$, ref$, len$, Typed;
    global = Function('return this')();
    for (i$ = 0, len$ = (ref$ = ['Float32Array', 'Float64Array', 'Int8Array', 'Int16Array', 'Int32Array', 'Uint8Array', 'Uint16Array', 'Uint32Array', 'Uint8ClampedArray']).length; i$ < len$; ++i$) {
      x$ = ref$[i$];
      Typed = global[x$];
      assert.isFunction(Typed.prototype.join, x$ + "::join is function");
      assert.arity(Typed.prototype.join, 1, x$ + "::join arity is 1");
      assert.name(Typed.prototype.join, 'join', x$ + "::join name is 'join'");
      assert.looksNative(Typed.prototype.join, x$ + "::join looks native");
      assert.same(new Typed([1, 2, 3]).join('|'), '1|2|3', 'works #1');
      assert.same(new Typed([1, 2, 3]).join(), '1,2,3', 'works #2');
      assert.throws(fn$, "isn't generic");
    }
    function fn$(){
      Typed.prototype.join.call([1, 2, 3]);
    }
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, this$ = this;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('%TypedArrayPrototype%.lastIndexOf', function(assert){
    var global, i$, x$, ref$, len$, Typed;
    global = Function('return this')();
    for (i$ = 0, len$ = (ref$ = ['Float32Array', 'Float64Array', 'Int8Array', 'Int16Array', 'Int32Array', 'Uint8Array', 'Uint16Array', 'Uint32Array', 'Uint8ClampedArray']).length; i$ < len$; ++i$) {
      x$ = ref$[i$];
      Typed = global[x$];
      assert.isFunction(Typed.prototype.lastIndexOf, x$ + "::lastIndexOf is function");
      assert.arity(Typed.prototype.lastIndexOf, 1, x$ + "::lastIndexOf arity is 1");
      assert.name(Typed.prototype.lastIndexOf, 'lastIndexOf', x$ + "::lastIndexOf name is 'lastIndexOf'");
      assert.looksNative(Typed.prototype.lastIndexOf, x$ + "::lastIndexOf looks native");
      assert.same(new Typed([1, 1, 1]).lastIndexOf(1), 2);
      assert.same(new Typed([1, 2, 3]).lastIndexOf(3, 1), -1);
      assert.same(new Typed([1, 2, 3]).lastIndexOf(2, 1), 1);
      assert.same(new Typed([1, 2, 3]).lastIndexOf(2, -3), -1);
      assert.same(new Typed([1, 2, 3]).lastIndexOf(2, -2), 1);
      assert.throws(fn$, "isn't generic");
    }
    function fn$(){
      Typed.prototype.lastIndexOf.call([1, 2], 1);
    }
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, this$ = this;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('%TypedArrayPrototype%.map', function(assert){
    var global, i$, x$, ref$, len$, Typed, a, ctx, instance, v, k;
    global = Function('return this')();
    for (i$ = 0, len$ = (ref$ = ['Float32Array', 'Float64Array', 'Int8Array', 'Int16Array', 'Int32Array', 'Uint8Array', 'Uint16Array', 'Uint32Array', 'Uint8ClampedArray']).length; i$ < len$; ++i$) {
      x$ = ref$[i$];
      Typed = global[x$];
      assert.isFunction(Typed.prototype.map, x$ + "::map is function");
      assert.arity(Typed.prototype.map, 1, x$ + "::map arity is 1");
      assert.name(Typed.prototype.map, 'map', x$ + "::map name is 'map'");
      assert.looksNative(Typed.prototype.map, x$ + "::map looks native");
      (a = new Typed([1])).map(fn$, ctx = {});
      instance = new Typed([1, 2, 3, 4, 5]).map((fn1$));
      assert.ok(instance instanceof Typed, 'correct instance');
      assert.arrayEqual(instance, [2, 4, 6, 8, 10], 'works');
      v = '';
      k = '';
      new Typed([1, 2, 3]).map(fn2$);
      assert.same(v, '123');
      assert.same(k, '012');
      assert.throws(fn3$, "isn't generic");
    }
    function fn$(val, key, that){
      assert.same(arguments.length, 3, 'correct number of callback arguments');
      assert.same(val, 1, 'correct value in callback');
      assert.same(key, 0, 'correct index in callback');
      assert.same(that, a, 'correct link to array in callback');
      return assert.same(this, ctx, 'correct callback context');
    }
    function fn1$(it){
      return it * 2;
    }
    function fn2$(a, b){
      v += a;
      k += b;
    }
    function fn3$(){
      Typed.prototype.map.call([0], function(){
        return true;
      });
    }
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, this$ = this;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('%TypedArray%.of', function(assert){
    var global, i$, x$, ref$, len$, Typed, inst;
    global = Function('return this')();
    for (i$ = 0, len$ = (ref$ = ['Float32Array', 'Float64Array', 'Int8Array', 'Int16Array', 'Int32Array', 'Uint8Array', 'Uint16Array', 'Uint32Array', 'Uint8ClampedArray']).length; i$ < len$; ++i$) {
      x$ = ref$[i$];
      Typed = global[x$];
      assert.isFunction(Typed.of, x$ + ".of is function");
      assert.arity(Typed.of, 0, x$ + ".of arity is 0");
      assert.name(Typed.of, 'of', x$ + ".of name is 'of'");
      assert.looksNative(Typed.of, x$ + ".of looks native");
      inst = Typed.of();
      assert.ok(inst instanceof Typed, 'correct instance with 0 arguments');
      assert.arrayEqual(inst, [], 'correct elements with 0 arguments');
      inst = Typed.of(1);
      assert.ok(inst instanceof Typed, 'correct instance with 1 argument');
      assert.arrayEqual(inst, [1], 'correct elements with 1 argument');
      inst = Typed.of(1, 2, 3);
      assert.ok(inst instanceof Typed, 'correct instance with several arguments');
      assert.arrayEqual(inst, [1, 2, 3], 'correct elements with several arguments');
      assert.throws(fn$, "isn't generic #1");
      (typeof NATIVE != 'undefined' && NATIVE !== null) && assert.throws(fn1$, "isn't generic #2");
    }
    function fn$(){
      Typed.of.call(void 8, 1);
    }
    function fn1$(){
      Typed.of.call(Array, 1);
    }
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, this$ = this;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('%TypedArrayPrototype%.reduceRight', function(assert){
    var global, i$, x$, ref$, len$, Typed, a, accumulator, v, k, fn1$ = curry$(function(x$, y$){
      return x$ + y$;
    }), fn3$ = curry$(function(x$, y$){
      return x$ + y$;
    });
    global = Function('return this')();
    for (i$ = 0, len$ = (ref$ = ['Float32Array', 'Float64Array', 'Int8Array', 'Int16Array', 'Int32Array', 'Uint8Array', 'Uint16Array', 'Uint32Array', 'Uint8ClampedArray']).length; i$ < len$; ++i$) {
      x$ = ref$[i$];
      Typed = global[x$];
      assert.isFunction(Typed.prototype.reduceRight, x$ + "::reduceRight is function");
      assert.arity(Typed.prototype.reduceRight, 1, x$ + "::reduceRight arity is 1");
      assert.name(Typed.prototype.reduceRight, 'reduceRight', x$ + "::reduceRight name is 'reduceRight'");
      assert.looksNative(Typed.prototype.reduceRight, x$ + "::reduceRight looks native");
      (a = new Typed([1])).reduceRight(fn$, accumulator = {});
      assert.same(new Typed([1, 2, 3]).reduceRight(fn1$, 1), 7, 'works with initial accumulator');
      (a = new Typed([1, 2])).reduceRight(fn2$);
      assert.same(new Typed([1, 2, 3]).reduceRight(fn3$), 6, 'works without initial accumulator');
      v = '';
      k = '';
      new Typed([1, 2, 3]).reduceRight(fn4$, 0);
      assert.same(v, '321', 'correct order #1');
      assert.same(k, '210', 'correct order #2');
      assert.throws(fn5$, "isn't generic");
    }
    function fn$(memo, val, key, that){
      assert.same(arguments.length, 4, 'correct number of callback arguments');
      assert.same(memo, accumulator, 'correct callback accumulator');
      assert.same(val, 1, 'correct value in callback');
      assert.same(key, 0, 'correct index in callback');
      return assert.same(that, a, 'correct link to array in callback');
    }
    function fn2$(memo, val, key, that){
      assert.same(memo, 2, 'correct default accumulator');
      assert.same(val, 1, 'correct start value without initial accumulator');
      return assert.same(key, 0, 'correct start index without initial accumulator');
    }
    function fn4$(memo, a, b){
      v += a;
      k += b;
    }
    function fn5$(){
      Typed.prototype.reduceRight.call([0], function(){
        return true;
      });
    }
  });
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, this$ = this;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('%TypedArrayPrototype%.reduce', function(assert){
    var global, i$, x$, ref$, len$, Typed, a, accumulator, v, k, fn1$ = curry$(function(x$, y$){
      return x$ + y$;
    }), fn3$ = curry$(function(x$, y$){
      return x$ + y$;
    });
    global = Function('return this')();
    for (i$ = 0, len$ = (ref$ = ['Float32Array', 'Float64Array', 'Int8Array', 'Int16Array', 'Int32Array', 'Uint8Array', 'Uint16Array', 'Uint32Array', 'Uint8ClampedArray']).length; i$ < len$; ++i$) {
      x$ = ref$[i$];
      Typed = global[x$];
      assert.isFunction(Typed.prototype.reduce, x$ + "::reduce is function");
      assert.arity(Typed.prototype.reduce, 1, x$ + "::reduce arity is 1");
      assert.name(Typed.prototype.reduce, 'reduce', x$ + "::reduce name is 'reduce'");
      assert.looksNative(Typed.prototype.reduce, x$ + "::reduce looks native");
      (a = new Typed([1])).reduce(fn$, accumulator = {});
      assert.same(new Typed([1, 2, 3]).reduce(fn1$, 1), 7, 'works with initial accumulator');
      (a = new Typed([1, 2])).reduce(fn2$);
      assert.same(new Typed([1, 2, 3]).reduce(fn3$), 6, 'works without initial accumulator');
      v = '';
      k = '';
      new Typed([1, 2, 3]).reduce(fn4$, 0);
      assert.same(v, '123', 'correct order #1');
      assert.same(k, '012', 'correct order #2');
      assert.throws(fn5$, "isn't generic");
    }
    function fn$(memo, val, key, that){
      assert.same(arguments.length, 4, 'correct number of callback arguments');
      assert.same(memo, accumulator, 'correct callback accumulator');
      assert.same(val, 1, 'correct value in callback');
      assert.same(key, 0, 'correct index in callback');
      return assert.same(that, a, 'correct link to array in callback');
    }
    function fn2$(memo, val, key, that){
      assert.same(memo, 1, 'correct default accumulator');
      assert.same(val, 2, 'correct start value without initial accumulator');
      return assert.same(key, 1, 'correct start index without initial accumulator');
    }
    function fn4$(memo, a, b){
      v += a;
      k += b;
    }
    function fn5$(){
      Typed.prototype.reduce.call([0], function(){
        return true;
      });
    }
  });
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, this$ = this;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('%TypedArrayPrototype%.reverse', function(assert){
    var global, i$, x$, ref$, len$, Typed, a;
    global = Function('return this')();
    for (i$ = 0, len$ = (ref$ = ['Float32Array', 'Float64Array', 'Int8Array', 'Int16Array', 'Int32Array', 'Uint8Array', 'Uint16Array', 'Uint32Array', 'Uint8ClampedArray']).length; i$ < len$; ++i$) {
      x$ = ref$[i$];
      Typed = global[x$];
      assert.isFunction(Typed.prototype.reverse, x$ + "::reverse is function");
      assert.arity(Typed.prototype.reverse, 0, x$ + "::reverse arity is 0");
      assert.name(Typed.prototype.reverse, 'reverse', x$ + "::reverse name is 'reverse'");
      assert.looksNative(Typed.prototype.reverse, x$ + "::reverse looks native");
      assert.same((a = new Typed([1, 2])).reverse(), a, 'return this');
      assert.arrayEqual(new Typed([1, 2, 3, 4]).reverse(), [4, 3, 2, 1], 'works #1');
      assert.arrayEqual(new Typed([1, 2, 3]).reverse(), [3, 2, 1], 'works #2');
      assert.throws(fn$, "isn't generic");
    }
    function fn$(){
      Typed.prototype.reverse.call([1, 2]);
    }
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, this$ = this;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('%TypedArrayPrototype%.set', function(assert){
    var global, i$, x$, ref$, len$, Typed, a, b, y$;
    global = Function('return this')();
    for (i$ = 0, len$ = (ref$ = ['Float32Array', 'Float64Array', 'Int8Array', 'Int16Array', 'Int32Array', 'Uint8Array', 'Uint16Array', 'Uint32Array', 'Uint8ClampedArray']).length; i$ < len$; ++i$) {
      x$ = ref$[i$];
      Typed = global[x$];
      assert.isFunction(Typed.prototype.set, x$ + "::set is function");
      (typeof NATIVE != 'undefined' && NATIVE !== null) && assert.arity(Typed.prototype.set, 1, x$ + "::set arity is 1");
      assert.name(Typed.prototype.set, 'set', x$ + "::set name is 'subarray'");
      assert.looksNative(Typed.prototype.set, x$ + "::set looks native");
      assert.same(new Typed(1).set([1]), void 8, 'void');
      a = new Typed([1, 2, 3, 4, 5]);
      b = new Typed(5);
      b.set(a);
      assert.arrayEqual(b, [1, 2, 3, 4, 5]);
      assert.throws(fn$);
      assert.throws(fn1$);
      b.set(new Typed([99, 98]), 2);
      assert.arrayEqual(b, [1, 2, 99, 98, 5]);
      b.set(new Typed([99, 98, 97]), 2);
      assert.arrayEqual(b, [1, 2, 99, 98, 97]);
      assert.throws(fn2$);
      assert.throws(fn3$);
      assert.arrayEqual((y$ = new Typed(2), y$.set({
        length: 2,
        0: 1,
        1: 2
      }), y$), [1, 2]);
      assert.throws(fn4$, "isn't generic");
    }
    function fn$(){
      b.set(a, 1);
    }
    function fn1$(){
      b.set(a, -1);
    }
    function fn2$(){
      b.set(new Typed([99, 98, 97, 96]), 2);
    }
    function fn3$(){
      b.set([101, 102, 103, 104], 4);
    }
    function fn4$(){
      Typed.prototype.set.call([1, 2, 3], [1]);
    }
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, this$ = this;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('%TypedArrayPrototype%.some', function(assert){
    var global, i$, x$, ref$, len$, Typed, a, ctx, v, k, arr;
    global = Function('return this')();
    for (i$ = 0, len$ = (ref$ = ['Float32Array', 'Float64Array', 'Int8Array', 'Int16Array', 'Int32Array', 'Uint8Array', 'Uint16Array', 'Uint32Array', 'Uint8ClampedArray']).length; i$ < len$; ++i$) {
      x$ = ref$[i$];
      Typed = global[x$];
      assert.isFunction(Typed.prototype.some, x$ + "::some is function");
      assert.arity(Typed.prototype.some, 1, x$ + "::some arity is 1");
      assert.name(Typed.prototype.some, 'some', x$ + "::some name is 'some'");
      assert.looksNative(Typed.prototype.some, x$ + "::some looks native");
      (a = new Typed([1])).some(fn$, ctx = {});
      assert.ok(new Typed([1, 2, 3]).some(fn1$));
      assert.ok(new Typed([1, 2, 3]).some((fn2$)));
      assert.ok(!new Typed([1, 2, 3]).some((fn3$)));
      assert.ok(!new Typed([1, 2, 3]).some(fn4$));
      v = '';
      k = '';
      new Typed([1, 2, 3]).some(fn5$);
      assert.same(v, '123');
      assert.same(k, '012');
      assert.ok((arr = new Typed([1, 2, 3])).some(fn6$));
      assert.throws(fn7$, "isn't generic");
    }
    function fn$(val, key, that){
      assert.same(arguments.length, 3, 'correct number of callback arguments');
      assert.same(val, 1, 'correct value in callback');
      assert.same(key, 0, 'correct index in callback');
      assert.same(that, a, 'correct link to array in callback');
      return assert.same(this, ctx, 'correct callback context');
    }
    function fn1$(it){
      return typeof it === 'number';
    }
    function fn2$(it){
      return it < 3;
    }
    function fn3$(it){
      return it < 0;
    }
    function fn4$(it){
      return typeof it === 'string';
    }
    function fn5$(a, b){
      v += a;
      k += b;
    }
    function fn6$(){
      return arguments[2] === arr;
    }
    function fn7$(){
      Typed.prototype.some.call([0], function(){
        return true;
      });
    }
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, this$ = this;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('%TypedArrayPrototype%.subarray', function(assert){
    var global, i$, x$, ref$, len$, Typed, a, b;
    global = Function('return this')();
    for (i$ = 0, len$ = (ref$ = ['Float32Array', 'Float64Array', 'Int8Array', 'Int16Array', 'Int32Array', 'Uint8Array', 'Uint16Array', 'Uint32Array', 'Uint8ClampedArray']).length; i$ < len$; ++i$) {
      x$ = ref$[i$];
      Typed = global[x$];
      assert.isFunction(Typed.prototype.subarray, x$ + "::subarray is function");
      assert.arity(Typed.prototype.subarray, 2, x$ + "::subarray arity is 2");
      assert.name(Typed.prototype.subarray, 'subarray', x$ + "::subarray name is 'subarray'");
      assert.looksNative(Typed.prototype.subarray, x$ + "::subarray looks native");
      a = new Typed([1, 2, 3, 4, 5]);
      b = a.subarray(3);
      assert.ok(a !== b, 'creates new array');
      assert.ok(b instanceof Typed, "instance " + x$);
      assert.same(a.buffer, b.buffer, 'with the same buffer');
      assert.arrayEqual(b, [4, 5]);
      assert.arrayEqual(a.subarray(1, 3), [2, 3]);
      assert.arrayEqual(a.subarray(-3), [3, 4, 5]);
      assert.arrayEqual(a.subarray(-3, -1), [3, 4]);
      assert.arrayEqual(a.subarray(3, 2), []);
      assert.arrayEqual(a.subarray(-2, -3), []);
      assert.arrayEqual(a.subarray(4, 1), []);
      assert.arrayEqual(a.subarray(-1, -4), []);
      assert.arrayEqual(a.subarray(1).subarray(1), [3, 4, 5]);
      assert.arrayEqual(a.subarray(1, 4).subarray(1, 2), [3]);
      assert.throws(fn$, "isn't generic");
    }
    function fn$(){
      Typed.prototype.subarray.call([1, 2, 3], 1);
    }
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, this$ = this;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('%TypedArrayPrototype%.toLocaleString', function(assert){
    var global, i$, x$, ref$, len$, Typed;
    global = Function('return this')();
    for (i$ = 0, len$ = (ref$ = ['Float32Array', 'Float64Array', 'Int8Array', 'Int16Array', 'Int32Array', 'Uint8Array', 'Uint16Array', 'Uint32Array', 'Uint8ClampedArray']).length; i$ < len$; ++i$) {
      x$ = ref$[i$];
      Typed = global[x$];
      assert.isFunction(Typed.prototype.toLocaleString, x$ + "::toLocaleString is function");
      assert.arity(Typed.prototype.toLocaleString, 0, x$ + "::toLocaleString arity is 0");
      assert.name(Typed.prototype.toLocaleString, 'toLocaleString', x$ + "::toLocaleString name is 'toLocaleString'");
      assert.looksNative(Typed.prototype.toLocaleString, x$ + "::toLocaleString looks native");
      assert.same(new Typed([1, 2, 3]).toLocaleString(), '1,2,3', 'works');
      assert.throws(fn$, "isn't generic");
    }
    function fn$(){
      Typed.prototype.toLocaleString.call([1, 2, 3]);
    }
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, this$ = this;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('%TypedArrayPrototype%.toString', function(assert){
    var global, i$, x$, ref$, len$, Typed;
    global = Function('return this')();
    for (i$ = 0, len$ = (ref$ = ['Float32Array', 'Float64Array', 'Int8Array', 'Int16Array', 'Int32Array', 'Uint8Array', 'Uint16Array', 'Uint32Array', 'Uint8ClampedArray']).length; i$ < len$; ++i$) {
      x$ = ref$[i$];
      Typed = global[x$];
      assert.isFunction(Typed.prototype.toString, x$ + "::toString is function");
      assert.arity(Typed.prototype.toString, 0, x$ + "::toString arity is 0");
      assert.name(Typed.prototype.toString, 'toString', x$ + "::toString name is 'toString'");
      assert.looksNative(Typed.prototype.toString, x$ + "::toString looks native");
      assert.same(new Typed([1, 2, 3]).toString(), '1,2,3', 'works');
      assert.same(Typed.prototype.toString.call([1, 2, 3]), '1,2,3', "generic");
    }
  });
}).call(this);
