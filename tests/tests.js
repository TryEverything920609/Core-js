// Generated by LiveScript 1.3.1
(function(){
  var module, test, timeLimitedPromise, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('core-js');
  timeLimitedPromise = function(time, fn){
    return Promise.race([
      new Promise(fn), new Promise(function(res, rej){
        return setTimeout(rej, time);
      })
    ]);
  };
  test('delay', function(assert){
    assert.expect(6);
    assert.ok(toString$.call(delay).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(delay.length, 1, 'arity is 1');
    assert.strictEqual(delay.name, 'delay', 'name is "delay"');
    assert.ok(/native code/.test(delay), 'looks like native');
    assert.ok(delay(42) instanceof Promise, 'returns promises');
    return timeLimitedPromise(1e3, function(res){
      delay(10).then(function(it){
        res(it);
      });
    }).then(function(it){
      return assert.ok(it === true, 'resolves as `true`');
    })['catch'](function(){
      return assert.ok(false, 'rejected');
    }).then(assert.async());
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, isFunction, keys, create, assign, from, global, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('core-js');
  isFunction = function(it){
    return toString$.call(it).slice(8, -1) === 'Function';
  };
  keys = Object.keys, create = Object.create, assign = Object.assign;
  from = Array.from;
  global = this;
  test('Dict', function(assert){
    var dict1, dict2, dict3, done, iter;
    assert.ok(isFunction(global.Dict), 'is function');
    assert.strictEqual(Dict.length, 1, 'arity is 1');
    assert.strictEqual(Dict.name, 'Dict', 'name is "Dict"');
    assert.ok(/native code/.test(Dict), 'looks like native');
    dict1 = Dict();
    assert.ok(!(dict1 instanceof Object));
    assert.deepEqual(keys(dict1), []);
    dict2 = Dict({
      q: 1,
      w: 2
    });
    assert.ok(!(dict2 instanceof Object));
    assert.deepEqual(keys(dict2), ['q', 'w']);
    assert.ok(dict2.q === 1);
    assert.ok(dict2.w === 2);
    dict3 = Dict(new Set([1, 2]).entries());
    assert.ok(!(dict3 instanceof Object));
    assert.deepEqual(keys(dict3), ['1', '2']);
    assert.ok(dict3[1] === 1);
    assert.ok(dict3[2] === 2);
    done = false;
    iter = [null, 1, 2].values();
    iter['return'] = function(){
      return done = true;
    };
    try {
      new Dict(iter);
    } catch (e$) {}
    return assert.ok(done, '.return #throw');
  });
  test('Dict.every', function(assert){
    var every, obj, ctx;
    every = Dict.every;
    assert.ok(isFunction(every), 'is function');
    every(obj = {
      q: 1
    }, function(val, key, that){
      assert.ok(val === 1);
      assert.ok(key === 'q');
      assert.ok(that === obj);
      return assert.ok(this === ctx);
    }, ctx = {});
    assert.ok(every({
      q: 1,
      w: 2,
      e: 3
    }, function(it){
      return toString$.call(it).slice(8, -1) === 'Number';
    }));
    return assert.ok(!every({
      q: 1,
      w: '2',
      e: 3
    }, function(it){
      return toString$.call(it).slice(8, -1) === 'Number';
    }));
  });
  test('Dict.filter', function(assert){
    var filter, obj, ctx;
    filter = Dict.filter;
    assert.ok(isFunction(filter), 'is function');
    filter(obj = {
      q: 1
    }, function(val, key, that){
      assert.ok(val === 1);
      assert.ok(key === 'q');
      assert.ok(that === obj);
      return assert.ok(this === ctx);
    }, ctx = {});
    return assert.deepEqual(filter({
      q: 1,
      w: 2,
      e: 3
    }, function(it){
      return it % 2;
    }), Dict({
      q: 1,
      e: 3
    }));
  });
  test('Dict.find', function(assert){
    var find, obj, ctx;
    find = Dict.find;
    assert.ok(isFunction(find), 'is function');
    find(obj = {
      q: 1
    }, function(val, key, that){
      assert.ok(val === 1);
      assert.ok(key === 'q');
      assert.ok(that === obj);
      return assert.ok(this === ctx);
    }, ctx = {});
    return assert.ok(find({
      q: 1,
      w: 2,
      e: 3
    }, function(it){
      return !(it % 2);
    }) === 2);
  });
  test('Dict.findKey', function(assert){
    var findKey, obj, ctx;
    findKey = Dict.findKey;
    assert.ok(isFunction(findKey), 'is function');
    findKey(obj = {
      q: 1
    }, function(val, key, that){
      assert.ok(val === 1);
      assert.ok(key === 'q');
      assert.ok(that === obj);
      return assert.ok(this === ctx);
    }, ctx = {});
    return assert.ok(findKey({
      q: 1,
      w: 2,
      e: 3
    }, function(it){
      return it === 2;
    }) === 'w');
  });
  test('Dict.forEach', function(assert){
    var forEach, obj, ctx, rez;
    forEach = Dict.forEach;
    assert.ok(isFunction(forEach), 'is function');
    forEach(obj = {
      q: 1
    }, function(val, key, that){
      assert.ok(val === 1);
      assert.ok(key === 'q');
      assert.ok(that === obj);
      assert.ok(this === ctx);
    }, ctx = {});
    rez = {};
    forEach({
      q: 1,
      w: 2
    }, function(){
      rez[arguments[1]] = arguments[0] + this;
    }, '_');
    assert.deepEqual(rez, {
      q: '1_',
      w: '2_'
    });
    rez = true;
    forEach(obj = {
      q: 1,
      w: 2
    }, function(){
      var rez;
      rez && (rez = obj === arguments[2]);
    });
    assert.ok(rez);
    rez = {};
    forEach(Object.make({
      e: 3
    }, {
      q: 1,
      w: 2
    }), function(){
      rez[arguments[1]] = arguments[0];
    });
    assert.ok(!('e' in rez));
    rez = {};
    forEach([1, 2], function(){
      rez[arguments[1]] = arguments[0];
    });
    assert.ok(!('length' in rez));
    rez = {};
    forEach('123', function(){
      rez[arguments[1]] = arguments[0];
    });
    return assert.ok('2' in rez);
  });
  test('Dict.keyOf', function(assert){
    var keyOf;
    keyOf = Dict.keyOf;
    assert.ok(isFunction(keyOf), 'is function');
    assert.ok(keyOf({
      q: 1,
      w: 2,
      e: 3
    }, 2) === 'w');
    assert.ok(keyOf({
      q: 1,
      w: 2,
      e: 3
    }, 4) === void 8);
    return assert.ok(keyOf({
      q: 1,
      w: 2,
      e: NaN
    }, NaN) === void 8);
  });
  test('Dict.map', function(assert){
    var map, obj, ctx;
    map = Dict.map;
    assert.ok(isFunction(map), 'is function');
    map(obj = {
      q: 1
    }, function(val, key, that){
      assert.ok(val === 1);
      assert.ok(key === 'q');
      assert.ok(that === obj);
      return assert.ok(this === ctx);
    }, ctx = {});
    return assert.deepEqual(map({
      q: 1,
      w: 2,
      e: 3
    }, (function(it){
      return Math.pow(it, 2);
    })), Dict({
      q: 1,
      w: 4,
      e: 9
    }));
  });
  test('Dict.mapPairs', function(assert){
    var mapPairs, obj, ctx;
    mapPairs = Dict.mapPairs;
    assert.ok(isFunction(mapPairs), 'is function');
    mapPairs(obj = {
      q: 1
    }, function(val, key, that){
      assert.ok(val === 1);
      assert.ok(key === 'q');
      assert.ok(that === obj);
      return assert.ok(this === ctx);
    }, ctx = {});
    return assert.deepEqual(mapPairs({
      q: 1,
      w: 2,
      e: 3
    }, function(v, k){
      return v !== 2 && [k + k, v * v];
    }), Dict({
      qq: 1,
      ee: 9
    }));
  });
  test('Dict.reduce', function(assert){
    var reduce, obj, foo, memo;
    reduce = Dict.reduce;
    assert.ok(isFunction(reduce), 'is function');
    reduce(obj = {
      a: 1
    }, function(memo, val, key, that){
      assert.ok(memo === foo);
      assert.ok(val === 1);
      assert.ok(key === 'a');
      return assert.ok(that === obj);
    }, foo = {});
    reduce({
      a: 1,
      b: 2
    }, function(memo, val, key){
      assert.ok(memo === 1);
      assert.ok(val === 2);
      return assert.ok(key === 'b');
    });
    reduce({
      q: 1,
      w: 2,
      e: 3
    }, function(that, it){
      that[it] = it;
      return that;
    }, memo = {});
    return assert.deepEqual(memo, {
      1: 1,
      2: 2,
      3: 3
    });
  });
  test('Dict.some', function(assert){
    var some, obj, ctx;
    some = Dict.some;
    assert.ok(isFunction(some), 'is function');
    some(obj = {
      q: 1
    }, function(val, key, that){
      assert.ok(val === 1);
      assert.ok(key === 'q');
      assert.ok(that === obj);
      return assert.ok(this === ctx);
    }, ctx = {});
    assert.ok(!some({
      q: 1,
      w: 2,
      e: 3
    }, function(it){
      return toString$.call(it).slice(8, -1) === 'String';
    }));
    return assert.ok(some({
      q: 1,
      w: '2',
      e: 3
    }, function(it){
      return toString$.call(it).slice(8, -1) === 'String';
    }));
  });
  test('Dict.includes', function(assert){
    var includes, dict, o;
    includes = Dict.includes;
    assert.ok(isFunction(includes), 'is function');
    dict = {
      q: 1,
      w: NaN,
      e: -0,
      r: o = {}
    };
    assert.ok(includes(dict, 1));
    assert.ok(includes(dict, -0));
    assert.ok(includes(dict, 0));
    assert.ok(includes(dict, NaN));
    assert.ok(includes(dict, o));
    assert.ok(!includes(dict, 4));
    assert.ok(!includes(dict, -0.5));
    return assert.ok(!includes(dict, {}));
  });
  test('Dict.has', function(assert){
    var has;
    has = Dict.has;
    assert.ok(isFunction(has), 'is function');
    assert.ok(has({
      q: 1
    }, 'q'));
    assert.ok(!has({
      q: 1
    }, 'w'));
    assert.ok(has([1], 0));
    assert.ok(!has([], 0));
    assert.ok(!has(clone$({
      q: 1
    }), 'q'));
    return assert.ok(!has({}, 'toString'));
  });
  test('Dict.get', function(assert){
    var get;
    get = Dict.get;
    assert.ok(isFunction(get), 'is function');
    assert.ok(get({
      q: 1
    }, 'q') === 1);
    assert.ok(get({
      q: 1
    }, 'w') === void 8);
    assert.ok(get([1], 0) === 1);
    assert.ok(get([], 0) === void 8);
    assert.ok(get(clone$({
      q: 1
    }), 'q') === void 8);
    return assert.ok(get({}, 'toString') === void 8);
  });
  test('Dict.values', function(assert){
    var values, iter;
    values = Dict.values;
    assert.ok(isFunction(values), 'is function');
    iter = values({});
    assert.ok(iter[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.toStringTag : void 8] === 'Dict Iterator');
    assert.ok('next' in iter);
    assert.deepEqual(from(values({
      q: 1,
      w: 2,
      e: 3
    })), [1, 2, 3]);
    assert.deepEqual(from(values(new String('qwe'))), ['q', 'w', 'e']);
    return assert.deepEqual(from(values(assign(create({
      q: 1,
      w: 2,
      e: 3
    }), {
      a: 4,
      s: 5,
      d: 6
    }))), [4, 5, 6]);
  });
  test('Dict.keys', function(assert){
    var keys, iter;
    keys = Dict.keys;
    assert.ok(isFunction(keys), 'is function');
    iter = keys({});
    assert.ok(iter[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.toStringTag : void 8] === 'Dict Iterator');
    assert.ok('next' in iter);
    assert.deepEqual(from(keys({
      q: 1,
      w: 2,
      e: 3
    })), ['q', 'w', 'e']);
    assert.deepEqual(from(keys(new String('qwe'))), ['0', '1', '2']);
    return assert.deepEqual(from(keys(assign(create({
      q: 1,
      w: 2,
      e: 3
    }), {
      a: 4,
      s: 5,
      d: 6
    }))), ['a', 's', 'd']);
  });
  test('Dict.entries', function(assert){
    var entries, iter;
    entries = Dict.entries;
    assert.ok(isFunction(entries), 'is function');
    iter = entries({});
    assert.ok(iter[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.toStringTag : void 8] === 'Dict Iterator');
    assert.ok('next' in iter);
    assert.deepEqual(from(entries({
      q: 1,
      w: 2,
      e: 3
    })), [['q', 1], ['w', 2], ['e', 3]]);
    assert.deepEqual(from(entries(new String('qwe'))), [['0', 'q'], ['1', 'w'], ['2', 'e']]);
    return assert.deepEqual(from(entries(assign(create({
      q: 1,
      w: 2,
      e: 3
    }), {
      a: 4,
      s: 5,
      d: 6
    }))), [['a', 4], ['s', 5], ['d', 6]]);
  });
  function clone$(it){
    function fun(){} fun.prototype = it;
    return new fun;
  }
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, isFunction, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('core-js');
  isFunction = function(it){
    return toString$.call(it).slice(8, -1) === 'Function';
  };
  test('Function#part', function(assert){
    var obj, $, fn, part;
    assert.ok(isFunction(Function.prototype.part), 'is function');
    assert.ok(function(it){
      return toString$.call(it).slice(8, -1) === 'String';
    }.part('qwe')());
    obj = {
      a: 42
    };
    obj.fn = function(it){
      return this.a + it;
    }.part(21);
    assert.ok(obj.fn() === 63);
    $ = _;
    fn = function(){
      return Array.prototype.map.call(arguments, String).join(' ');
    };
    part = fn.part($, 'Саша', $, 'шоссе', $, 'сосала');
    assert.ok(isFunction(part), '.part with placeholders return function');
    assert.ok(part('Шла', 'по') === 'Шла Саша по шоссе undefined сосала', '.part with placeholders: args < placeholders');
    assert.ok(part('Шла', 'по', 'и') === 'Шла Саша по шоссе и сосала', '.part with placeholders: args == placeholders');
    return assert.ok(part('Шла', 'по', 'и', 'сушку') === 'Шла Саша по шоссе и сосала сушку', '.part with placeholders: args > placeholders');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, from;
  module = QUnit.module, test = QUnit.test;
  module('core-js');
  from = Array.from;
  test('core.getIteratorMethod', function(assert){
    var getIteratorMethod, iterFn, iter;
    getIteratorMethod = core.getIteratorMethod;
    assert.ok(typeof getIteratorMethod === 'function', 'is function');
    assert.strictEqual(getIteratorMethod({}), void 8);
    iterFn = getIteratorMethod([]);
    assert.ok(typeof iterFn === 'function');
    iter = iterFn.call([]);
    assert.ok('next' in iter);
    iter = getIteratorMethod(function(){
      return arguments;
    }());
    return assert.ok(typeof iterFn === 'function');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, from;
  module = QUnit.module, test = QUnit.test;
  module('core-js');
  from = Array.from;
  test('core.getIterator', function(assert){
    var getIterator, iter;
    getIterator = core.getIterator;
    assert.ok(typeof getIterator === 'function', 'is function');
    assert.throws(function(){
      getIterator({});
    }, TypeError);
    iter = getIterator([]);
    assert.ok('next' in iter);
    iter = getIterator(function(){
      return arguments;
    }());
    return assert.ok('next' in iter);
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test;
  module = QUnit.module, test = QUnit.test;
  module('core-js');
  test('core.isIterable', function(assert){
    var isIterable;
    isIterable = core.isIterable;
    assert.ok(typeof isIterable === 'function', 'is function');
    assert.ok(!isIterable({}));
    assert.ok(isIterable([]));
    return assert.ok(isIterable(function(){
      return arguments;
    }()));
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, isFunction, isObject, methods, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('core-js');
  isFunction = function(it){
    return toString$.call(it).slice(8, -1) === 'Function';
  };
  isObject = function(it){
    return it === Object(it);
  };
  methods = ['assert', 'count', 'debug', 'dir', 'dirxml', 'error', 'exception', 'group', 'groupEnd', 'groupCollapsed', 'groupEnd', 'info', 'log', 'table', 'trace', 'warn', 'markTimeline', 'profile', 'profileEnd', 'time', 'timeEnd', 'timeStamp'];
  test('log is object', function(assert){
    return assert.ok(isObject(log), 'global.log is object');
  });
  test('log.{..} are functions', function(assert){
    var i$, x$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = methods).length; i$ < len$; ++i$) {
      x$ = ref$[i$];
      results$.push(assert.ok(isFunction(log[x$]), "log." + x$ + " is function"));
    }
    return results$;
  });
  test('call log.{..}', function(assert){
    var i$, ref$, len$, m, results$ = [];
    for (i$ = 0, len$ = (ref$ = methods).length; i$ < len$; ++i$) {
      m = ref$[i$];
      results$.push(assert.ok((fn$()), "call log." + m));
    }
    return results$;
    function fn$(){
      try {
        if (m === 'profileEnd') {
          log[m]();
        } else {
          log[m]('foo');
        }
        return true;
      } catch (e$) {}
    }
  });
  test('call unbound log.#{..}', function(assert){
    var i$, ref$, len$, m, results$ = [];
    for (i$ = 0, len$ = (ref$ = methods).length; i$ < len$; ++i$) {
      m = ref$[i$];
      results$.push(assert.ok((fn$()), "call unbound log." + m));
    }
    return results$;
    function fn$(){
      try {
        if (m === 'profileEnd') {
          log[m].call(void 8);
        } else {
          log[m].call(void 8, 'foo');
        }
        return true;
      } catch (e$) {}
    }
  });
  test('log.{enable, disable}', function(assert){
    var enable, disable;
    enable = log.enable, disable = log.disable;
    assert.ok(isFunction(enable), 'log.enable is function');
    assert.ok(isFunction(disable), 'log.disable is function');
    assert.ok((function(){
      try {
        disable();
        return true;
      } catch (e$) {}
    }()), 'disable log');
    assert.ok((function(){
      try {
        return log.log('call disabled log') === void 8;
      } catch (e$) {}
    }()), 'call disabled log');
    return assert.ok((function(){
      try {
        enable();
        return true;
      } catch (e$) {}
    }()), 'enable log');
  });
  test('log', function(assert){
    assert.ok(isFunction(log), 'global.log is function');
    return assert.ok((function(){
      try {
        log(42);
        return true;
      } catch (e$) {}
    }()), 'call log');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('core-js');
  test('Number#@@iterator', function(assert){
    var iterator, toStringTag, iter1, iter2, iter3, iter4, iter5, iter6;
    iterator = Symbol.iterator, toStringTag = Symbol.toStringTag;
    assert.ok(toString$.call(Number.prototype[iterator]).slice(8, -1) === 'Function', 'is function');
    iter1 = 2[iterator]();
    assert.ok(iter1[toStringTag] === 'Number Iterator', '@@toStringTag');
    assert.deepEqual(iter1.next(), {
      done: false,
      value: 0
    }, '2 #1');
    assert.deepEqual(iter1.next(), {
      done: false,
      value: 1
    }, '2 #2');
    assert.deepEqual(iter1.next(), {
      done: true,
      value: void 8
    }, '2 #3');
    iter2 = 1.5[iterator]();
    assert.deepEqual(iter2.next(), {
      done: false,
      value: 0
    }, '1.5 #1');
    assert.deepEqual(iter2.next(), {
      done: false,
      value: 1
    }, '1.5 #2');
    assert.deepEqual(iter2.next(), {
      done: true,
      value: void 8
    }, '1.5 #3');
    iter3 = (-1)[iterator]();
    assert.deepEqual(iter3.next(), {
      done: true,
      value: void 8
    }, '-1');
    iter4 = NaN[iterator]();
    assert.deepEqual(iter4.next(), {
      done: true,
      value: void 8
    }, 'NaN');
    iter5 = Infinity[iterator]();
    assert.deepEqual(iter5.next(), {
      done: false,
      value: 0
    }, 'Infinity #1');
    assert.deepEqual(iter5.next(), {
      done: false,
      value: 1
    }, 'Infinity #1');
    assert.deepEqual(iter5.next(), {
      done: false,
      value: 2
    }, 'Infinity #1');
    iter6 = (-Infinity)[iterator]();
    return assert.deepEqual(iter6.next(), {
      done: true,
      value: void 8
    }, '-Infinity');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('core-js');
  test('Object.classof', function(assert){
    var classof, Class;
    classof = Object.classof;
    assert.ok(toString$.call(classof).slice(8, -1) === 'Function', 'is function');
    assert.ok(classof(void 8) === 'Undefined', 'classof undefined is `Undefined`');
    assert.ok(classof(null) === 'Null', 'classof null is `Null`');
    assert.ok(classof(true) === 'Boolean', 'classof bool is `Boolean`');
    assert.ok(classof('string') === 'String', 'classof string is `String`');
    assert.ok(classof(7) === 'Number', 'classof number is `Number`');
    assert.ok(classof(Symbol()) === 'Symbol', 'classof symbol is `Symbol`');
    assert.ok(classof(new Boolean(false)) === 'Boolean', 'classof new Boolean is `Boolean`');
    assert.ok(classof(new String('')) === 'String', 'classof new String is `String`');
    assert.ok(classof(new Number(7)) === 'Number', 'classof new Number is `Number`');
    assert.ok(classof({}) === 'Object', 'classof {} is `Object`');
    assert.ok(classof([]) === 'Array', 'classof array is `Array`');
    assert.ok(classof(function(){}) === 'Function', 'classof function is `Function`');
    assert.ok(classof(/./) === 'RegExp', 'classof regexp is `Undefined`');
    assert.ok(classof(TypeError()) === 'Error', 'classof new TypeError is `RegExp`');
    assert.ok(classof(function(){
      return arguments;
    }()) === 'Arguments', 'classof arguments list is `Arguments`');
    assert.ok(classof(new Set) === 'Set', 'classof undefined is `Map`');
    assert.ok(classof(new Map) === 'Map', 'classof map is `Undefined`');
    assert.ok(classof(new WeakSet) === 'WeakSet', 'classof weakset is `WeakSet`');
    assert.ok(classof(new WeakMap) === 'WeakMap', 'classof weakmap is `WeakMap`');
    assert.ok(classof(new Promise(function(){})) === 'Promise', 'classof promise is `Promise`');
    assert.ok(classof(''[Symbol.iterator]()) === 'String Iterator', 'classof String Iterator is `String Iterator`');
    assert.ok(classof([].entries()) === 'Array Iterator', 'classof Array Iterator is `Array Iterator`');
    assert.ok(classof(new Set().entries()) === 'Set Iterator', 'classof Set Iterator is `Set Iterator`');
    assert.ok(classof(new Map().entries()) === 'Map Iterator', 'classof Map Iterator is `Map Iterator`');
    assert.ok(classof(Math) === 'Math', 'classof Math is `Math`');
    if (typeof JSON != 'undefined' && JSON !== null) {
      assert.ok(classof(JSON) === 'JSON', 'classof JSON is `JSON`');
    }
    Class = (function(){
      Class.displayName = 'Class';
      var prototype = Class.prototype, constructor = Class;
      Class.prototype[Symbol.toStringTag] = 'Class';
      function Class(){}
      return Class;
    }());
    return assert.ok(classof(new Class) === 'Class', 'classof user class is [Symbol.toStringTag]');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('core-js');
  test('Object.define', function(assert){
    var define, defineProperty, foo, foo2;
    define = Object.define, defineProperty = Object.defineProperty;
    assert.ok(toString$.call(define).slice(8, -1) === 'Function', 'is function');
    foo = {
      q: 1
    };
    assert.ok(foo === define(foo, {
      w: 2
    }));
    assert.ok(foo.w === 2);
    if (function(){
      try {
        return 2 === defineProperty({}, 'a', {
          get: function(){
            return 2;
          }
        }).a;
      } catch (e$) {}
    }()) {
      foo = {
        q: 1
      };
      foo2 = defineProperty({}, 'w', {
        get: function(){
          return this.q + 1;
        }
      });
      define(foo, foo2);
      return assert.ok(foo.w === 2);
    }
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('core-js');
  test('Object.isObject', function(assert){
    var isObject;
    isObject = Object.isObject;
    assert.ok(toString$.call(isObject).slice(8, -1) === 'Function', 'is function');
    assert.ok(!isObject(void 8), 'isObject undefined return false');
    assert.ok(!isObject(null), 'isObject null return false');
    assert.ok(!isObject(1), 'isObject number return false');
    assert.ok(!isObject(true), 'isObject bool return false');
    assert.ok(!isObject('string'), 'isObject string return false');
    assert.ok(isObject(new Number(1)), 'isObject new Number return true');
    assert.ok(isObject(new Boolean(false)), 'isObject new Boolean return true');
    assert.ok(isObject(new String(1)), 'isObject new String return true');
    assert.ok(isObject({}), 'isObject object return true');
    assert.ok(isObject([]), 'isObject array return true');
    assert.ok(isObject(/./), 'isObject regexp return true');
    assert.ok(isObject(function(){}), 'isObject function return true');
    return assert.ok(isObject(new function(){}), 'isObject constructor instance return true');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('core-js');
  test('Object.make', function(assert){
    var make, object, foo;
    make = Object.make;
    assert.ok(toString$.call(make).slice(8, -1) === 'Function', 'is function');
    object = make(foo = {
      q: 1
    }, {
      w: 2
    });
    assert.ok(Object.getPrototypeOf(object) === foo);
    return assert.ok(object.w === 2);
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('core-js');
  test('String#escapeHTML', function(assert){
    assert.ok(toString$.call(String.prototype.escapeHTML).slice(8, -1) === 'Function', 'is function');
    assert.ok(/native code/.test(String.prototype.escapeHTML), 'looks like native');
    assert.strictEqual(String.prototype.escapeHTML.length, 0, 'arity is 0');
    assert.strictEqual(String.prototype.escapeHTML.name, 'escapeHTML', 'name is "escapeHTML"');
    assert.strictEqual('qwe, asd'.escapeHTML(), 'qwe, asd');
    assert.strictEqual('<div>qwe</div>'.escapeHTML(), '&lt;div&gt;qwe&lt;/div&gt;');
    return assert.strictEqual("&<>\"'".escapeHTML(), '&amp;&lt;&gt;&quot;&apos;');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('core-js');
  test('String#unescapeHTML', function(assert){
    assert.ok(toString$.call(String.prototype.unescapeHTML).slice(8, -1) === 'Function', 'is function');
    assert.ok(/native code/.test(String.prototype.unescapeHTML), 'looks like native');
    assert.strictEqual(String.prototype.unescapeHTML.length, 0, 'arity is 0');
    assert.strictEqual(String.prototype.unescapeHTML.name, 'unescapeHTML', 'name is "unescapeHTML"');
    assert.strictEqual('qwe, asd'.unescapeHTML(), 'qwe, asd');
    assert.strictEqual('&lt;div&gt;qwe&lt;/div&gt;'.unescapeHTML(), '<div>qwe</div>');
    return assert.strictEqual('&amp;&lt;&gt;&quot;&apos;'.unescapeHTML(), "&<>\"'");
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, isFunction, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES5');
  isFunction = function(it){
    return toString$.call(it).slice(8, -1) === 'Function';
  };
  test('Object.getOwnPropertyDescriptor', function(assert){
    var getOwnPropertyDescriptor;
    getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    assert.ok(isFunction(getOwnPropertyDescriptor), 'is function');
    assert.deepEqual(getOwnPropertyDescriptor({
      q: 42
    }, 'q'), {
      writable: true,
      enumerable: true,
      configurable: true,
      value: 42
    });
    return assert.ok(getOwnPropertyDescriptor({}, 'toString') === void 8);
  });
  test('Object.defineProperty', function(assert){
    var defineProperty, rez, src;
    defineProperty = Object.defineProperty;
    assert.ok(isFunction(defineProperty), 'is function');
    assert.ok((rez = defineProperty(src = {}, 'q', {
      value: 42
    })) === src);
    return assert.ok(rez.q === 42);
  });
  test('Object.defineProperties', function(assert){
    var defineProperties, rez, src;
    defineProperties = Object.defineProperties;
    assert.ok(isFunction(defineProperties), 'is function');
    assert.ok((rez = defineProperties(src = {}, {
      q: {
        value: 42
      },
      w: {
        value: 33
      }
    })) === src);
    return assert.ok(rez.q === 42) && rez.w === 33;
  });
  test('Object.getPrototypeOf', function(assert){
    var create, getPrototypeOf, fn, obj, foo, bar;
    create = Object.create, getPrototypeOf = Object.getPrototypeOf;
    assert.ok(isFunction(getPrototypeOf), 'is function');
    assert.ok(getPrototypeOf({}) === Object.prototype);
    assert.ok(getPrototypeOf([]) === Array.prototype);
    assert.ok(getPrototypeOf(new (fn = (function(){
      fn.displayName = 'fn';
      var prototype = fn.prototype, constructor = fn;
      function fn(){}
      return fn;
    }()))) === fn.prototype);
    assert.ok(getPrototypeOf(create(obj = {
      q: 1
    })) === obj);
    assert.ok(getPrototypeOf(create(null)) === null);
    assert.ok(getPrototypeOf(getPrototypeOf({})) === null);
    foo = function(){};
    foo.prototype.foo = 'foo';
    bar = function(){};
    bar.prototype = create(foo.prototype);
    bar.prototype.constructor = bar;
    return assert.strictEqual(getPrototypeOf(bar.prototype).foo, 'foo');
  });
  test('Object.getOwnPropertyNames', function(assert){
    var getOwnPropertyNames, fn1, fn2, names;
    getOwnPropertyNames = Object.getOwnPropertyNames;
    assert.ok(isFunction(getOwnPropertyNames), 'is function');
    fn1 = function(w){
      this.w = w != null ? w : 2;
    };
    fn2 = function(toString){
      this.toString = toString != null ? toString : 2;
    };
    fn1.prototype.q = fn2.prototype.q = 1;
    names = getOwnPropertyNames([1, 2, 3]);
    assert.strictEqual(names.length, 4);
    assert.ok(in$('0', names));
    assert.ok(in$('1', names));
    assert.ok(in$('2', names));
    assert.ok(in$('length', names));
    assert.deepEqual(getOwnPropertyNames(new fn1(1)), ['w']);
    assert.deepEqual(getOwnPropertyNames(new fn2(1)), ['toString']);
    assert.ok(in$('toString', getOwnPropertyNames(Array.prototype)));
    assert.ok(in$('toString', getOwnPropertyNames(Object.prototype)));
    return assert.ok(in$('constructor', getOwnPropertyNames(Object.prototype)));
  });
  test('Object.create', function(assert){
    var create, getPrototypeOf, getOwnPropertyNames, isObject, isPrototype, getPropertyNames, obj, fn;
    create = Object.create, getPrototypeOf = Object.getPrototypeOf, getOwnPropertyNames = Object.getOwnPropertyNames;
    isObject = function(it){
      return it === Object(it);
    };
    isPrototype = function(a, b){
      return {}.isPrototypeOf.call(a, b);
    };
    getPropertyNames = function(object){
      var result, i$, x$, ref$, len$;
      result = getOwnPropertyNames(object);
      while (object = getPrototypeOf(object)) {
        for (i$ = 0, len$ = (ref$ = getOwnPropertyNames(object)).length; i$ < len$; ++i$) {
          x$ = ref$[i$];
          in$(x$, result) || result.push(x$);
        }
      }
      return result;
    };
    assert.ok(isFunction(create), 'is function');
    assert.ok(isPrototype(obj = {
      q: 1
    }, create(obj)));
    assert.ok(create(obj).q === 1);
    fn = function(){
      return this.a = 1;
    };
    assert.ok(create(new fn) instanceof fn);
    assert.ok(fn.prototype === getPrototypeOf(getPrototypeOf(create(new fn))));
    assert.ok(create(new fn).a === 1);
    assert.ok(create({}, {
      a: {
        value: 42
      }
    }).a === 42);
    assert.ok(isObject(obj = create(null, {
      w: {
        value: 2
      }
    })));
    assert.ok(!('toString' in obj));
    assert.ok(obj.w === 2);
    return assert.deepEqual(getPropertyNames(create(null)), []);
  });
  test('Object.keys', function(assert){
    var keys, fn1, fn2;
    keys = Object.keys;
    assert.ok(isFunction(keys), 'is function');
    fn1 = function(w){
      this.w = w != null ? w : 2;
    };
    fn2 = function(toString){
      this.toString = toString != null ? toString : 2;
    };
    fn1.prototype.q = fn2.prototype.q = 1;
    assert.deepEqual(keys([1, 2, 3]), ['0', '1', '2']);
    assert.deepEqual(keys(new fn1(1)), ['w']);
    assert.deepEqual(keys(new fn2(1)), ['toString']);
    return assert.ok(!in$('push', keys(Array.prototype)));
  });
  test('Object.seal', function(assert){
    var seal, a;
    seal = Object.seal;
    assert.ok(isFunction(seal), 'is function');
    return assert.strictEqual(seal(a = {}), a);
  });
  test('Object.freeze', function(assert){
    var freeze, a;
    freeze = Object.freeze;
    assert.ok(isFunction(freeze), 'is function');
    return assert.strictEqual(freeze(a = {}), a);
  });
  test('Object.preventExtensions', function(assert){
    var preventExtensions, a;
    preventExtensions = Object.preventExtensions;
    assert.ok(isFunction(preventExtensions), 'is function');
    return assert.strictEqual(preventExtensions(a = {}), a);
  });
  test('Object.isSealed', function(assert){
    var isSealed;
    isSealed = Object.isSealed;
    assert.ok(isFunction(isSealed), 'is function');
    return assert.strictEqual(isSealed({}), false);
  });
  test('Object.isFrozen', function(assert){
    var isFrozen;
    isFrozen = Object.isFrozen;
    assert.ok(isFunction(isFrozen), 'is function');
    return assert.strictEqual(isFrozen({}), false);
  });
  test('Object.isExtensible', function(assert){
    var isExtensible;
    isExtensible = Object.isExtensible;
    assert.ok(isFunction(isExtensible), 'is function');
    return assert.strictEqual(isExtensible({}), true);
  });
  test('Function#bind', function(assert){
    var obj, fn, inst, F, date;
    assert.ok(isFunction(Function.prototype.bind), 'is function');
    obj = {
      a: 42
    };
    assert.ok(42 === function(){
      return this.a;
    }.bind(obj)());
    assert.ok(void 8 === new (function(){}.bind(obj))().a);
    fn = function(a, b){
      this.a = a;
      this.b = b;
    };
    inst = new (fn.bind(null, 1))(2);
    assert.ok(inst instanceof fn);
    assert.strictEqual(inst.a, 1);
    assert.strictEqual(inst.b, 2);
    assert.ok(42 === function(it){
      return it;
    }.bind(null, 42)());
    fn = RegExp.prototype.test.bind(/a/);
    assert.ok(fn('a'));
    F = Date.bind(null, 2015);
    date = new F(6);
    assert.ok(date instanceof Date);
    assert.strictEqual(date.getFullYear(), 2015);
    return assert.strictEqual(date.getMonth(), 6);
  });
  test('Array.isArray', function(assert){
    var isArray;
    isArray = Array.isArray;
    assert.ok(isFunction(isArray), 'is function');
    assert.ok(!isArray({}));
    assert.ok(!isArray(function(){
      return arguments;
    }()));
    return assert.ok(isArray([]));
  });
  test('ES5 Array prototype methods are functions', function(assert){
    var i$, x$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = ['indexOf', 'lastIndexOf', 'every', 'some', 'forEach', 'map', 'filter', 'reduce', 'reduceRight']).length; i$ < len$; ++i$) {
      x$ = ref$[i$];
      results$.push(assert.ok(isFunction(Array.prototype[x$]), "Array::" + x$ + " is function"));
    }
    return results$;
  });
  test('Array#slice', function(assert){
    var slice, arr, str, list, ref$, e;
    slice = Array.prototype.slice;
    arr = ['1', '2', '3', '4', '5'];
    assert.deepEqual(arr.slice(), arr);
    assert.deepEqual(arr.slice(1, 3), ['2', '3']);
    assert.deepEqual(arr.slice(1, void 8), ['2', '3', '4', '5']);
    assert.deepEqual(arr.slice(1, -1), ['2', '3', '4']);
    assert.deepEqual(arr.slice(-2, -1), ['4']);
    assert.deepEqual(arr.slice(-2, -3), []);
    str = '12345';
    assert.deepEqual(slice.call(str), arr);
    assert.deepEqual(slice.call(str, 1, 3), ['2', '3']);
    assert.deepEqual(slice.call(str, 1, void 8), ['2', '3', '4', '5']);
    assert.deepEqual(slice.call(str, 1, -1), ['2', '3', '4']);
    assert.deepEqual(slice.call(str, -2, -1), ['4']);
    assert.deepEqual(slice.call(str, -2, -3), []);
    if (list = typeof document != 'undefined' && document !== null ? (ref$ = document.body) != null ? ref$.childNodes : void 8 : void 8) {
      try {
        return assert.strictEqual(toString$.call(slice.call(list)).slice(8, -1), 'Array');
      } catch (e$) {
        e = e$;
        return assert.ok(false);
      }
    }
  });
  test('Array#join', function(assert){
    assert.strictEqual(Array.prototype.join.call('123'), '1,2,3');
    return assert.strictEqual(Array.prototype.join.call('123', '|'), '1|2|3');
  });
  test('Array#indexOf', function(assert){
    assert.ok(0 === [1, 1, 1].indexOf(1));
    assert.ok(-1 === [1, 2, 3].indexOf(1, 1));
    assert.ok(1 === [1, 2, 3].indexOf(2, 1));
    assert.ok(-1 === [NaN].indexOf(NaN));
    assert.ok(3 === Array(2).concat([1, 2, 3]).indexOf(2));
    return assert.ok(-1 === Array(1).indexOf(void 8));
  });
  test('Array#lastIndexOf', function(assert){
    assert.strictEqual(2, [1, 1, 1].lastIndexOf(1));
    assert.strictEqual(-1, [1, 2, 3].lastIndexOf(3, 1));
    assert.strictEqual(1, [1, 2, 3].lastIndexOf(2, 1));
    assert.strictEqual(-1, [NaN].lastIndexOf(NaN));
    return assert.strictEqual(1, [1, 2, 3].concat(Array(2)).lastIndexOf(2));
  });
  test('Array#every', function(assert){
    var a, ctx, rez, arr;
    (a = [1]).every(function(val, key, that){
      assert.ok(val === 1);
      assert.ok(key === 0);
      assert.ok(that === a);
      return assert.ok(this === ctx);
    }, ctx = {});
    assert.ok([1, 2, 3].every(function(it){
      return toString$.call(it).slice(8, -1) === 'Number';
    }));
    assert.ok([1, 2, 3].every((function(it){
      return it < 4;
    })));
    assert.ok(![1, 2, 3].every((function(it){
      return it < 3;
    })));
    assert.ok(![1, 2, 3].every(function(it){
      return toString$.call(it).slice(8, -1) === 'String';
    }));
    assert.ok([1, 2, 3].every(function(){
      return +this === 1;
    }, 1));
    rez = '';
    [1, 2, 3].every(function(){
      return rez += arguments[1];
    });
    assert.ok(rez === '012');
    return assert.ok((arr = [1, 2, 3]).every(function(){
      return arguments[2] === arr;
    }));
  });
  test('Array#some', function(assert){
    var a, ctx, rez, arr;
    (a = [1]).some(function(val, key, that){
      assert.ok(val === 1);
      assert.ok(key === 0);
      assert.ok(that === a);
      return assert.ok(this === ctx);
    }, ctx = {});
    assert.ok([1, '2', 3].some(function(it){
      return toString$.call(it).slice(8, -1) === 'Number';
    }));
    assert.ok([1, 2, 3].some((function(it){
      return it < 3;
    })));
    assert.ok(![1, 2, 3].some((function(it){
      return it < 0;
    })));
    assert.ok(![1, 2, 3].some(function(it){
      return toString$.call(it).slice(8, -1) === 'String';
    }));
    assert.ok(![1, 2, 3].some(function(){
      return +this !== 1;
    }, 1));
    rez = '';
    [1, 2, 3].some(function(){
      rez += arguments[1];
      return false;
    });
    assert.ok(rez === '012');
    return assert.ok(!(arr = [1, 2, 3]).some(function(){
      return arguments[2] !== arr;
    }));
  });
  test('Array#forEach', function(assert){
    var a, ctx, rez, arr;
    (a = [1]).forEach(function(val, key, that){
      assert.ok(val === 1);
      assert.ok(key === 0);
      assert.ok(that === a);
      assert.ok(this === ctx);
    }, ctx = {});
    rez = '';
    [1, 2, 3].forEach(function(it){
      rez += it;
    });
    assert.ok(rez === '123');
    rez = '';
    [1, 2, 3].forEach(function(){
      rez += arguments[1];
    });
    assert.ok(rez === '012');
    rez = '';
    [1, 2, 3].forEach(function(){
      rez += arguments[2];
    });
    assert.ok(rez === '1,2,31,2,31,2,3');
    rez = '';
    [1, 2, 3].forEach(function(){
      rez += this;
    }, 1);
    assert.ok(rez === '111');
    rez = '';
    arr = [];
    arr[5] = '';
    arr.forEach(function(arg$, k){
      rez += k;
    });
    return assert.ok(rez === '5');
  });
  test('Array#map', function(assert){
    var a, ctx;
    (a = [1]).map(function(val, key, that){
      assert.ok(val === 1);
      assert.ok(key === 0);
      assert.ok(that === a);
      return assert.ok(this === ctx);
    }, ctx = {});
    assert.deepEqual([2, 3, 4], [1, 2, 3].map((function(it){
      return it + 1;
    })));
    assert.deepEqual([1, 3, 5], [1, 2, 3].map(curry$(function(x$, y$){
      return x$ + y$;
    })));
    return assert.deepEqual([2, 2, 2], [1, 2, 3].map(function(){
      return +this;
    }, 2));
  });
  test('Array#filter', function(assert){
    var a, ctx;
    (a = [1]).filter(function(val, key, that){
      assert.ok(val === 1);
      assert.ok(key === 0);
      assert.ok(that === a);
      return assert.ok(this === ctx);
    }, ctx = {});
    return assert.deepEqual([1, 2, 3, 4, 5], [1, 2, 3, 'q', {}, 4, true, 5].filter(function(it){
      return toString$.call(it).slice(8, -1) === 'Number';
    }));
  });
  test('Array#reduce', function(assert){
    var a;
    assert.ok(-5 === [5, 4, 3, 2, 1].reduce(curry$(function(x$, y$){
      return x$ - y$;
    })));
    (a = [1]).reduce(function(memo, val, key, that){
      assert.ok(memo === 42);
      assert.ok(val === 1);
      assert.ok(key === 0);
      return assert.ok(that === a);
    }, 42);
    return [42, 43].reduce(function(it){
      return assert.ok(it === 42);
    });
  });
  test('Array#reduceRight', function(assert){
    var a;
    assert.ok(-5 === [1, 2, 3, 4, 5].reduceRight(curry$(function(x$, y$){
      return x$ - y$;
    })));
    (a = [1]).reduceRight(function(memo, val, key, that){
      assert.ok(memo === 42);
      assert.ok(val === 1);
      assert.ok(key === 0);
      return assert.ok(that === a);
    }, 42);
    return [42, 43].reduceRight(function(it){
      return assert.ok(it === 43);
    });
  });
  test('Date.now', function(assert){
    var now;
    now = Date.now;
    assert.ok(isFunction(now), 'is function');
    return assert.ok(+new Date - now() < 10, 'Date.now() ~ +new Date');
  });
  test('Date#toISOString', function(assert){
    var ft, bc;
    assert.ok(isFunction(Date.prototype.toISOString), 'is function');
    assert.strictEqual(new Date(0).toISOString(), '1970-01-01T00:00:00.000Z');
    assert.strictEqual(new Date(1e12 + 1).toISOString(), '2001-09-09T01:46:40.001Z');
    assert.strictEqual(new Date(-5e13 - 1).toISOString(), '0385-07-25T07:06:39.999Z');
    ft = new Date(1e15 + 1).toISOString();
    assert.ok(ft === '+033658-09-27T01:46:40.001Z' || ft === '33658-09-27T01:46:40.001Z');
    bc = new Date(-1e15 + 1).toISOString();
    assert.ok(bc === '-029719-04-05T22:13:20.001Z' || bc === '-29719-04-05T22:13:20.001Z');
    return assert.throws(function(){
      return new Date(NaN).toISOString();
    }, RangeError);
  });
  function in$(x, xs){
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  'use strict';
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Array#copyWithin', function(assert){
    var a;
    assert.ok(toString$.call(Array.prototype.copyWithin).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(Array.prototype.copyWithin.length, 2, 'arity is 2');
    assert.ok(/native code/.test(Array.prototype.copyWithin), 'looks like native');
    assert.strictEqual(Array.prototype.copyWithin.name, 'copyWithin', 'name is "copyWithin"');
    assert.strictEqual(a = [1].copyWithin(0), a);
    assert.deepEqual([1, 2, 3, 4, 5].copyWithin(0, 3), [4, 5, 3, 4, 5]);
    assert.deepEqual([1, 2, 3, 4, 5].copyWithin(1, 3), [1, 4, 5, 4, 5]);
    assert.deepEqual([1, 2, 3, 4, 5].copyWithin(1, 2), [1, 3, 4, 5, 5]);
    assert.deepEqual([1, 2, 3, 4, 5].copyWithin(2, 2), [1, 2, 3, 4, 5]);
    assert.deepEqual([1, 2, 3, 4, 5].copyWithin(0, 3, 4), [4, 2, 3, 4, 5]);
    assert.deepEqual([1, 2, 3, 4, 5].copyWithin(1, 3, 4), [1, 4, 3, 4, 5]);
    assert.deepEqual([1, 2, 3, 4, 5].copyWithin(1, 2, 4), [1, 3, 4, 4, 5]);
    assert.deepEqual([1, 2, 3, 4, 5].copyWithin(0, -2), [4, 5, 3, 4, 5]);
    assert.deepEqual([1, 2, 3, 4, 5].copyWithin(0, -2, -1), [4, 2, 3, 4, 5]);
    assert.deepEqual([1, 2, 3, 4, 5].copyWithin(-4, -3, -2), [1, 3, 3, 4, 5]);
    assert.deepEqual([1, 2, 3, 4, 5].copyWithin(-4, -3, -1), [1, 3, 4, 4, 5]);
    assert.deepEqual([1, 2, 3, 4, 5].copyWithin(-4, -3), [1, 3, 4, 5, 5]);
    if (!function(){
      return this;
    }()) {
      assert.throws(function(){
        return Array.prototype.copyWithin.call(null, 0);
      }, TypeError);
      assert.throws(function(){
        return Array.prototype.copyWithin.call(void 8, 0);
      }, TypeError);
    }
    return assert.ok('copyWithin' in Array.prototype[Symbol.unscopables], 'In Array#@@unscopables');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  'use strict';
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Array#fill', function(assert){
    var a;
    assert.ok(toString$.call(Array.prototype.fill).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(Array.prototype.fill.length, 1, 'arity is 1');
    assert.ok(/native code/.test(Array.prototype.fill), 'looks like native');
    assert.strictEqual(Array.prototype.fill.name, 'fill', 'name is "fill"');
    assert.strictEqual(a = Array(5).fill(5), a);
    assert.deepEqual(Array(5).fill(5), [5, 5, 5, 5, 5]);
    assert.deepEqual(Array(5).fill(5, 1), [void 8, 5, 5, 5, 5]);
    assert.deepEqual(Array(5).fill(5, 1, 4), [void 8, 5, 5, 5, void 8]);
    assert.deepEqual(Array(5).fill(5, 6, 1), [void 8, void 8, void 8, void 8, void 8]);
    assert.deepEqual(Array(5).fill(5, -3, 4), [void 8, void 8, 5, 5, void 8]);
    if (!function(){
      return this;
    }()) {
      assert.throws(function(){
        return Array.prototype.fill.call(null, 0);
      }, TypeError);
      assert.throws(function(){
        return Array.prototype.fill.call(void 8, 0);
      }, TypeError);
    }
    return assert.ok('fill' in Array.prototype[Symbol.unscopables], 'In Array#@@unscopables');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  'use strict';
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Array#findIndex', function(assert){
    var arr, ctx;
    assert.ok(toString$.call(Array.prototype.findIndex).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(Array.prototype.findIndex.length, 1, 'arity is 1');
    assert.ok(/native code/.test(Array.prototype.findIndex), 'looks like native');
    assert.strictEqual(Array.prototype.findIndex.name, 'findIndex', 'name is "findIndex"');
    (arr = [1]).findIndex(function(val, key, that){
      assert.strictEqual(this, ctx);
      assert.strictEqual(val, 1);
      assert.strictEqual(key, 0);
      return assert.strictEqual(that, arr);
    }, ctx = {});
    assert.strictEqual([1, 3, NaN, 42, {}].findIndex((function(it){
      return it === 42;
    })), 3);
    if (!function(){
      return this;
    }()) {
      assert.throws(function(){
        return Array.prototype.findIndex.call(null, 0);
      }, TypeError);
      assert.throws(function(){
        return Array.prototype.findIndex.call(void 8, 0);
      }, TypeError);
    }
    return assert.ok('findIndex' in Array.prototype[Symbol.unscopables], 'In Array#@@unscopables');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  'use strict';
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Array#find', function(assert){
    var arr, ctx;
    assert.ok(toString$.call(Array.prototype.find).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(Array.prototype.find.length, 1, 'arity is 1');
    assert.ok(/native code/.test(Array.prototype.find), 'looks like native');
    assert.strictEqual(Array.prototype.find.name, 'find', 'name is "find"');
    (arr = [1]).find(function(val, key, that){
      assert.strictEqual(this, ctx);
      assert.strictEqual(val, 1);
      assert.strictEqual(key, 0);
      return assert.strictEqual(that, arr);
    }, ctx = {});
    assert.strictEqual([1, 3, NaN, 42, {}].find((function(it){
      return it === 42;
    })), 42);
    assert.strictEqual([1, 3, NaN, 42, {}].find((function(it){
      return it === 43;
    })), void 8);
    if (!function(){
      return this;
    }()) {
      assert.throws(function(){
        return Array.prototype.find.call(null, 0);
      }, TypeError);
      assert.throws(function(){
        return Array.prototype.find.call(void 8, 0);
      }, TypeError);
    }
    return assert.ok('find' in Array.prototype[Symbol.unscopables], 'In Array#@@unscopables');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Array.from', function(assert){
    var from, iterator, al, ctx, done, iter, F, inst, a;
    from = Array.from;
    iterator = Symbol.iterator;
    assert.ok(toString$.call(from).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(Array.from.length, 1, 'arity is 1');
    assert.ok(/native code/.test(Array.from), 'looks like native');
    assert.strictEqual(Array.from.name, 'from', 'name is "from"');
    assert.deepEqual(from('123'), ['1', '2', '3']);
    assert.deepEqual(from({
      length: 3,
      0: 1,
      1: 2,
      2: 3
    }), [1, 2, 3]);
    from(al = function(){
      return arguments;
    }(1), function(val, key){
      assert.strictEqual(this, ctx);
      assert.strictEqual(val, 1);
      return assert.strictEqual(key, 0);
    }, ctx = {});
    from([1], function(val, key){
      assert.strictEqual(this, ctx);
      assert.strictEqual(val, 1);
      return assert.strictEqual(key, 0);
    }, ctx = {});
    assert.deepEqual(from({
      length: 3,
      0: 1,
      1: 2,
      2: 3
    }, (function(it){
      return Math.pow(it, 2);
    })), [1, 4, 9]);
    assert.deepEqual(from(new Set([1, 2, 3, 2, 1])), [1, 2, 3], 'Works with iterators');
    assert.throws(function(){
      return from(null);
    }, TypeError);
    assert.throws(function(){
      return from(void 8);
    }, TypeError);
    done = true;
    iter = [1, 2, 3].values();
    iter['return'] = function(){
      return done = false;
    };
    from(iter, function(){
      return false;
    });
    assert.ok(done, '.return #default');
    done = false;
    iter = [1, 2, 3].values();
    iter['return'] = function(){
      return done = true;
    };
    try {
      from(iter, function(){
        throw 42;
      });
    } catch (e$) {}
    assert.ok(done, '.return #throw');
    F = function(){};
    inst = from.call(F, [1, 2]);
    assert.ok(inst instanceof F);
    assert.strictEqual(inst[0], 1);
    assert.strictEqual(inst[1], 2);
    assert.strictEqual(inst.length, 2);
    inst = from.call(F, {
      0: 1,
      1: 2,
      length: 2
    });
    assert.ok(inst instanceof F);
    assert.strictEqual(inst[0], 1);
    assert.strictEqual(inst[1], 2);
    assert.strictEqual(inst.length, 2);
    a = [1, 2, 3];
    done = false;
    a[iterator] = function(){
      done = true;
      return [][iterator].call(this);
    };
    assert.deepEqual(from(a), [1, 2, 3]);
    return assert.ok(done);
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, isFunction, isIterator, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  isFunction = function(it){
    return toString$.call(it).slice(8, -1) === 'Function';
  };
  isIterator = function(it){
    return typeof it === 'object' && isFunction(it.next);
  };
  test('Array#keys', function(assert){
    var iter;
    assert.ok(isFunction(Array.prototype.keys), 'is function');
    assert.strictEqual(Array.prototype.keys.length, 0, 'arity is 0');
    assert.strictEqual(Array.prototype.keys.name, 'keys', 'name is "keys"');
    assert.ok(/native code/.test(Array.prototype.keys), 'looks like native');
    iter = ['q', 'w', 'e'].keys();
    assert.ok(isIterator(iter), 'Return iterator');
    assert.strictEqual(iter[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.toStringTag : void 8], 'Array Iterator');
    assert.deepEqual(iter.next(), {
      value: 0,
      done: false
    });
    assert.deepEqual(iter.next(), {
      value: 1,
      done: false
    });
    assert.deepEqual(iter.next(), {
      value: 2,
      done: false
    });
    assert.deepEqual(iter.next(), {
      value: void 8,
      done: true
    });
    return assert.ok('keys' in Array.prototype[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.unscopables : void 8], 'In Array#@@unscopables');
  });
  test('Array#values', function(assert){
    var iter;
    assert.ok(isFunction(Array.prototype.values), 'is function');
    assert.strictEqual(Array.prototype.values.length, 0, 'arity is 0');
    assert.ok(/native code/.test(Array.prototype.values), 'looks like native');
    iter = ['q', 'w', 'e'].values();
    assert.ok(isIterator(iter), 'Return iterator');
    assert.strictEqual(iter[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.toStringTag : void 8], 'Array Iterator');
    assert.deepEqual(iter.next(), {
      value: 'q',
      done: false
    });
    assert.deepEqual(iter.next(), {
      value: 'w',
      done: false
    });
    assert.deepEqual(iter.next(), {
      value: 'e',
      done: false
    });
    assert.deepEqual(iter.next(), {
      value: void 8,
      done: true
    });
    return assert.ok('values' in Array.prototype[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.unscopables : void 8], 'In Array#@@unscopables');
  });
  test('Array#entries', function(assert){
    var iter;
    assert.ok(isFunction(Array.prototype.entries), 'is function');
    assert.strictEqual(Array.prototype.entries.length, 0, 'arity is 0');
    assert.strictEqual(Array.prototype.entries.name, 'entries', 'name is "entries"');
    assert.ok(/native code/.test(Array.prototype.entries), 'looks like native');
    iter = ['q', 'w', 'e'].entries();
    assert.ok(isIterator(iter), 'Return iterator');
    assert.strictEqual(iter[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.toStringTag : void 8], 'Array Iterator');
    assert.deepEqual(iter.next(), {
      value: [0, 'q'],
      done: false
    });
    assert.deepEqual(iter.next(), {
      value: [1, 'w'],
      done: false
    });
    assert.deepEqual(iter.next(), {
      value: [2, 'e'],
      done: false
    });
    assert.deepEqual(iter.next(), {
      value: void 8,
      done: true
    });
    return assert.ok('entries' in Array.prototype[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.unscopables : void 8], 'In Array#@@unscopables');
  });
  test('Array#@@iterator', function(assert){
    var iter;
    assert.ok(isFunction(Array.prototype[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.iterator : void 8]), 'is function');
    assert.strictEqual(Array.prototype[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.iterator : void 8].length, 0, 'arity is 0');
    assert.ok(/native code/.test(Array.prototype[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.iterator : void 8]), 'looks like native');
    assert.strictEqual(Array.prototype[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.iterator : void 8], Array.prototype.values);
    iter = ['q', 'w', 'e'][typeof Symbol != 'undefined' && Symbol !== null ? Symbol.iterator : void 8]();
    assert.ok(isIterator(iter), 'Return iterator');
    assert.strictEqual(iter[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.toStringTag : void 8], 'Array Iterator');
    assert.deepEqual(iter.next(), {
      value: 'q',
      done: false
    });
    assert.deepEqual(iter.next(), {
      value: 'w',
      done: false
    });
    assert.deepEqual(iter.next(), {
      value: 'e',
      done: false
    });
    return assert.deepEqual(iter.next(), {
      value: void 8,
      done: true
    });
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Array.of', function(assert){
    var F, inst;
    assert.ok(toString$.call(Array.of).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(Array.of.length, 0, 'arity is 0');
    assert.ok(/native code/.test(Array.of), 'looks like native');
    assert.strictEqual(Array.of.name, 'of', 'name is "of"');
    assert.deepEqual(Array.of(1), [1]);
    assert.deepEqual(Array.of(1, 2, 3), [1, 2, 3]);
    F = function(){};
    inst = Array.of.call(F, 1, 2);
    assert.ok(inst instanceof F);
    assert.strictEqual(inst[0], 1);
    assert.strictEqual(inst[1], 2);
    return assert.strictEqual(inst.length, 2);
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Function#@@hasInstance', function(assert){
    assert.ok(Symbol.hasInstance in Function.prototype);
    assert.ok(Function[Symbol.hasInstance](function(){}));
    return assert.ok(!Function[Symbol.hasInstance]({}));
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test;
  if (function(){
    try {
      return 2 === Object.defineProperty({}, 'a', {
        get: function(){
          return 2;
        }
      }).a;
    } catch (e$) {}
  }()) {
    module = QUnit.module, test = QUnit.test;
    module('ES6');
    test('Function#name', function(assert){
      assert.ok('name' in Function.prototype);
      assert.strictEqual((function(){
        function foo(it){
          return it;
        }
        return foo;
      }()).name, 'foo');
      return assert.strictEqual(function(){}.name, '');
    });
  }
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, isFunction, isIterator, same, getOwnPropertyDescriptor, freeze, iterator, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  isFunction = function(it){
    return toString$.call(it).slice(8, -1) === 'Function';
  };
  isIterator = function(it){
    return typeof it === 'object' && isFunction(it.next);
  };
  same = function(a, b){
    if (a === b) {
      return a !== 0 || 1 / a === 1 / b;
    } else {
      return a != a && b != b;
    }
  };
  getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor, freeze = Object.freeze;
  iterator = Symbol.iterator;
  test('Map', function(assert){
    var done, iter, a;
    assert.ok(isFunction(Map), 'is function');
    assert.ok(/native code/.test(Map), 'looks like native');
    assert.strictEqual(Map.name, 'Map', 'name is "Map"');
    assert.strictEqual(Map.length, 0, 'arity is 0');
    assert.ok('clear' in Map.prototype, 'clear in Map.prototype');
    assert.ok('delete' in Map.prototype, 'delete in Map.prototype');
    assert.ok('forEach' in Map.prototype, 'forEach in Map.prototype');
    assert.ok('get' in Map.prototype, 'get in Map.prototype');
    assert.ok('has' in Map.prototype, 'has in Map.prototype');
    assert.ok('set' in Map.prototype, 'set in Map.prototype');
    assert.ok(new Map instanceof Map, 'new Map instanceof Map');
    assert.strictEqual(new Map([1, 2, 3].entries()).size, 3, 'Init from iterator #1');
    assert.strictEqual(new Map(new Map([1, 2, 3].entries())).size, 3, 'Init from iterator #2');
    assert.strictEqual(new Map([[freeze({}), 1], [2, 3]]).size, 2, 'Support frozen objects');
    done = false;
    iter = [null, 1, 2].values();
    iter['return'] = function(){
      return done = true;
    };
    try {
      new Map(iter);
    } catch (e$) {}
    assert.ok(done, '.return #throw');
    a = [];
    done = false;
    a[iterator] = function(){
      done = true;
      return [][iterator].call(this);
    };
    new Map(a);
    return assert.ok(done);
  });
  test('Map#clear', function(assert){
    var M, f;
    assert.ok(isFunction(Map.prototype.clear), 'is function');
    assert.strictEqual(Map.prototype.clear.name, 'clear', 'name is "clear"');
    assert.strictEqual(Map.prototype.clear.length, 0, 'arity is 0');
    assert.ok(/native code/.test(Map.prototype.clear), 'looks like native');
    M = new Map;
    M.clear();
    assert.strictEqual(M.size, 0);
    M = new Map().set(1, 2).set(2, 3).set(1, 4);
    M.clear();
    assert.strictEqual(M.size, 0);
    assert.ok(!M.has(1));
    assert.ok(!M.has(2));
    M = new Map().set(1, 2).set(f = freeze({}), 3);
    M.clear();
    assert.strictEqual(M.size, 0, 'Support frozen objects');
    assert.ok(!M.has(1));
    return assert.ok(!M.has(f));
  });
  test('Map#delete', function(assert){
    var a, M, f;
    assert.ok(isFunction(Map.prototype['delete']), 'is function');
    assert.strictEqual(Map.prototype['delete'].length, 1, 'arity is 1');
    assert.ok(/native code/.test(Map.prototype['delete']), 'looks like native');
    a = [];
    M = new Map().set(NaN, 1).set(2, 1).set(3, 1).set(2, 5).set(1, 4).set(a, {});
    assert.strictEqual(M.size, 5);
    assert.ok(M['delete'](NaN));
    assert.strictEqual(M.size, 4);
    assert.ok(!M['delete'](4));
    assert.strictEqual(M.size, 4);
    M['delete']([]);
    assert.strictEqual(M.size, 4);
    M['delete'](a);
    assert.strictEqual(M.size, 3);
    M.set(freeze(f = {}), 42);
    assert.strictEqual(M.size, 4);
    M['delete'](f);
    return assert.strictEqual(M.size, 3);
  });
  test('Map#forEach', function(assert){
    var r, T, count, M, a, map, s;
    assert.ok(isFunction(Map.prototype.forEach), 'is function');
    assert.strictEqual(Map.prototype.forEach.name, 'forEach', 'name is "forEach"');
    assert.strictEqual(Map.prototype.forEach.length, 1, 'arity is 1');
    assert.ok(/native code/.test(Map.prototype.forEach), 'looks like native');
    r = {};
    count = 0;
    M = new Map().set(NaN, 1).set(2, 1).set(3, 7).set(2, 5).set(1, 4).set(a = {}, 9);
    M.forEach(function(value, key){
      count++;
      r[value] = key;
    });
    assert.strictEqual(count, 5);
    assert.deepEqual(r, {
      1: NaN,
      7: 3,
      5: 2,
      4: 1,
      9: a
    });
    map = new Map([['0', 9], ['1', 9], ['2', 9], ['3', 9]]);
    s = "";
    map.forEach(function(value, key){
      s += key;
      if (key === '2') {
        map['delete']('2');
        map['delete']('3');
        map['delete']('1');
        return map.set('4', 9);
      }
    });
    assert.strictEqual(s, '0124');
    map = new Map([['0', 1]]);
    s = "";
    map.forEach(function(it){
      map['delete']('0');
      if (s !== '') {
        throw '!!!';
      }
      return s += it;
    });
    return assert.strictEqual(s, '1');
  });
  test('Map#get', function(assert){
    var o, f, M;
    assert.ok(isFunction(Map.prototype.get), 'is function');
    assert.strictEqual(Map.prototype.get.name, 'get', 'name is "get"');
    assert.strictEqual(Map.prototype.get.length, 1, 'arity is 1');
    assert.ok(/native code/.test(Map.prototype.get), 'looks like native');
    o = {};
    f = freeze({});
    M = new Map([[NaN, 1], [2, 1], [3, 1], [2, 5], [1, 4], [f, 42], [o, o]]);
    assert.strictEqual(M.get(NaN), 1);
    assert.strictEqual(M.get(4), void 8);
    assert.strictEqual(M.get({}), void 8);
    assert.strictEqual(M.get(o), o);
    assert.strictEqual(M.get(f), 42);
    return assert.strictEqual(M.get(2), 5);
  });
  test('Map#has', function(assert){
    var o, f, M;
    assert.ok(isFunction(Map.prototype.has), 'is function');
    assert.strictEqual(Map.prototype.has.name, 'has', 'name is "has"');
    assert.strictEqual(Map.prototype.has.length, 1, 'arity is 1');
    assert.ok(/native code/.test(Map.prototype.has), 'looks like native');
    o = {};
    f = freeze({});
    M = new Map([[NaN, 1], [2, 1], [3, 1], [2, 5], [1, 4], [f, 42], [o, o]]);
    assert.ok(M.has(NaN));
    assert.ok(M.has(o));
    assert.ok(M.has(2));
    assert.ok(M.has(f));
    assert.ok(!M.has(4));
    return assert.ok(!M.has({}));
  });
  test('Map#set', function(assert){
    var o, M, chain, f;
    assert.ok(isFunction(Map.prototype.set), 'is function');
    assert.strictEqual(Map.prototype.set.name, 'set', 'name is "set"');
    assert.strictEqual(Map.prototype.set.length, 2, 'arity is 2');
    assert.ok(/native code/.test(Map.prototype.set), 'looks like native');
    o = {};
    M = new Map().set(NaN, 1).set(2, 1).set(3, 1).set(2, 5).set(1, 4).set(o, o);
    assert.ok(M.size === 5);
    chain = M.set(7, 2);
    assert.strictEqual(chain, M);
    M.set(7, 2);
    assert.strictEqual(M.size, 6);
    assert.strictEqual(M.get(7), 2);
    assert.strictEqual(M.get(NaN), 1);
    M.set(NaN, 42);
    assert.strictEqual(M.size, 6);
    assert.strictEqual(M.get(NaN), 42);
    M.set({}, 11);
    assert.strictEqual(M.size, 7);
    assert.strictEqual(M.get(o), o);
    M.set(o, 27);
    assert.strictEqual(M.size, 7);
    assert.strictEqual(M.get(o), 27);
    assert.strictEqual(new Map().set(NaN, 2).set(NaN, 3).set(NaN, 4).size, 1);
    M = new Map().set(freeze(f = {}), 42);
    return assert.strictEqual(M.get(f), 42);
  });
  test('Map#size', function(assert){
    var size, sizeDesc;
    size = new Map().set(2, 1).size;
    assert.strictEqual(typeof size, 'number', 'size is number');
    assert.strictEqual(size, 1, 'size is correct');
    if (function(){
      try {
        return 2 === Object.defineProperty({}, 'a', {
          get: function(){
            return 2;
          }
        }).a;
      } catch (e$) {}
    }()) {
      sizeDesc = getOwnPropertyDescriptor(Map.prototype, 'size');
      assert.ok(sizeDesc && sizeDesc.get, 'size is getter');
      assert.ok(sizeDesc && !sizeDesc.set, 'size isnt setter');
      return assert.throws(function(){
        return Map.prototype.size;
      }, TypeError);
    }
  });
  test('Map & -0', function(assert){
    var map;
    map = new Map;
    map.set(-0, 1);
    assert.strictEqual(map.size, 1);
    assert.ok(map.has(0));
    assert.ok(map.has(-0));
    assert.strictEqual(map.get(0), 1);
    assert.strictEqual(map.get(-0), 1);
    map.forEach(function(val, key){
      return assert.ok(!same(key, -0));
    });
    map['delete'](-0);
    assert.strictEqual(map.size, 0);
    map = new Map([[-0, 1]]);
    return map.forEach(function(val, key){
      return assert.ok(!same(key, -0));
    });
  });
  test('Map#@@toStringTag', function(assert){
    return assert.strictEqual(Map.prototype[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.toStringTag : void 8], 'Map', 'Map::@@toStringTag is `Map`');
  });
  test('Map Iterator', function(assert){
    var map, keys, iterator;
    map = new Map([['a', 1], ['b', 2], ['c', 3], ['d', 4]]);
    keys = [];
    iterator = map.keys();
    keys.push(iterator.next().value);
    assert.ok(map['delete']('a'));
    assert.ok(map['delete']('b'));
    assert.ok(map['delete']('c'));
    map.set('e');
    keys.push(iterator.next().value);
    keys.push(iterator.next().value);
    assert.ok(iterator.next().done);
    map.set('f');
    assert.ok(iterator.next().done);
    return assert.deepEqual(keys, ['a', 'd', 'e']);
  });
  test('Map#keys', function(assert){
    var iter;
    assert.ok(typeof Map.prototype.keys === 'function', 'is function');
    assert.strictEqual(Map.prototype.keys.name, 'keys', 'name is "keys"');
    assert.strictEqual(Map.prototype.keys.length, 0, 'arity is 0');
    assert.ok(/native code/.test(Map.prototype.keys), 'looks like native');
    iter = new Map([['a', 'q'], ['s', 'w'], ['d', 'e']]).keys();
    assert.ok(isIterator(iter), 'Return iterator');
    assert.strictEqual(iter[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.toStringTag : void 8], 'Map Iterator');
    assert.deepEqual(iter.next(), {
      value: 'a',
      done: false
    });
    assert.deepEqual(iter.next(), {
      value: 's',
      done: false
    });
    assert.deepEqual(iter.next(), {
      value: 'd',
      done: false
    });
    return assert.deepEqual(iter.next(), {
      value: void 8,
      done: true
    });
  });
  test('Map#values', function(assert){
    var iter;
    assert.ok(typeof Map.prototype.values === 'function', 'is function');
    assert.strictEqual(Map.prototype.values.name, 'values', 'name is "values"');
    assert.strictEqual(Map.prototype.values.length, 0, 'arity is 0');
    assert.ok(/native code/.test(Map.prototype.values), 'looks like native');
    iter = new Map([['a', 'q'], ['s', 'w'], ['d', 'e']]).values();
    assert.ok(isIterator(iter), 'Return iterator');
    assert.strictEqual(iter[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.toStringTag : void 8], 'Map Iterator');
    assert.deepEqual(iter.next(), {
      value: 'q',
      done: false
    });
    assert.deepEqual(iter.next(), {
      value: 'w',
      done: false
    });
    assert.deepEqual(iter.next(), {
      value: 'e',
      done: false
    });
    return assert.deepEqual(iter.next(), {
      value: void 8,
      done: true
    });
  });
  test('Map#entries', function(assert){
    var iter;
    assert.ok(typeof Map.prototype.entries === 'function', 'is function');
    assert.strictEqual(Map.prototype.entries.name, 'entries', 'name is "entries"');
    assert.strictEqual(Map.prototype.entries.length, 0, 'arity is 0');
    assert.ok(/native code/.test(Map.prototype.entries), 'looks like native');
    iter = new Map([['a', 'q'], ['s', 'w'], ['d', 'e']]).entries();
    assert.ok(isIterator(iter), 'Return iterator');
    assert.strictEqual(iter[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.toStringTag : void 8], 'Map Iterator');
    assert.deepEqual(iter.next(), {
      value: ['a', 'q'],
      done: false
    });
    assert.deepEqual(iter.next(), {
      value: ['s', 'w'],
      done: false
    });
    assert.deepEqual(iter.next(), {
      value: ['d', 'e'],
      done: false
    });
    return assert.deepEqual(iter.next(), {
      value: void 8,
      done: true
    });
  });
  test('Map#@@iterator', function(assert){
    var iter;
    assert.ok(typeof Map.prototype[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.iterator : void 8] === 'function', 'is function');
    assert.strictEqual(Map.prototype.entries.name, 'entries', 'name is "entries"');
    assert.strictEqual(Map.prototype.entries.length, 0, 'arity is 0');
    assert.ok(/native code/.test(Map.prototype[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.iterator : void 8]), 'looks like native');
    assert.strictEqual(Map.prototype[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.iterator : void 8], Map.prototype.entries);
    iter = new Map([['a', 'q'], ['s', 'w'], ['d', 'e']])[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.iterator : void 8]();
    assert.ok(isIterator(iter), 'Return iterator');
    assert.strictEqual(iter[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.toStringTag : void 8], 'Map Iterator');
    assert.deepEqual(iter.next(), {
      value: ['a', 'q'],
      done: false
    });
    assert.deepEqual(iter.next(), {
      value: ['s', 'w'],
      done: false
    });
    assert.deepEqual(iter.next(), {
      value: ['d', 'e'],
      done: false
    });
    return assert.deepEqual(iter.next(), {
      value: void 8,
      done: true
    });
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Math.acosh', function(assert){
    var epsilon, sameValue, acosh;
    epsilon = function(a, b, E){
      return Math.abs(a - b) <= (E != null ? E : 1e-11);
    };
    sameValue = function(a, b, c){
      return assert.ok(a === b
        ? a !== 0 || 1 / a === 1 / b
        : a != a && b != b, c);
    };
    acosh = Math.acosh;
    assert.ok(toString$.call(acosh).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(acosh.name, 'acosh', 'name is "acosh"');
    assert.strictEqual(acosh.length, 1, 'arity is 1');
    assert.ok(/native code/.test(acosh), 'looks like native');
    sameValue(acosh(NaN), NaN);
    sameValue(acosh(0.5), NaN);
    sameValue(acosh(-1), NaN);
    sameValue(acosh(-1e300), NaN);
    sameValue(acosh(1), 0);
    assert.strictEqual(acosh(Infinity), Infinity);
    assert.ok(epsilon(acosh(1234), 7.811163220849231));
    assert.ok(epsilon(acosh(8.88), 2.8737631531629235));
    assert.ok(epsilon(acosh(1e+160), 369.10676205960726));
    assert.ok(epsilon(acosh(Number.MAX_VALUE), 710.475860073944));
    return assert.ok(epsilon(acosh(1 + Number.EPSILON), 2.1073424255447017e-8));
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Math.asinh', function(assert){
    var epsilon, sameValue, asinh;
    epsilon = function(a, b, E){
      return Math.abs(a - b) <= (E != null ? E : 1e-11);
    };
    sameValue = function(a, b, c){
      return assert.ok(a === b
        ? a !== 0 || 1 / a === 1 / b
        : a != a && b != b, c);
    };
    asinh = Math.asinh;
    assert.ok(toString$.call(asinh).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(asinh.name, 'asinh', 'name is "asinh"');
    assert.strictEqual(asinh.length, 1, 'arity is 1');
    assert.ok(/native code/.test(asinh), 'looks like native');
    sameValue(asinh(NaN), NaN);
    sameValue(asinh(0), 0);
    sameValue(asinh(-0), -0);
    assert.strictEqual(asinh(Infinity), Infinity);
    assert.strictEqual(asinh(-Infinity), -Infinity);
    assert.ok(epsilon(asinh(1234), 7.811163549201245));
    assert.ok(epsilon(asinh(9.99), 2.997227420191335));
    assert.ok(epsilon(asinh(1e150), 346.0809111296668));
    assert.ok(epsilon(asinh(1e7), 16.811242831518268));
    return assert.ok(epsilon(asinh(-1e7), -16.811242831518268));
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Math.atanh', function(assert){
    var epsilon, sameValue, atanh;
    epsilon = function(a, b, E){
      return Math.abs(a - b) <= (E != null ? E : 1e-11);
    };
    sameValue = function(a, b, c){
      return assert.ok(a === b
        ? a !== 0 || 1 / a === 1 / b
        : a != a && b != b, c);
    };
    atanh = Math.atanh;
    assert.ok(toString$.call(atanh).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(atanh.name, 'atanh', 'name is "atanh"');
    assert.strictEqual(atanh.length, 1, 'arity is 1');
    assert.ok(/native code/.test(atanh), 'looks like native');
    sameValue(atanh(NaN), NaN);
    sameValue(atanh(-2), NaN);
    sameValue(atanh(-1.5), NaN);
    sameValue(atanh(2), NaN);
    sameValue(atanh(1.5), NaN);
    assert.strictEqual(atanh(-1), -Infinity);
    assert.strictEqual(atanh(1), Infinity);
    sameValue(atanh(0), 0);
    sameValue(atanh(-0), -0);
    sameValue(atanh(-1e300), NaN);
    sameValue(atanh(1e300), NaN);
    assert.ok(epsilon(atanh(0.5), 0.5493061443340549));
    assert.ok(epsilon(atanh(-0.5), -0.5493061443340549));
    return assert.ok(epsilon(atanh(0.444), 0.47720201260109457));
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Math.cbrt', function(assert){
    var epsilon, sameValue, cbrt;
    epsilon = function(a, b, E){
      return Math.abs(a - b) <= (E != null ? E : 1e-11);
    };
    sameValue = function(a, b, c){
      return assert.ok(a === b
        ? a !== 0 || 1 / a === 1 / b
        : a != a && b != b, c);
    };
    cbrt = Math.cbrt;
    assert.ok(toString$.call(cbrt).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(cbrt.name, 'cbrt', 'name is "cbrt"');
    assert.strictEqual(cbrt.length, 1, 'arity is 1');
    assert.ok(/native code/.test(cbrt), 'looks like native');
    sameValue(cbrt(NaN), NaN);
    sameValue(cbrt(0), 0);
    sameValue(cbrt(-0), -0);
    assert.strictEqual(cbrt(Infinity), Infinity);
    assert.strictEqual(cbrt(-Infinity), -Infinity);
    assert.strictEqual(cbrt(-8), -2);
    assert.strictEqual(cbrt(8), 2);
    assert.ok(epsilon(cbrt(-1000), -10));
    return assert.ok(epsilon(cbrt(1000), 10));
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Math.clz32', function(assert){
    var sameValue, clz32;
    sameValue = function(a, b, c){
      return assert.ok(a === b
        ? a !== 0 || 1 / a === 1 / b
        : a != a && b != b, c);
    };
    clz32 = Math.clz32;
    assert.ok(toString$.call(clz32).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(clz32.name, 'clz32', 'name is "clz32"');
    assert.strictEqual(clz32.length, 1, 'arity is 1');
    assert.ok(/native code/.test(clz32), 'looks like native');
    assert.strictEqual(clz32(0), 32);
    assert.strictEqual(clz32(1), 31);
    sameValue(clz32(-1), 0);
    assert.strictEqual(clz32(0.6), 32);
    sameValue(clz32(Math.pow(2, 32) - 1), 0);
    return assert.strictEqual(clz32(Math.pow(2, 32)), 32);
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Math.cosh', function(assert){
    var epsilon, sameValue, cosh;
    epsilon = function(a, b, E){
      return Math.abs(a - b) <= (E != null ? E : 1e-11);
    };
    sameValue = function(a, b, c){
      return assert.ok(a === b
        ? a !== 0 || 1 / a === 1 / b
        : a != a && b != b, c);
    };
    cosh = Math.cosh;
    assert.ok(toString$.call(cosh).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(cosh.name, 'cosh', 'name is "cosh"');
    assert.strictEqual(cosh.length, 1, 'arity is 1');
    assert.ok(/native code/.test(cosh), 'looks like native');
    sameValue(cosh(NaN), NaN);
    assert.strictEqual(cosh(0), 1);
    assert.strictEqual(cosh(-0), 1);
    assert.strictEqual(cosh(Infinity), Infinity);
    assert.strictEqual(cosh(-Infinity), Infinity);
    assert.ok(epsilon(cosh(12), 81377.39571257407, 3e-11));
    assert.ok(epsilon(cosh(22), 1792456423.065795780980053377, 1e-5));
    assert.ok(epsilon(cosh(-10), 11013.23292010332313972137));
    return assert.ok(epsilon(cosh(-23), 4872401723.1244513000, 1e-5));
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Math.expm1', function(assert){
    var epsilon, sameValue, expm1;
    epsilon = function(a, b, E){
      return Math.abs(a - b) <= (E != null ? E : 1e-11);
    };
    sameValue = function(a, b, c){
      return assert.ok(a === b
        ? a !== 0 || 1 / a === 1 / b
        : a != a && b != b, c);
    };
    expm1 = Math.expm1;
    assert.ok(toString$.call(expm1).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(expm1.name, 'expm1', 'name is "expm1"');
    assert.strictEqual(expm1.length, 1, 'arity is 1');
    assert.ok(/native code/.test(expm1), 'looks like native');
    sameValue(expm1(NaN), NaN);
    sameValue(expm1(0), 0);
    sameValue(expm1(-0), -0);
    assert.strictEqual(expm1(Infinity), Infinity);
    assert.strictEqual(expm1(-Infinity), -1);
    return assert.ok(epsilon(expm1(10), 22025.465794806718, assert.ok(epsilon(expm1(-10), -0.9999546000702375))));
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Math.fround', function(assert){
    var sameValue, fround, maxFloat32, minFloat32;
    sameValue = function(a, b, c){
      return assert.ok(a === b
        ? a !== 0 || 1 / a === 1 / b
        : a != a && b != b, c);
    };
    fround = Math.fround;
    assert.ok(toString$.call(fround).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(fround.name, 'fround', 'name is "fround"');
    assert.strictEqual(fround.length, 1, 'arity is 1');
    assert.ok(/native code/.test(fround), 'looks like native');
    sameValue(fround(void 8), NaN);
    sameValue(fround(NaN), NaN);
    sameValue(fround(0), 0);
    sameValue(fround(-0), -0);
    sameValue(fround(Number.MIN_VALUE), 0);
    sameValue(fround(-Number.MIN_VALUE), -0);
    assert.strictEqual(fround(Infinity), Infinity);
    assert.strictEqual(fround(-Infinity), -Infinity);
    assert.strictEqual(fround(1.7976931348623157e+308), Infinity);
    assert.strictEqual(fround(-1.7976931348623157e+308), -Infinity);
    assert.strictEqual(fround(3.4028235677973366e+38), Infinity);
    assert.strictEqual(fround(3), 3);
    assert.strictEqual(fround(-3), -3);
    maxFloat32 = 3.4028234663852886e+38;
    minFloat32 = 1.401298464324817e-45;
    assert.strictEqual(fround(maxFloat32), maxFloat32);
    assert.strictEqual(fround(-maxFloat32), -maxFloat32);
    assert.strictEqual(fround(maxFloat32 + Math.pow(2, Math.pow(2, 8 - 1) - 1 - 23 - 2)), maxFloat32);
    assert.strictEqual(fround(minFloat32), minFloat32);
    assert.strictEqual(fround(-minFloat32), -minFloat32);
    sameValue(fround(minFloat32 / 2), 0);
    sameValue(fround(-minFloat32 / 2), -0);
    assert.strictEqual(fround(minFloat32 / 2 + Math.pow(2, -202)), minFloat32);
    return assert.strictEqual(fround(-minFloat32 / 2 - Math.pow(2, -202)), -minFloat32);
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Math.hypot', function(assert){
    var epsilon, sameValue, hypot, sqrt;
    epsilon = function(a, b, E){
      return Math.abs(a - b) <= (E != null ? E : 1e-11);
    };
    sameValue = function(a, b, c){
      return assert.ok(a === b
        ? a !== 0 || 1 / a === 1 / b
        : a != a && b != b, c);
    };
    hypot = Math.hypot, sqrt = Math.sqrt;
    assert.ok(toString$.call(hypot).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(hypot.name, 'hypot', 'name is "hypot"');
    assert.strictEqual(hypot.length, 2, 'arity is 2');
    assert.ok(/native code/.test(hypot), 'looks like native');
    assert.strictEqual(hypot(), 0);
    assert.strictEqual(hypot(1), 1);
    sameValue(hypot('', 0), 0);
    sameValue(hypot(0, ''), 0);
    assert.strictEqual(hypot(Infinity, 0), Infinity);
    assert.strictEqual(hypot(-Infinity, 0), Infinity);
    assert.strictEqual(hypot(0, Infinity), Infinity);
    assert.strictEqual(hypot(0, -Infinity), Infinity);
    assert.strictEqual(hypot(Infinity, NaN), Infinity);
    assert.strictEqual(hypot(NaN, -Infinity), Infinity);
    sameValue(hypot(NaN, 0), NaN);
    sameValue(hypot(0, NaN), NaN);
    sameValue(hypot(0, -0), 0);
    sameValue(hypot(0, 0), 0);
    sameValue(hypot(-0, -0), 0);
    sameValue(hypot(-0, 0), 0);
    assert.strictEqual(hypot(0, 1), 1);
    assert.strictEqual(hypot(0, -1), 1);
    assert.strictEqual(hypot(-0, 1), 1);
    assert.strictEqual(hypot(-0, -1), 1);
    sameValue(hypot(0), 0);
    assert.strictEqual(hypot(1), 1);
    assert.strictEqual(hypot(2), 2);
    assert.strictEqual(hypot(0, 0, 1), 1);
    assert.strictEqual(hypot(0, 1, 0), 1);
    assert.strictEqual(hypot(1, 0, 0), 1);
    assert.strictEqual(hypot(2, 3, 4), sqrt(2 * 2 + 3 * 3 + 4 * 4));
    assert.strictEqual(hypot(2, 3, 4, 5), sqrt(2 * 2 + 3 * 3 + 4 * 4 + 5 * 5));
    assert.ok(epsilon(hypot(66, 66), 93.33809511662427));
    assert.ok(epsilon(hypot(0.1, 100), 100.0000499999875));
    assert.strictEqual(hypot(1e+300, 1e+300), 1.4142135623730952e+300);
    assert.strictEqual(Math.floor(hypot(1e-300, 1e-300) * 1e308), 141421356);
    assert.strictEqual(hypot(1e+300, 1e+300, 2, 3), 1.4142135623730952e+300);
    assert.strictEqual(hypot(-3, 4), 5);
    return assert.strictEqual(hypot(3, -4), 5);
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Math.imul', function(assert){
    var sameValue, imul;
    sameValue = function(a, b, c){
      return assert.ok(a === b
        ? a !== 0 || 1 / a === 1 / b
        : a != a && b != b, c);
    };
    imul = Math.imul;
    assert.ok(toString$.call(imul).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(imul.name, 'imul', 'name is "imul"');
    assert.strictEqual(imul.length, 2, 'arity is 2');
    assert.ok(/native code/.test(imul), 'looks like native');
    sameValue(imul(0, 0), 0);
    assert.strictEqual(imul(123, 456), 56088);
    assert.strictEqual(imul(-123, 456), -56088);
    assert.strictEqual(imul(123, -456), -56088);
    assert.strictEqual(imul(19088743, 4275878552), 602016552);
    sameValue(imul(false, 7), 0);
    sameValue(imul(7, false), 0);
    sameValue(imul(false, false), 0);
    assert.strictEqual(imul(true, 7), 7);
    assert.strictEqual(imul(7, true), 7);
    assert.strictEqual(imul(true, true), 1);
    sameValue(imul(void 8, 7), 0);
    sameValue(imul(7, void 8), 0);
    sameValue(imul(void 8, void 8), 0);
    sameValue(imul('str', 7), 0);
    sameValue(imul(7, 'str'), 0);
    sameValue(imul({}, 7), 0);
    sameValue(imul(7, {}), 0);
    sameValue(imul([], 7), 0);
    sameValue(imul(7, []), 0);
    assert.strictEqual(imul(0xffffffff, 5), -5);
    assert.strictEqual(imul(0xfffffffe, 5), -10);
    assert.strictEqual(imul(2, 4), 8);
    assert.strictEqual(imul(-1, 8), -8);
    assert.strictEqual(imul(-2, -2), 4);
    sameValue(imul(-0, 7), 0);
    sameValue(imul(7, -0), 0);
    sameValue(imul(0.1, 7), 0);
    sameValue(imul(7, 0.1), 0);
    sameValue(imul(0.9, 7), 0);
    sameValue(imul(7, 0.9), 0);
    assert.strictEqual(imul(1.1, 7), 7);
    assert.strictEqual(imul(7, 1.1), 7);
    assert.strictEqual(imul(1.9, 7), 7);
    return assert.strictEqual(imul(7, 1.9), 7);
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Math.log10', function(assert){
    var epsilon, sameValue, log10;
    epsilon = function(a, b, E){
      return Math.abs(a - b) <= (E != null ? E : 1e-11);
    };
    sameValue = function(a, b, c){
      return assert.ok(a === b
        ? a !== 0 || 1 / a === 1 / b
        : a != a && b != b, c);
    };
    log10 = Math.log10;
    assert.ok(toString$.call(log10).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(log10.name, 'log10', 'name is "log10"');
    assert.strictEqual(log10.length, 1, 'arity is 1');
    assert.ok(/native code/.test(log10), 'looks like native');
    sameValue(log10(''), log10(0));
    sameValue(log10(NaN), NaN);
    sameValue(log10(-1), NaN);
    sameValue(log10(0), -Infinity);
    sameValue(log10(-0), -Infinity);
    sameValue(log10(1), 0);
    sameValue(log10(Infinity), Infinity);
    assert.ok(epsilon(log10(0.1), -1));
    assert.ok(epsilon(log10(0.5), -0.3010299956639812));
    assert.ok(epsilon(log10(1.5), 0.17609125905568124));
    assert.ok(epsilon(log10(5), 0.6989700043360189));
    return assert.ok(epsilon(log10(50), 1.6989700043360187));
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Math.log1p', function(assert){
    var epsilon, sameValue, log1p;
    epsilon = function(a, b, E){
      return Math.abs(a - b) <= (E != null ? E : 1e-11);
    };
    sameValue = function(a, b, c){
      return assert.ok(a === b
        ? a !== 0 || 1 / a === 1 / b
        : a != a && b != b, c);
    };
    log1p = Math.log1p;
    assert.ok(toString$.call(log1p).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(log1p.name, 'log1p', 'name is "log1p"');
    assert.strictEqual(log1p.length, 1, 'arity is 1');
    assert.ok(/native code/.test(log1p), 'looks like native');
    sameValue(log1p(''), log1p(0));
    sameValue(log1p(NaN), NaN);
    sameValue(log1p(-2), NaN);
    sameValue(log1p(-1), -Infinity);
    sameValue(log1p(0), 0);
    sameValue(log1p(-0), -0);
    sameValue(log1p(Infinity), Infinity);
    assert.ok(epsilon(log1p(5), 1.791759469228055));
    return assert.ok(epsilon(log1p(50), 3.9318256327243257));
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Math.log2', function(assert){
    var epsilon, sameValue, log2;
    epsilon = function(a, b, E){
      return Math.abs(a - b) <= (E != null ? E : 1e-11);
    };
    sameValue = function(a, b, c){
      return assert.ok(a === b
        ? a !== 0 || 1 / a === 1 / b
        : a != a && b != b, c);
    };
    log2 = Math.log2;
    assert.ok(toString$.call(log2).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(log2.name, 'log2', 'name is "log2"');
    assert.strictEqual(log2.length, 1, 'arity is 1');
    assert.ok(/native code/.test(log2), 'looks like native');
    sameValue(log2(''), log2(0));
    sameValue(log2(NaN), NaN);
    sameValue(log2(-1), NaN);
    sameValue(log2(0), -Infinity);
    sameValue(log2(-0), -Infinity);
    sameValue(log2(1), 0);
    sameValue(log2(Infinity), Infinity);
    sameValue(log2(0.5), -1);
    sameValue(log2(32), 5);
    return assert.ok(epsilon(log2(5), 2.321928094887362));
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Math.sign', function(assert){
    var sameValue, sign;
    sameValue = function(a, b, c){
      return assert.ok(a === b
        ? a !== 0 || 1 / a === 1 / b
        : a != a && b != b, c);
    };
    sign = Math.sign;
    assert.ok(toString$.call(sign).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(sign.name, 'sign', 'name is "sign"');
    assert.strictEqual(sign.length, 1, 'arity is 1');
    assert.ok(/native code/.test(sign), 'looks like native');
    sameValue(sign(NaN), NaN);
    sameValue(sign(), NaN);
    sameValue(sign(-0), -0);
    sameValue(sign(0), 0);
    assert.strictEqual(sign(Infinity), 1);
    assert.strictEqual(sign(-Infinity), -1);
    assert.strictEqual(sign(13510798882111488), 1);
    assert.strictEqual(sign(-13510798882111488), -1);
    assert.strictEqual(sign(42.5), 1);
    return assert.strictEqual(sign(-42.5), -1);
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Math.sinh', function(assert){
    var epsilon, sameValue, sinh;
    epsilon = function(a, b, E){
      return Math.abs(a - b) <= (E != null ? E : 1e-11);
    };
    sameValue = function(a, b, c){
      return assert.ok(a === b
        ? a !== 0 || 1 / a === 1 / b
        : a != a && b != b, c);
    };
    sinh = Math.sinh;
    assert.ok(toString$.call(sinh).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(sinh.name, 'sinh', 'name is "sinh"');
    assert.strictEqual(sinh.length, 1, 'arity is 1');
    assert.ok(/native code/.test(sinh), 'looks like native');
    sameValue(sinh(NaN), NaN);
    sameValue(sinh(0), 0);
    sameValue(sinh(-0), -0);
    assert.strictEqual(sinh(Infinity), Infinity);
    assert.strictEqual(sinh(-Infinity), -Infinity);
    assert.ok(epsilon(sinh(-5), -74.20321057778875));
    assert.ok(epsilon(sinh(2), 3.6268604078470186));
    return assert.strictEqual(sinh(-2e-17), -2e-17);
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Math.tanh', function(assert){
    var epsilon, sameValue, tanh;
    epsilon = function(a, b, E){
      return Math.abs(a - b) <= (E != null ? E : 1e-11);
    };
    sameValue = function(a, b, c){
      return assert.ok(a === b
        ? a !== 0 || 1 / a === 1 / b
        : a != a && b != b, c);
    };
    tanh = Math.tanh;
    assert.ok(toString$.call(tanh).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(tanh.name, 'tanh', 'name is "tanh"');
    assert.strictEqual(tanh.length, 1, 'arity is 1');
    assert.ok(/native code/.test(tanh), 'looks like native');
    sameValue(tanh(NaN), NaN);
    sameValue(tanh(0), 0);
    sameValue(tanh(-0), -0);
    assert.strictEqual(tanh(Infinity), 1);
    assert.strictEqual(tanh(90), 1);
    return assert.ok(epsilon(tanh(10), 0.9999999958776927));
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Math.trunc', function(assert){
    var sameValue, trunc;
    sameValue = function(a, b, c){
      return assert.ok(a === b
        ? a !== 0 || 1 / a === 1 / b
        : a != a && b != b, c);
    };
    trunc = Math.trunc;
    assert.ok(toString$.call(trunc).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(trunc.name, 'trunc', 'name is "trunc"');
    assert.strictEqual(trunc.length, 1, 'arity is 1');
    assert.ok(/native code/.test(trunc), 'looks like native');
    sameValue(trunc(NaN), NaN, 'NaN -> NaN');
    sameValue(trunc(-0), -0, '-0 -> -0');
    sameValue(trunc(0), 0, '0 -> 0');
    sameValue(trunc(Infinity), Infinity, 'Infinity -> Infinity');
    sameValue(trunc(-Infinity), -Infinity, '-Infinity -> -Infinity');
    sameValue(trunc(null), 0, 'null -> 0');
    sameValue(trunc({}), NaN, '{} -> NaN');
    assert.strictEqual(trunc([]), 0, '[] -> 0');
    assert.strictEqual(trunc(1.01), 1, '1.01 -> 0');
    assert.strictEqual(trunc(1.99), 1, '1.99 -> 0');
    assert.strictEqual(trunc(-1), -1, '-1 -> -1');
    assert.strictEqual(trunc(-1.99), -1, '-1.99 -> -1');
    assert.strictEqual(trunc(-555.555), -555, '-555.555 -> -555');
    assert.strictEqual(trunc(0x20000000000001), 0x20000000000001, '0x20000000000001 -> 0x20000000000001');
    return assert.strictEqual(trunc(-0x20000000000001), -0x20000000000001, '-0x20000000000001 -> -0x20000000000001');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, $check, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  $check = function(assert){
    return function(a, b){
      var sameValue, x;
      sameValue = function(a, b, c){
        return assert.ok(a === b
          ? a !== 0 || 1 / a === 1 / b
          : a != a && b != b, c);
      };
      sameValue(Number(a), b, "Number " + typeof a + " " + a + " -> " + b);
      x = new Number(a);
      assert.ok(x === Object(x), "new Number " + typeof a + " " + a + " is object");
      assert.strictEqual(toString$.call(x).slice(8, -1), 'Number', "classof new Number " + typeof a + " " + a + " is Number");
      return sameValue(x.valueOf(), b, "new Number(" + typeof a + " " + a + ").valueOf() -> " + b);
    };
  };
  test('Number constructor: regression', function(assert){
    var check, i, i$, x$, ref$, len$, n;
    check = $check(assert);
    assert.ok(toString$.call(Number).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(Number.length, 1, 'arity is 1');
    assert.ok(/native code/.test(Number), 'looks like native');
    assert.strictEqual(Number.name, 'Number', 'name is "Number"');
    check(42, 42);
    check(42.42, 42.42);
    check(new Number(42), 42);
    check(new Number(42.42), 42.42);
    check('42', 42);
    check('42.42', 42.42);
    check('0x42', 66);
    check('0X42', 66);
    check('0xzzz', NaN);
    check(new String('42'), 42);
    check(new String('42.42'), 42.42);
    check(new String('0x42'), 66);
    check(null, 0);
    check(void 8, NaN);
    check(false, 0);
    check(true, 1);
    check(new Boolean(false), 0);
    check(new Boolean(true), 1);
    check({
      valueOf: function(){
        return 42;
      }
    }, 42);
    check({
      valueOf: function(){
        return '42';
      }
    }, 42);
    check({
      valueOf: function(){
        return null;
      }
    }, 0);
    check({
      toString: function(){
        return 42;
      }
    }, 42);
    check({
      toString: function(){
        return '42';
      }
    }, 42);
    check({
      valueOf: function(){
        return 1;
      },
      toString: function(){
        return 2;
      }
    }, 1);
    check({
      valueOf: 1,
      toString: function(){
        return 2;
      }
    }, 2);
    i = 1;
    assert.strictEqual(Number({
      valueOf: function(){
        return ++i;
      }
    }), 2, 'Number call valueOf only once #1');
    assert.strictEqual(i, 2, 'Number call valueOf only once #2');
    i = 1;
    assert.strictEqual(Number({
      toString: function(){
        return ++i;
      }
    }), 2, 'Number call toString only once #1');
    assert.strictEqual(i, 2, 'Number call toString only once #2');
    i = 1;
    assert.strictEqual(new Number({
      valueOf: function(){
        return ++i;
      }
    }).valueOf(), 2, 'new Number call valueOf only once #1');
    assert.strictEqual(i, 2, 'new Number call valueOf only once #2');
    i = 1;
    assert.strictEqual(new Number({
      toString: function(){
        return ++i;
      }
    }).valueOf(), 2, 'new Number call toString only once #1');
    assert.strictEqual(i, 2, 'new Number call toString only once #2');
    assert.throws(function(){
      return Number(Object.create(null));
    }, TypeError, 'Number assert.throws on object w/o valueOf and toString');
    assert.throws(function(){
      return Number({
        valueOf: 1,
        toString: 2
      });
    }, TypeError, 'Number assert.throws on object then valueOf and toString are not functions');
    assert.throws(function(){
      return new Number(Object.create(null));
    }, TypeError, 'new Number assert.throws on object w/o valueOf and toString');
    assert.throws(function(){
      return new Number({
        valueOf: 1,
        toString: 2
      });
    }, TypeError, 'new Number assert.throws on object then valueOf and toString are not functions');
    for (i$ = 0, len$ = (ref$ = ['MAX_VALUE', 'MIN_VALUE', 'NaN', 'NEGATIVE_INFINITY', 'POSITIVE_INFINITY']).length; i$ < len$; ++i$) {
      x$ = ref$[i$];
      assert.ok(x$ in Number, x$ + " in Number");
    }
    n = new Number(42);
    return assert.strictEqual(typeof n.constructor(n), 'number');
  });
  test('Number constructor: binary', function(assert){
    var check;
    check = $check(assert);
    check('0b1', 1);
    check('0B1', 1);
    check('0b234', NaN);
    check({
      valueOf: function(){
        return '0b11';
      }
    }, 3);
    return check({
      toString: function(){
        return '0b111';
      }
    }, 7);
  });
  test('Number constructor: octal', function(assert){
    var check;
    check = $check(assert);
    check('0o7', 7);
    check('0O7', 7);
    check('0o89a', NaN);
    check({
      valueOf: function(){
        return '0o77';
      }
    }, 63);
    return check({
      toString: function(){
        return '0o777';
      }
    }, 511);
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Number.EPSILON', function(assert){
    var EPSILON;
    EPSILON = Number.EPSILON;
    assert.ok('EPSILON' in Number, 'EPSILON in Number');
    assert.strictEqual(EPSILON, Math.pow(2, -52), 'Is 2^-52');
    assert.ok(1 !== 1 + EPSILON, '1 isnt 1 + EPSILON');
    return assert.strictEqual(1, 1 + EPSILON / 2, '1 is 1 + EPSILON / 2');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Number.isFinite', function(assert){
    var isFinite, create, i$, x$, ref$, len$, y$, e, results$ = [];
    isFinite = Number.isFinite;
    create = Object.create;
    assert.ok(toString$.call(isFinite).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(isFinite.name, 'isFinite', 'name is "isFinite"');
    assert.strictEqual(isFinite.length, 1, 'arity is 1');
    assert.ok(/native code/.test(isFinite), 'looks like native');
    for (i$ = 0, len$ = (ref$ = [1, 0.1, -1, Math.pow(2, 16), Math.pow(2, 16) - 1, Math.pow(2, 31), Math.pow(2, 31) - 1, Math.pow(2, 32), Math.pow(2, 32) - 1, -0]).length; i$ < len$; ++i$) {
      x$ = ref$[i$];
      assert.ok(isFinite(x$), "isFinite " + typeof x$ + " " + x$);
    }
    for (i$ = 0, len$ = (ref$ = [NaN, Infinity, 'NaN', '5', false, new Number(NaN), new Number(Infinity), new Number(5), new Number(0.1), void 8, null, {}, fn$, create(null)]).length; i$ < len$; ++i$) {
      y$ = ref$[i$];
      results$.push(assert.ok(!isFinite(y$), "not isFinite " + typeof y$ + " " + (fn1$())));
    }
    return results$;
    function fn$(){}
    function fn1$(){
      try {
        return String(y$);
      } catch (e$) {
        e = e$;
        return 'Object.create(null)';
      }
    }
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Number.isInteger', function(assert){
    var isInteger, create, i$, x$, ref$, len$, y$, e, results$ = [];
    isInteger = Number.isInteger;
    create = Object.create;
    assert.ok(toString$.call(isInteger).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(isInteger.name, 'isInteger', 'name is "isInteger"');
    assert.strictEqual(isInteger.length, 1, 'arity is 1');
    assert.ok(/native code/.test(isInteger), 'looks like native');
    for (i$ = 0, len$ = (ref$ = [1, -1, Math.pow(2, 16), Math.pow(2, 16) - 1, Math.pow(2, 31), Math.pow(2, 31) - 1, Math.pow(2, 32), Math.pow(2, 32) - 1, -0]).length; i$ < len$; ++i$) {
      x$ = ref$[i$];
      assert.ok(isInteger(x$), "isInteger " + typeof x$ + " " + x$);
    }
    for (i$ = 0, len$ = (ref$ = [NaN, 0.1, Infinity, 'NaN', '5', false, new Number(NaN), new Number(Infinity), new Number(5), new Number(0.1), void 8, null, {}, fn$, create(null)]).length; i$ < len$; ++i$) {
      y$ = ref$[i$];
      results$.push(assert.ok(!isInteger(y$), "not isInteger " + typeof y$ + " " + (fn1$())));
    }
    return results$;
    function fn$(){}
    function fn1$(){
      try {
        return String(y$);
      } catch (e$) {
        e = e$;
        return 'Object.create(null)';
      }
    }
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Number.isNaN', function(assert){
    var isNaN, create, i$, x$, ref$, len$, e, results$ = [];
    isNaN = Number.isNaN;
    create = Object.create;
    assert.ok(toString$.call(isNaN).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(isNaN.name, 'isNaN', 'name is "isNaN"');
    assert.strictEqual(isNaN.length, 1, 'arity is 1');
    assert.ok(/native code/.test(isNaN), 'looks like native');
    assert.ok(isNaN(NaN), 'Number.isNaN NaN');
    for (i$ = 0, len$ = (ref$ = [1, 0.1, -1, Math.pow(2, 16), Math.pow(2, 16) - 1, Math.pow(2, 31), Math.pow(2, 31) - 1, Math.pow(2, 32), Math.pow(2, 32) - 1, -0, Infinity, 'NaN', '5', false, new Number(NaN), new Number(Infinity), new Number(5), new Number(0.1), void 8, null, {}, fn$, create(null)]).length; i$ < len$; ++i$) {
      x$ = ref$[i$];
      results$.push(assert.ok(!isNaN(x$), "not Number.isNaN " + typeof x$ + " " + (fn1$())));
    }
    return results$;
    function fn$(){}
    function fn1$(){
      try {
        return String(x$);
      } catch (e$) {
        e = e$;
        return 'Object.create(null)';
      }
    }
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Number.isSafeInteger', function(assert){
    var isSafeInteger, create, i$, x$, ref$, len$, y$, e, results$ = [];
    isSafeInteger = Number.isSafeInteger;
    create = Object.create;
    assert.ok(toString$.call(isSafeInteger).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(isSafeInteger.name, 'isSafeInteger', 'name is "isSafeInteger"');
    assert.strictEqual(isSafeInteger.length, 1, 'arity is 1');
    assert.ok(/native code/.test(isSafeInteger), 'looks like native');
    for (i$ = 0, len$ = (ref$ = [1, -1, Math.pow(2, 16), Math.pow(2, 16) - 1, Math.pow(2, 31), Math.pow(2, 31) - 1, Math.pow(2, 32), Math.pow(2, 32) - 1, -0, 9007199254740991, -9007199254740991]).length; i$ < len$; ++i$) {
      x$ = ref$[i$];
      assert.ok(isSafeInteger(x$), "isSafeInteger " + typeof x$ + " " + x$);
    }
    for (i$ = 0, len$ = (ref$ = [9007199254740992, -9007199254740992, NaN, 0.1, Infinity, 'NaN', '5', false, new Number(NaN), new Number(Infinity), new Number(5), new Number(0.1), void 8, null, {}, fn$, create(null)]).length; i$ < len$; ++i$) {
      y$ = ref$[i$];
      results$.push(assert.ok(!isSafeInteger(y$), "not isSafeInteger " + typeof y$ + " " + (fn1$())));
    }
    return results$;
    function fn$(){}
    function fn1$(){
      try {
        return String(y$);
      } catch (e$) {
        e = e$;
        return 'Object.create(null)';
      }
    }
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Number.MAX_SAFE_INTEGER', function(assert){
    return assert.strictEqual(Number.MAX_SAFE_INTEGER, Math.pow(2, 53) - 1, 'Is 2^53 - 1');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Number.MIN_SAFE_INTEGER', function(assert){
    return assert.strictEqual(Number.MIN_SAFE_INTEGER, -Math.pow(2, 53) + 1, 'Is -2^53 + 1');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Number.parseFloat', function(assert){
    assert.ok(toString$.call(Number.parseFloat).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(Number.parseFloat.name, 'parseFloat', 'name is "parseFloat"');
    assert.strictEqual(Number.parseFloat.length, 1, 'arity is 1');
    return assert.ok(/native code/.test(Number.parseFloat), 'looks like native');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Number.parseInt', function(assert){
    assert.ok(toString$.call(Number.parseInt).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(Number.parseInt.name, 'parseInt', 'name is "parseInt"');
    assert.strictEqual(Number.parseInt.length, 2, 'arity is 2');
    return assert.ok(/native code/.test(Number.parseInt), 'looks like native');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, descriptors, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  descriptors = function(){
    try {
      return 2 === Object.defineProperty({}, 'a', {
        get: function(){
          return 2;
        }
      }).a;
    } catch (e$) {}
  }();
  test('Object.assign', function(assert){
    var assign, keys, defineProperty, foo, str, c, d, D, ref$, O, string, i$, x$, len$;
    assign = Object.assign, keys = Object.keys, defineProperty = Object.defineProperty;
    assert.ok(toString$.call(assign).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(assign.length, 2, 'arity is 2');
    assert.strictEqual(assign.name, 'assign', 'name is "assign"');
    assert.ok(/native code/.test(assign), 'looks like native');
    foo = {
      q: 1
    };
    assert.strictEqual(foo, assign(foo, {
      bar: 2
    }), 'assign return target');
    assert.strictEqual(foo.bar, 2, 'assign define properties');
    assert.deepEqual(assign({}, {
      q: 1
    }, {
      w: 2
    }), {
      q: 1,
      w: 2
    });
    assert.deepEqual(assign({}, 'qwe'), {
      0: 'q',
      1: 'w',
      2: 'e'
    });
    assert.throws(function(){
      return assign(null, {
        q: 1
      });
    }, TypeError);
    assert.throws(function(){
      return assign(void 8, {
        q: 1
      });
    }, TypeError);
    str = assign('qwe', {
      q: 1
    });
    assert.strictEqual(typeof str, 'object');
    assert.strictEqual(String(str), 'qwe');
    assert.strictEqual(str.q, 1);
    if (descriptors) {
      foo = {
        baz: 1
      };
      assign(foo, defineProperty({}, 'bar', {
        get: function(){
          return this.baz + 1;
        }
      }));
      assert.ok(foo.bar === void 8, "assign don't copy descriptors");
      c = Symbol('c');
      d = Symbol('d');
      D = (ref$ = {
        a: 'a'
      }, ref$[c] = 'c', ref$);
      defineProperty(D, 'b', {
        value: 'b'
      });
      defineProperty(D, d, {
        value: 'd'
      });
      O = assign({}, D);
      assert.strictEqual(O.a, 'a', 'a');
      assert.strictEqual(O.b, void 8, 'b');
      assert.strictEqual(O[c], 'c', 'c');
      assert.strictEqual(O[d], void 8, 'd');
      try {
        assert.strictEqual(Function('return Object.assign({b: 1}, {get a(){delete this.b;},b: 2})')().b, 1);
      } catch (e$) {}
    }
    string = 'abcdefghijklmnopqrst';
    O = {};
    for (i$ = 0, len$ = (ref$ = string.split('')).length; i$ < len$; ++i$) {
      x$ = ref$[i$];
      O[x$] = x$;
    }
    return assert.strictEqual(keys(assign({}, O)).join(''), string);
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Object.is', function(assert){
    var same;
    same = Object.is;
    assert.ok(toString$.call(same).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(same.length, 2, 'arity is 2');
    assert.strictEqual(same.name, 'is', 'name is "is"');
    assert.ok(/native code/.test(same), 'looks like native');
    assert.ok(same(1, 1), '1 is 1');
    assert.ok(same(NaN, NaN), '1 is 1');
    assert.ok(!same(0, -0), '0 isnt -0');
    return assert.ok(!same({}, {}), '{} isnt {}');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  if (Object.setPrototypeOf || '__proto__' in Object.prototype) {
    module = QUnit.module, test = QUnit.test;
    module('ES6');
    test('Object.setPrototypeOf', function(assert){
      var setPrototypeOf, tmp;
      setPrototypeOf = Object.setPrototypeOf;
      assert.ok(toString$.call(setPrototypeOf).slice(8, -1) === 'Function', 'is function');
      assert.strictEqual(setPrototypeOf.length, 2, 'arity is 2');
      assert.strictEqual(setPrototypeOf.name, 'setPrototypeOf', 'name is "setPrototypeOf"');
      assert.ok(/native code/.test(setPrototypeOf), 'looks like native');
      assert.ok('apply' in setPrototypeOf({}, Function.prototype), 'Parent properties in target');
      assert.strictEqual(setPrototypeOf({
        a: 2
      }, {
        b: function(){
          return Math.pow(this.a, 2);
        }
      }).b(), 4, 'Child and parent properties in target');
      assert.strictEqual(setPrototypeOf(tmp = {}, {
        a: 1
      }), tmp, 'setPrototypeOf return target');
      return assert.ok(!('toString' in setPrototypeOf({}, null)), 'Can set null as prototype');
    });
  }
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Object static methods accept primitives', function(assert){
    var i$, ref$, len$, method, j$, ref1$, len1$, value;
    for (i$ = 0, len$ = (ref$ = ['freeze', 'seal', 'preventExtensions', 'getOwnPropertyDescriptor', 'getPrototypeOf', 'isExtensible', 'isSealed', 'isFrozen', 'keys', 'getOwnPropertyNames']).length; i$ < len$; ++i$) {
      method = ref$[i$];
      assert.ok(/native code/.test(Object[method]), "Object." + method + " looks like native");
      for (j$ = 0, len1$ = (ref1$ = [42, 'foo', false]).length; j$ < len1$; ++j$) {
        value = ref1$[j$];
        assert.ok((fn$()), "Object." + method + " accept " + toString$.call(value).slice(8, -1));
      }
    }
    for (i$ = 0, len$ = (ref$ = ['freeze', 'seal', 'preventExtensions']).length; i$ < len$; ++i$) {
      method = ref$[i$];
      for (j$ = 0, len1$ = (ref1$ = [42, 'foo', false, null, void 8, {}]).length; j$ < len1$; ++j$) {
        value = ref1$[j$];
        assert.strictEqual(Object[method](value), value, "Object." + method + " returns target on " + toString$.call(value).slice(8, -1));
      }
    }
    for (i$ = 0, len$ = (ref$ = ['isSealed', 'isFrozen']).length; i$ < len$; ++i$) {
      method = ref$[i$];
      for (j$ = 0, len1$ = (ref1$ = [42, 'foo', false, null, void 8]).length; j$ < len1$; ++j$) {
        value = ref1$[j$];
        assert.strictEqual(Object[method](value), true, "Object." + method + " returns true on " + toString$.call(value).slice(8, -1));
      }
    }
    for (i$ = 0, len$ = (ref$ = [42, 'foo', false, null, void 8]).length; i$ < len$; ++i$) {
      value = ref$[i$];
      assert.strictEqual(Object.isExtensible(value), false, "Object.isExtensible returns false on " + toString$.call(value).slice(8, -1));
    }
    for (i$ = 0, len$ = (ref$ = ['getOwnPropertyDescriptor', 'getPrototypeOf', 'keys', 'getOwnPropertyNames']).length; i$ < len$; ++i$) {
      method = ref$[i$];
      for (j$ = 0, len1$ = (ref1$ = [null, void 8]).length; j$ < len1$; ++j$) {
        value = ref1$[j$];
        assert.throws(fn1$, TypeError, "Object." + method + " assert.throws on " + value);
      }
    }
    return assert.strictEqual(Object.getPrototypeOf('foo'), String.prototype);
    function fn$(){
      try {
        Object[method](value);
        return true;
      } catch (e$) {}
    }
    function fn1$(){
      return Object[method](value);
    }
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  'use strict';
  var module, test;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Object#toString', function(assert){
    var toString, Class;
    assert.strictEqual(Object.prototype.toString.length, 0, 'arity is 0');
    assert.strictEqual(Object.prototype.toString.name, 'toString', 'name is "toString"');
    assert.ok(/native code/.test(Object.prototype.toString), 'looks like native');
    toString = Object.prototype.toString;
    if (!function(){
      return this;
    }()) {
      assert.strictEqual(toString.call(null), '[object Null]', 'classof null is `Null`');
      assert.strictEqual(toString.call(void 8), '[object Undefined]', 'classof void is `Undefined`');
    }
    assert.strictEqual(toString.call(true), '[object Boolean]', 'classof bool is `Boolean`');
    assert.strictEqual(toString.call('string'), '[object String]', 'classof string is `String`');
    assert.strictEqual(toString.call(7), '[object Number]', 'classof number is `Number`');
    assert.strictEqual(toString.call(Symbol()), '[object Symbol]', 'classof symbol is `Symbol`');
    assert.strictEqual(toString.call(new Boolean(false)), '[object Boolean]', 'classof new Boolean is `Boolean`');
    assert.strictEqual(toString.call(new String('')), '[object String]', 'classof new String is `String`');
    assert.strictEqual(toString.call(new Number(7)), '[object Number]', 'classof new Number is `Number`');
    assert.strictEqual('' + {}, '[object Object]', 'classof {} is `Object`');
    assert.strictEqual(toString.call([]), '[object Array]', 'classof array is `Array`');
    assert.strictEqual(toString.call(function(){}), '[object Function]', 'classof function is `Function`');
    assert.strictEqual(toString.call(/./), '[object RegExp]', 'classof regexp is `Undefined`');
    assert.strictEqual(toString.call(TypeError()), '[object Error]', 'classof new TypeError is `RegExp`');
    assert.strictEqual(toString.call(function(){
      return arguments;
    }()), '[object Arguments]', 'classof arguments list is `Arguments`');
    assert.strictEqual('' + new Set, '[object Set]', 'classof undefined is `Map`');
    assert.strictEqual('' + new Map, '[object Map]', 'classof map is `Undefined`');
    assert.strictEqual('' + new WeakSet, '[object WeakSet]', 'classof weakset is `WeakSet`');
    assert.strictEqual('' + new WeakMap, '[object WeakMap]', 'classof weakmap is `WeakMap`');
    assert.strictEqual('' + new Promise(function(){}), '[object Promise]', 'classof promise is `Promise`');
    assert.strictEqual('' + ''[Symbol.iterator](), '[object String Iterator]', 'classof String Iterator is `String Iterator`');
    assert.strictEqual('' + [].entries(), '[object Array Iterator]', 'classof Array Iterator is `Array Iterator`');
    assert.strictEqual('' + new Set().entries(), '[object Set Iterator]', 'classof Set Iterator is `Set Iterator`');
    assert.strictEqual('' + new Map().entries(), '[object Map Iterator]', 'classof Map Iterator is `Map Iterator`');
    assert.strictEqual('' + Math, '[object Math]', 'classof Math is `Math`');
    if (typeof JSON != 'undefined' && JSON !== null) {
      assert.strictEqual(toString.call(JSON), '[object JSON]', 'classof JSON is `JSON`');
    }
    Class = (function(){
      Class.displayName = 'Class';
      var prototype = Class.prototype, constructor = Class;
      Class.prototype[Symbol.toStringTag] = 'Class';
      function Class(){}
      return Class;
    }());
    return assert.strictEqual('' + new Class, '[object Class]', 'classof user class is [Symbol.toStringTag]');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, isFunction, iterator, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  isFunction = function(it){
    return toString$.call(it).slice(8, -1) === 'Function';
  };
  iterator = Symbol.iterator;
  test('Promise', function(assert){
    assert.ok(isFunction(((typeof global != 'undefined' && global !== null) && global || window).Promise), 'is function');
    assert.strictEqual(Promise.length, 1, 'arity is 1');
    assert.strictEqual(Promise.name, 'Promise', 'name is "Promise"');
    return assert.ok(/native code/.test(Promise), 'looks like native');
  });
  test('Promise#then', function(assert){
    assert.ok(isFunction(Promise.prototype.then), 'is function');
    assert.strictEqual(Promise.prototype.then.length, 2, 'arity is 2');
    assert.strictEqual(Promise.prototype.then.name, 'then', 'name is "then"');
    return assert.ok(/native code/.test(Promise.prototype.then), 'looks like native');
  });
  test('Promise#catch', function(assert){
    assert.ok(isFunction(Promise.prototype['catch']), 'is function');
    assert.strictEqual(Promise.prototype['catch'].length, 1, 'arity is 1');
    return assert.ok(/native code/.test(Promise.prototype.then), 'looks like native');
  });
  test('Promise#@@toStringTag', function(assert){
    return assert.ok(Promise.prototype[Symbol.toStringTag] === 'Promise', 'Promise::@@toStringTag is `Promise`');
  });
  test('Promise.all', function(assert){
    var passed, iter, next, a, done;
    assert.ok(isFunction(Promise.all), 'is function');
    assert.strictEqual(Promise.all.length, 1, 'arity is 1');
    assert.strictEqual(Promise.all.name, 'all', 'name is "all"');
    assert.ok(/native code/.test(Promise.all), 'looks like native');
    passed = false;
    iter = [1, 2, 3].values();
    next = bind$(iter, 'next');
    iter.next = function(){
      passed = true;
      return next();
    };
    Promise.all(iter)['catch'](function(){});
    assert.ok(passed, 'works with iterables');
    a = [];
    done = false;
    a[iterator] = function(){
      done = true;
      return [][iterator].call(this);
    };
    Promise.all(a);
    return assert.ok(done);
  });
  test('Promise.race', function(assert){
    var passed, iter, next, a, done;
    assert.ok(isFunction(Promise.race), 'is function');
    assert.strictEqual(Promise.race.length, 1, 'arity is 1');
    assert.strictEqual(Promise.race.name, 'race', 'name is "race"');
    assert.ok(/native code/.test(Promise.race), 'looks like native');
    passed = false;
    iter = [1, 2, 3].values();
    next = bind$(iter, 'next');
    iter.next = function(){
      passed = true;
      return next();
    };
    Promise.race(iter)['catch'](function(){});
    assert.ok(passed, 'works with iterables');
    a = [];
    done = false;
    a[iterator] = function(){
      done = true;
      return [][iterator].call(this);
    };
    Promise.race(a);
    return assert.ok(done);
  });
  test('Promise.resolve', function(assert){
    assert.ok(isFunction(Promise.resolve), 'is function');
    assert.strictEqual(Promise.resolve.length, 1, 'arity is 1');
    assert.strictEqual(Promise.resolve.name, 'resolve', 'name is "resolve"');
    return assert.ok(/native code/.test(Promise.resolve), 'looks like native');
  });
  test('Promise.reject', function(assert){
    assert.ok(isFunction(Promise.reject), 'is function');
    assert.strictEqual(Promise.reject.length, 1, 'arity is 1');
    assert.strictEqual(Promise.reject.name, 'reject', 'name is "reject"');
    return assert.ok(/native code/.test(Promise.reject), 'looks like native');
  });
  if (Object.setPrototypeOf) {
    test('Promise subclassing', function(assert){
      var SubPromise, p1, p2, p3;
      SubPromise = function(it){
        var self;
        self = new Promise(it);
        Object.setPrototypeOf(self, SubPromise.prototype);
        self.mine = 'subclass';
        return self;
      };
      Object.setPrototypeOf(SubPromise, Promise);
      SubPromise.prototype = Object.create(Promise.prototype);
      SubPromise.prototype.constructor = SubPromise;
      p1 = SubPromise.resolve(5);
      assert.strictEqual(p1.mine, 'subclass');
      p1 = p1.then(function(it){
        return assert.strictEqual(it, 5);
      });
      assert.strictEqual(p1.mine, 'subclass');
      p2 = new SubPromise(function(it){
        return it(6);
      });
      assert.strictEqual(p2.mine, 'subclass');
      p2 = p2.then(function(it){
        return assert.strictEqual(it, 6);
      });
      assert.strictEqual(p2.mine, 'subclass');
      p3 = SubPromise.all([p1, p2]);
      assert.strictEqual(p3.mine, 'subclass');
      assert.ok(p3 instanceof Promise);
      assert.ok(p3 instanceof SubPromise);
      return p3.then(assert.async(), function(it){
        return assert.ok(it, false);
      });
    });
  }
  function bind$(obj, key, target){
    return function(){ return (target || obj)[key].apply(obj, arguments) };
  }
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Reflect.apply', function(assert){
    var apply, C;
    apply = Reflect.apply;
    assert.ok(toString$.call(apply).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(apply.length, 3, 'arity is 3');
    assert.ok(/native code/.test(apply), 'looks like native');
    assert.strictEqual(apply.name, 'apply', 'name is "apply"');
    assert.strictEqual(apply(Array.prototype.push, [1, 2], [3, 4, 5]), 5);
    C = function(a, b, c){
      return a + b + c;
    };
    C.apply = 42;
    assert.strictEqual(apply(C, null, ['foo', 'bar', 'baz']), 'foobarbaz', 'works with redefined apply');
    return assert.throws(function(){
      return apply(42, null, []);
    }, TypeError, 'throws on primitive');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, getPrototypeOf, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  getPrototypeOf = Object.getPrototypeOf;
  test('Reflect.construct', function(assert){
    var construct, C, inst, f, e;
    construct = Reflect.construct;
    assert.ok(toString$.call(construct).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(construct.length, 2, 'arity is 2');
    assert.ok(/native code/.test(construct), 'looks like native');
    assert.strictEqual(construct.name, 'construct', 'name is "construct"');
    C = function(a, b, c){
      return this.qux = a + b + c;
    };
    assert.strictEqual(construct(C, ['foo', 'bar', 'baz']).qux, 'foobarbaz', 'basic');
    C.apply = 42;
    assert.strictEqual(construct(C, ['foo', 'bar', 'baz']).qux, 'foobarbaz', 'works with redefined apply');
    inst = construct(function(){
      return this.x = 42;
    }, [], Array);
    assert.strictEqual(inst.x, 42, 'constructor with newTarget');
    assert.ok(inst instanceof Array, 'prototype with newTarget');
    assert.throws(function(){
      return construct(42, []);
    }, TypeError, 'throws on primitive');
    f = function(){};
    f.prototype = 42;
    assert.ok((function(){
      try {
        return getPrototypeOf(construct(f, [])) === Object.prototype;
      } catch (e$) {
        e = e$;
        return false;
      }
    }()));
    return assert.strictEqual(construct(Set, [[1, 2, 3, 2, 1]]).size, 3, 'works with native constructors');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, defineProperty, getOwnPropertyDescriptor, MODERN, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  defineProperty = Object.defineProperty, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  MODERN = function(){
    try {
      return 2 === defineProperty({}, 'a', {
        get: function(){
          return 2;
        }
      }).a;
    } catch (e$) {}
  }();
  test('Reflect.defineProperty', function(assert){
    var defineProperty, O;
    defineProperty = Reflect.defineProperty;
    assert.ok(toString$.call(defineProperty).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(defineProperty.length, 3, 'arity is 3');
    assert.ok(/native code/.test(defineProperty), 'looks like native');
    assert.strictEqual(defineProperty.name, 'defineProperty', 'name is "defineProperty"');
    O = {};
    assert.strictEqual(defineProperty(O, 'foo', {
      value: 123
    }), true);
    assert.strictEqual(O.foo, 123);
    if (MODERN) {
      O = {};
      defineProperty(O, 'foo', {
        value: 123,
        enumerable: true
      });
      assert.deepEqual(getOwnPropertyDescriptor(O, 'foo'), {
        value: 123,
        enumerable: true,
        configurable: false,
        writable: false
      });
      assert.strictEqual(defineProperty(O, 'foo', {
        value: 42
      }), false);
    }
    return assert.throws(function(){
      return defineProperty(42, 'foo', {
        value: 42
      });
    }, TypeError, 'throws on primitive');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, defineProperty, MODERN, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  defineProperty = Object.defineProperty;
  MODERN = function(){
    try {
      return 2 === defineProperty({}, 'a', {
        get: function(){
          return 2;
        }
      }).a;
    } catch (e$) {}
  }();
  test('Reflect.deleteProperty', function(assert){
    var deleteProperty, O;
    deleteProperty = Reflect.deleteProperty;
    assert.ok(toString$.call(deleteProperty).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(deleteProperty.length, 2, 'arity is 2');
    assert.ok(/native code/.test(deleteProperty), 'looks like native');
    assert.strictEqual(deleteProperty.name, 'deleteProperty', 'name is "deleteProperty"');
    O = {
      bar: 456
    };
    assert.strictEqual(deleteProperty(O, 'bar'), true);
    assert.ok(!in$('bar', O));
    if (MODERN) {
      assert.strictEqual(deleteProperty(defineProperty({}, 'foo', {
        value: 42
      }), 'foo'), false);
    }
    return assert.throws(function(){
      return deleteProperty(42, 'foo');
    }, TypeError, 'throws on primitive');
  });
  function in$(x, xs){
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, defineProperty, from, MODERN, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  defineProperty = Object.defineProperty;
  from = Array.from;
  MODERN = function(){
    try {
      return 2 === defineProperty({}, 'a', {
        get: function(){
          return 2;
        }
      }).a;
    } catch (e$) {}
  }();
  test('Reflect.enumerate', function(assert){
    var enumerate, iterator, obj, i, ref$;
    enumerate = Reflect.enumerate;
    iterator = Symbol.iterator;
    assert.ok(toString$.call(enumerate).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(enumerate.length, 1, 'arity is 1');
    assert.ok(/native code/.test(enumerate), 'looks like native');
    assert.strictEqual(enumerate.name, 'enumerate', 'name is "enumerate"');
    obj = {
      foo: 1,
      bar: 2
    };
    i = enumerate(obj);
    assert.ok(iterator in i, 'returns iterator');
    assert.deepEqual(from(i), ['foo', 'bar'], 'bisic');
    obj = {
      q: 1,
      w: 2,
      e: 3
    };
    i = enumerate(obj);
    delete obj.w;
    assert.deepEqual(from(i), ['q', 'e'], 'ignore holes');
    obj = (ref$ = clone$({
      q: 1,
      w: 2,
      e: 3
    }), ref$.a = 4, ref$.s = 5, ref$.d = 6, ref$);
    assert.deepEqual(from(enumerate(obj)).sort(), ['a', 'd', 'e', 'q', 's', 'w'], 'works with prototype');
    return assert.throws(function(){
      return enumerate(42);
    }, TypeError, 'throws on primitive');
  });
  function clone$(it){
    function fun(){} fun.prototype = it;
    return new fun;
  }
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Reflect.getOwnPropertyDescriptor', function(assert){
    var getOwnPropertyDescriptor, obj, desc;
    getOwnPropertyDescriptor = Reflect.getOwnPropertyDescriptor;
    assert.ok(toString$.call(getOwnPropertyDescriptor).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(getOwnPropertyDescriptor.length, 2, 'arity is 2');
    assert.ok(/native code/.test(getOwnPropertyDescriptor), 'looks like native');
    assert.strictEqual(getOwnPropertyDescriptor.name, 'getOwnPropertyDescriptor', 'name is "getOwnPropertyDescriptor"');
    obj = {
      baz: 789
    };
    desc = getOwnPropertyDescriptor(obj, 'baz');
    assert.strictEqual(desc.value, 789);
    return assert.throws(function(){
      return getOwnPropertyDescriptor(42, 'constructor');
    }, TypeError, 'throws on primitive');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Reflect.getPrototypeOf', function(assert){
    var getPrototypeOf;
    getPrototypeOf = Reflect.getPrototypeOf;
    assert.ok(toString$.call(getPrototypeOf).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(getPrototypeOf.length, 1, 'arity is 1');
    assert.ok(/native code/.test(getPrototypeOf), 'looks like native');
    assert.strictEqual(getPrototypeOf.name, 'getPrototypeOf', 'name is "getPrototypeOf"');
    assert.strictEqual(getPrototypeOf([]), Array.prototype);
    return assert.throws(function(){
      return getPrototypeOf(42);
    }, TypeError, 'throws on primitive');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, defineProperty, create, MODERN, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  defineProperty = Object.defineProperty, create = Object.create;
  MODERN = function(){
    try {
      return 2 === defineProperty({}, 'a', {
        get: function(){
          return 2;
        }
      }).a;
    } catch (e$) {}
  }();
  test('Reflect.get', function(assert){
    var get, target, receiver;
    get = Reflect.get;
    assert.ok(toString$.call(get).slice(8, -1) === 'Function', 'is function');
    assert.ok(/native code/.test(get), 'looks like native');
    assert.strictEqual(get.name, 'get', 'name is "get"');
    assert.strictEqual(get({
      qux: 987
    }, 'qux'), 987);
    if (MODERN) {
      target = create(defineProperty({
        z: 3
      }, 'w', {
        get: function(){
          return this;
        }
      }), {
        x: {
          value: 1
        },
        y: {
          get: function(){
            return this;
          }
        }
      });
      receiver = {};
      assert.strictEqual(get(target, 'x', receiver), 1, 'get x');
      assert.strictEqual(get(target, 'y', receiver), receiver, 'get y');
      assert.strictEqual(get(target, 'z', receiver), 3, 'get z');
      assert.strictEqual(get(target, 'w', receiver), receiver, 'get w');
      assert.strictEqual(get(target, 'u', receiver), void 8, 'get u');
    }
    return assert.throws(function(){
      return get(42, 'constructor');
    }, TypeError, 'throws on primitive');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('Reflect.has', function(assert){
    var has, O;
    has = Reflect.has;
    assert.ok(toString$.call(has).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(has.length, 2, 'arity is 2');
    assert.ok(/native code/.test(has), 'looks like native');
    assert.strictEqual(has.name, 'has', 'name is "has"');
    O = {
      qux: 987
    };
    assert.strictEqual(has(O, 'qux'), true);
    assert.strictEqual(has(O, 'qwe'), false);
    assert.strictEqual(has(O, 'toString'), true);
    return assert.throws(function(){
      return has(42, 'constructor');
    }, TypeError, 'throws on primitive');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, defineProperty, preventExtensions, MODERN, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  defineProperty = Object.defineProperty, preventExtensions = Object.preventExtensions;
  MODERN = function(){
    try {
      return 2 === defineProperty({}, 'a', {
        get: function(){
          return 2;
        }
      }).a;
    } catch (e$) {}
  }();
  test('Reflect.isExtensible', function(assert){
    var isExtensible;
    isExtensible = Reflect.isExtensible;
    assert.ok(toString$.call(isExtensible).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(isExtensible.length, 1, 'arity is 1');
    assert.ok(/native code/.test(isExtensible), 'looks like native');
    assert.strictEqual(isExtensible.name, 'isExtensible', 'name is "isExtensible"');
    assert.ok(isExtensible({}));
    if (MODERN) {
      assert.ok(!isExtensible(preventExtensions({})));
    }
    return assert.throws(function(){
      return isExtensible(42);
    }, TypeError, 'throws on primitive');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, defineProperty, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  defineProperty = Object.defineProperty;
  test('Reflect.ownKeys', function(assert){
    var ownKeys, sym, O1, keys, O2;
    ownKeys = Reflect.ownKeys;
    sym = Symbol('c');
    assert.ok(toString$.call(ownKeys).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(ownKeys.length, 1, 'arity is 1');
    assert.ok(/native code/.test(ownKeys), 'looks like native');
    assert.strictEqual(ownKeys.name, 'ownKeys', 'name is "ownKeys"');
    O1 = {
      a: 1
    };
    defineProperty(O1, 'b', {
      value: 2
    });
    O1[sym] = 3;
    keys = ownKeys(O1);
    assert.strictEqual(keys.length, 3, 'ownKeys return all own keys');
    assert.ok(in$('a', keys), 'ownKeys return all own keys: simple');
    assert.ok(in$('b', keys), 'ownKeys return all own keys: hidden');
    assert.strictEqual(O1[keys[2]], 3, 'ownKeys return all own keys: symbol');
    O2 = clone$(O1);
    keys = ownKeys(O2);
    assert.strictEqual(keys.length, 0, 'ownKeys return only own keys');
    return assert.throws(function(){
      return ownKeys(42);
    }, TypeError, 'throws on primitive');
  });
  function in$(x, xs){
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
  function clone$(it){
    function fun(){} fun.prototype = it;
    return new fun;
  }
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, defineProperty, isExtensible, MODERN, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  defineProperty = Object.defineProperty, isExtensible = Object.isExtensible;
  MODERN = function(){
    try {
      return 2 === defineProperty({}, 'a', {
        get: function(){
          return 2;
        }
      }).a;
    } catch (e$) {}
  }();
  test('Reflect.preventExtensions', function(assert){
    var preventExtensions, obj;
    preventExtensions = Reflect.preventExtensions;
    assert.ok(toString$.call(preventExtensions).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(preventExtensions.length, 1, 'arity is 1');
    assert.ok(/native code/.test(preventExtensions), 'looks like native');
    assert.strictEqual(preventExtensions.name, 'preventExtensions', 'name is "preventExtensions"');
    obj = {};
    assert.ok(preventExtensions(obj), true);
    if (MODERN) {
      assert.ok(!isExtensible(obj));
    }
    return assert.throws(function(){
      return preventExtensions(42);
    }, TypeError, 'throws on primitive');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  if (Object.setPrototypeOf || '__proto__' in {}) {
    module = QUnit.module, test = QUnit.test;
    module('ES6');
    test('Reflect.setPrototypeOf', function(assert){
      var setPrototypeOf, obj, o;
      setPrototypeOf = Reflect.setPrototypeOf;
      assert.ok(toString$.call(setPrototypeOf).slice(8, -1) === 'Function', 'is function');
      assert.ok(/native code/.test(setPrototypeOf), 'looks like native');
      assert.strictEqual(setPrototypeOf.name, 'setPrototypeOf', 'name is "setPrototypeOf"');
      obj = {};
      assert.ok(setPrototypeOf(obj, Array.prototype), true);
      assert.ok(obj instanceof Array);
      assert.throws(function(){
        return setPrototypeOf({}, 42);
      }, TypeError);
      assert.throws(function(){
        return setPrototypeOf(42, {});
      }, TypeError, 'throws on primitive');
      return assert.ok(setPrototypeOf(o = {}, o) === false, 'false on recursive __proto__');
    });
  }
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, defineProperty, getOwnPropertyDescriptor, create, MODERN, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  defineProperty = Object.defineProperty, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor, create = Object.create;
  MODERN = function(){
    try {
      return 2 === defineProperty({}, 'a', {
        get: function(){
          return 2;
        }
      }).a;
    } catch (e$) {}
  }();
  test('Reflect.set', function(assert){
    var set, obj, target, receiver, out;
    set = Reflect.set;
    assert.ok(toString$.call(set).slice(8, -1) === 'Function', 'is function');
    assert.ok(/native code/.test(set), 'looks like native');
    assert.strictEqual(set.name, 'set', 'name is "set"');
    obj = {};
    assert.ok(set(obj, 'quux', 654), true);
    assert.strictEqual(obj.quux, 654);
    target = {};
    receiver = {};
    set(target, 'foo', 1, receiver);
    assert.strictEqual(target.foo, void 8, 'target.foo === undefined');
    assert.strictEqual(receiver.foo, 1, 'receiver.foo === 1');
    if (MODERN) {
      defineProperty(receiver, 'bar', {
        value: 0,
        writable: true,
        enumerable: false,
        configurable: true
      });
      set(target, 'bar', 1, receiver);
      assert.strictEqual(receiver.bar, 1, 'receiver.bar === 1');
      assert.strictEqual(getOwnPropertyDescriptor(receiver, 'bar').enumerable, false, 'enumerability not overridden');
      target = create(defineProperty({
        z: 3
      }, 'w', {
        set: function(){
          out = this;
        }
      }), {
        x: {
          value: 1,
          writable: true,
          configurable: true
        },
        y: {
          set: function(){
            out = this;
          }
        },
        c: {
          value: 1,
          writable: false,
          configurable: false
        }
      });
      assert.strictEqual(set(target, 'x', 2, target), true, 'set x');
      assert.strictEqual(target.x, 2, 'set x');
      out = null;
      assert.strictEqual(set(target, 'y', 2, target), true, 'set y');
      assert.strictEqual(out, target, 'set y');
      assert.strictEqual(set(target, 'z', 4, target), true);
      assert.strictEqual(target.z, 4, 'set z');
      out = null;
      assert.strictEqual(set(target, 'w', 1, target), true, 'set w');
      assert.strictEqual(out, target, 'set w');
      assert.strictEqual(set(target, 'u', 0, target), true, 'set u');
      assert.strictEqual(target.u, 0, 'set u');
      assert.strictEqual(set(target, 'c', 2, target), false, 'set c');
      assert.strictEqual(target.c, 1, 'set c');
    }
    return assert.throws(function(){
      return set(42, 'q', 42);
    }, TypeError, 'throws on primitive');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  if (function(){
    try {
      return 2 === Object.defineProperty({}, 'a', {
        get: function(){
          return 2;
        }
      }).a;
    } catch (e$) {}
  }()) {
    test('RegExp constructor', function(assert){
      var re, O, i$, len$, index, val, results$ = [];
      assert.strictEqual(toString$.call(RegExp).slice(8, -1), 'Function', 'is function');
      assert.strictEqual(RegExp.length, 2, 'arity is 2');
      assert.ok(/native code/.test(RegExp), 'looks like native');
      assert.strictEqual(RegExp.name, 'RegExp', 'name is "RegExp"');
      assert.strictEqual(toString$.call(RegExp()).slice(8, -1), 'RegExp');
      assert.strictEqual(toString$.call(new RegExp()).slice(8, -1), 'RegExp');
      re = /a/g;
      assert.notStrictEqual(re, new RegExp(re), 'new RegExp(re) isnt re');
      assert.strictEqual(re, RegExp(re), 'RegExp(re) is re');
      re[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.match : void 8] = false;
      assert.notStrictEqual(re, RegExp(re), 'RegExp(re) isnt re, changed Symbol.match');
      O = {};
      assert.notStrictEqual(O, RegExp(O), 'RegExp(O) isnt O');
      O[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.match : void 8] = true;
      O.constructor = RegExp;
      assert.strictEqual(O, RegExp(O), 'RegExp(O) is O, changed Symbol.match');
      assert.strictEqual(String(re), '/a/g', 'b is /a/g');
      assert.strictEqual(String(new RegExp(/a/g, 'mi')), '/a/im', 'Allows a regex with flags');
      assert.ok(new RegExp(/a/g, 'im') instanceof RegExp, 'Works with instanceof');
      assert.strictEqual(new RegExp(/a/g, 'im').constructor, RegExp, 'Has the right constructor');
      /(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)(n)(o)(p)/.exec('abcdefghijklmnopq');
      for (i$ = 0, len$ = 'bcdefghij'.length; i$ < len$; ++i$) {
        index = i$;
        val = 'bcdefghij'[i$];
        results$.push(assert.strictEqual(RegExp["$" + (index + 1)], val, "Updates RegExp globals $" + (index + 1)));
      }
      return results$;
    });
  }
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  if (function(){
    try {
      return 2 === Object.defineProperty({}, 'a', {
        get: function(){
          return 2;
        }
      }).a;
    } catch (e$) {}
  }()) {
    test('RegExp#flags', function(assert){
      assert.strictEqual(/./g.flags, 'g', '/./g.flags is "g"');
      assert.strictEqual(/./.flags, '', '/./.flags is ""');
      assert.strictEqual(RegExp('.', 'gim').flags, 'gim', 'RegExp(".", "gim").flags is "gim"');
      assert.strictEqual(RegExp('.').flags, '', 'RegExp(".").flags is ""');
      assert.strictEqual(/./gim.flags, 'gim', '/./gim.flags is "gim"');
      assert.strictEqual(/./gmi.flags, 'gim', '/./gmi.flags is "gim"');
      assert.strictEqual(/./mig.flags, 'gim', '/./mig.flags is "gim"');
      return assert.strictEqual(/./mgi.flags, 'gim', '/./mgi.flags is "gim"');
    });
  }
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, global, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  global = Function('return this')();
  test('String#match regression', function(assert){
    var instance, matched, expected, obj, str, x, e, reg, string, matches, i$, len$, i, re, num;
    assert.ok(toString$.call(''.match).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(''.match.length, 1, 'arity is 1');
    assert.ok(/native code/.test(''.match), 'looks like native');
    assert.strictEqual(''.match.name, 'match', 'name is "match"');
    instance = Object(true);
    instance.match = String.prototype.match;
    assert.strictEqual(instance.match(true)[0], 'true', 'S15.5.4.10_A1_T1');
    instance = Object(false);
    instance.match = String.prototype.match;
    assert.strictEqual(instance.match(function(){
      return false;
    }())[0], 'false', 'S15.5.4.10_A1_T2');
    matched = ''.match();
    expected = RegExp().exec('');
    assert.strictEqual(matched.length, expected.length, 'S15.5.4.10_A1_T4 #1');
    assert.strictEqual(matched.index, expected.index, 'S15.5.4.10_A1_T4 #2');
    assert.strictEqual(matched.input, expected.input, 'S15.5.4.10_A1_T4 #3');
    assert.strictEqual('gnulluna'.match(null)[0], 'null', 'S15.5.4.10_A1_T5');
    matched = Object('undefined').match(x);
    expected = RegExp(x).exec('undefined');
    assert.strictEqual(matched.length, expected.length, 'S15.5.4.10_A1_T6 #1');
    assert.strictEqual(matched.index, expected.index, 'S15.5.4.10_A1_T6 #2');
    assert.strictEqual(matched.input, expected.input, 'S15.5.4.10_A1_T6 #3');
    matched = String('undefined').match(undefined);
    expected = RegExp(undefined).exec('undefined');
    assert.strictEqual(matched.length, expected.length, 'S15.5.4.10_A1_T7 #1');
    assert.strictEqual(matched.index, expected.index, 'S15.5.4.10_A1_T7 #2');
    assert.strictEqual(matched.input, expected.input, 'S15.5.4.10_A1_T7 #3');
    obj = {
      toString: function(){}
    };
    matched = String(obj).match(void 8);
    expected = RegExp(void 8).exec('undefined');
    assert.strictEqual(matched.length, expected.length, 'S15.5.4.10_A1_T8 #1');
    assert.strictEqual(matched.index, expected.index, 'S15.5.4.10_A1_T8 #2');
    assert.strictEqual(matched.input, expected.input, 'S15.5.4.10_A1_T8 #3');
    obj = {
      toString: function(){
        return '\u0041B';
      }
    };
    str = 'ABB\u0041BABAB';
    assert.strictEqual(str.match(obj)[0], 'AB', 'S15.5.4.10_A1_T10');
    obj = {
      toString: function(){
        throw 'intostr';
      }
    };
    str = 'ABB\u0041BABAB';
    try {
      x = str.match(obj);
      assert.ok(false, 'S15.5.4.10_A1_T11 #1 lead to throwing exception');
    } catch (e$) {
      e = e$;
      assert.strictEqual(e, 'intostr', 'S15.5.4.10_A1_T11 #1.1: Exception === "intostr". Actual: ' + e);
    }
    obj = {
      toString: function(){
        return {};
      },
      valueOf: function(){
        throw 'intostr';
      }
    };
    str = 'ABB\u0041BABAB';
    try {
      x = str.match(obj);
      assert.ok(false, 'S15.5.4.10_A1_T12 #1 lead to throwing exception');
    } catch (e$) {
      e = e$;
      assert.strictEqual(e, 'intostr', 'S15.5.4.10_A1_T12 #1.1: Exception === "intostr". Actual: ' + e);
    }
    obj = {
      toString: function(){
        return {};
      },
      valueOf: function(){
        return 1;
      }
    };
    assert.strictEqual('ABB\u0041B\u0031ABAB\u0031BBAA'.match(obj)[0], '1', 'S15.5.4.10_A1_T13 #1');
    assert.strictEqual('ABB\u0041B\u0031ABAB\u0031BBAA'.match(obj).length, 1, 'S15.5.4.10_A1_T13 #2');
    reg = RegExp('77');
    assert.strictEqual('ABB\u0041BABAB\u0037\u0037BBAA'.match(reg)[0], '77', 'S15.5.4.10_A1_T14');
    string = '1234567890';
    assert.strictEqual(string.match(3)[0], '3', 'S15.5.4.10_A2_T1 #1');
    assert.strictEqual(string.match(3).length, 1, 'S15.5.4.10_A2_T1 #2');
    assert.strictEqual(string.match(3).index, 2, 'S15.5.4.10_A2_T1 #3');
    assert.strictEqual(string.match(3).input, string, 'S15.5.4.10_A2_T1 #4');
    matches = ['34', '34', '34'];
    string = '343443444';
    assert.strictEqual(string.match(/34/g).length, 3, 'S15.5.4.10_A2_T2 #1');
    for (i$ = 0, len$ = matches.length; i$ < len$; ++i$) {
      i = matches[i$];
      assert.strictEqual(string.match(/34/g)[i], matches[i], "S15.5.4.10_A2_T2 #2");
    }
    matches = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0'];
    string = '123456abcde7890';
    assert.strictEqual(string.match(/\d{1}/g).length, 10, 'S15.5.4.10_A2_T3 #1');
    for (i$ = 0, len$ = matches.length; i$ < len$; ++i$) {
      i = matches[i$];
      assert.strictEqual(string.match(/\d{1}/g)[i], matches[i], "S15.5.4.10_A2_T3 #2");
    }
    matches = ['12', '34', '56', '78', '90'];
    string = '123456abcde7890';
    assert.strictEqual(string.match(/\d{2}/g).length, 5, 'S15.5.4.10_A2_T4 #1');
    for (i$ = 0, len$ = matches.length; i$ < len$; ++i$) {
      i = matches[i$];
      assert.strictEqual(string.match(/\d{2}/g)[i], matches[i], "S15.5.4.10_A2_T4 #2");
    }
    matches = ['ab', 'cd'];
    string = '123456abcde7890';
    assert.strictEqual(string.match(/\D{2}/g).length, 2, 'S15.5.4.10_A2_T5 #1');
    for (i$ = 0, len$ = matches.length; i$ < len$; ++i$) {
      i = matches[i$];
      assert.strictEqual(string.match(/\D{2}/g)[i], matches[i], "S15.5.4.10_A2_T5 #2");
    }
    string = "Boston, Mass. 02134";
    assert.strictEqual(string.match(/([\d]{5})([-\ ]?[\d]{4})?$/)[0], '02134', 'S15.5.4.10_A2_T6 #1');
    assert.strictEqual(string.match(/([\d]{5})([-\ ]?[\d]{4})?$/)[1], '02134', 'S15.5.4.10_A2_T6 #2');
    assert.strictEqual(string.match(/([\d]{5})([-\ ]?[\d]{4})?$/).length, 3, 'S15.5.4.10_A2_T6 #4');
    assert.strictEqual(string.match(/([\d]{5})([-\ ]?[\d]{4})?$/).index, 14, 'S15.5.4.10_A2_T6 #5');
    assert.strictEqual(string.match(/([\d]{5})([-\ ]?[\d]{4})?$/).input, string, 'S15.5.4.10_A2_T6 #6');
    string = "Boston, Mass. 02134";
    assert.strictEqual(string.match(/([\d]{5})([-\ ]?[\d]{4})?$/g).length, 1, 'S15.5.4.10_A2_T7 #1');
    assert.strictEqual(string.match(/([\d]{5})([-\ ]?[\d]{4})?$/g)[0], '02134', 'S15.5.4.10_A2_T7 #2');
    matches = ['02134', '02134', 'undefined'];
    string = "Boston, MA 02134";
    re = /([\d]{5})([-\ ]?[\d]{4})?$/;
    re.lastIndex = 0;
    assert.strictEqual(string.match(re).length, 3, 'S15.5.4.10_A2_T8 #1');
    assert.strictEqual(string.match(re).index, string.lastIndexOf('0'), 'S15.5.4.10_A2_T8 #2');
    for (i$ = 0, len$ = matches.length; i$ < len$; ++i$) {
      i = matches[i$];
      assert.strictEqual(string.match(re)[i], matches[i], "S15.5.4.10_A2_T8 #3");
    }
    string = "Boston, MA 02134";
    matches = ['02134', '02134', void 8];
    re = /([\d]{5})([-\ ]?[\d]{4})?$/;
    re.lastIndex = string.length;
    assert.strictEqual(string.match(re).length, 3, 'S15.5.4.10_A2_T9 #1');
    assert.strictEqual(string.match(re).index, string.lastIndexOf('0'), 'S15.5.4.10_A2_T9 #2');
    for (i$ = 0, len$ = matches.length; i$ < len$; ++i$) {
      i = matches[i$];
      assert.strictEqual(string.match(re)[i], matches[i], "S15.5.4.10_A2_T9 #3");
    }
    string = "Boston, MA 02134";
    matches = ['02134', '02134', void 8];
    re = /([\d]{5})([-\ ]?[\d]{4})?$/;
    re.lastIndex = string.lastIndexOf('0');
    assert.strictEqual(string.match(re).length, 3, 'S15.5.4.10_A2_T10 #1');
    assert.strictEqual(string.match(re).index, string.lastIndexOf('0'), 'S15.5.4.10_A2_T10 #2');
    for (i$ = 0, len$ = matches.length; i$ < len$; ++i$) {
      i = matches[i$];
      assert.strictEqual(string.match(re)[i], matches[i], "S15.5.4.10_A2_T10 #3");
    }
    string = "Boston, MA 02134";
    matches = ['02134', '02134', void 8];
    re = /([\d]{5})([-\ ]?[\d]{4})?$/;
    re.lastIndex = string.lastIndexOf('0') + 1;
    assert.strictEqual(string.match(re).length, 3, 'S15.5.4.10_A2_T11 #1');
    assert.strictEqual(string.match(re).index, string.lastIndexOf('0'), 'S15.5.4.10_A2_T11 #2');
    for (i$ = 0, len$ = matches.length; i$ < len$; ++i$) {
      i = matches[i$];
      assert.strictEqual(string.match(re)[i], matches[i], "S15.5.4.10_A2_T11 #3");
    }
    string = "Boston, MA 02134";
    re = /([\d]{5})([-\ ]?[\d]{4})?$/g;
    assert.strictEqual(string.match(re).length, 1, 'S15.5.4.10_A2_T12 #1');
    assert.strictEqual(string.match(re)[0], '02134', 'S15.5.4.10_A2_T12 #2');
    re = /([\d]{5})([-\ ]?[\d]{4})?$/g;
    re.lastIndex = 0;
    string = "Boston, MA 02134";
    assert.strictEqual(string.match(re).length, 1, 'S15.5.4.10_A2_T13 #1');
    assert.strictEqual(string.match(re)[0], '02134', 'S15.5.4.10_A2_T13 #2');
    string = "Boston, MA 02134";
    re = /([\d]{5})([-\ ]?[\d]{4})?$/g;
    re.lastIndex = string.length;
    assert.strictEqual(string.match(re).length, 1, 'S15.5.4.10_A2_T14 #1');
    assert.strictEqual(string.match(re)[0], '02134', 'S15.5.4.10_A2_T14 #2');
    string = "Boston, MA 02134";
    re = /([\d]{5})([-\ ]?[\d]{4})?$/g;
    re.lastIndex = string.lastIndexOf('0');
    assert.strictEqual(string.match(re).length, 1, 'S15.5.4.10_A2_T15 #1');
    assert.strictEqual(string.match(re)[0], '02134', 'S15.5.4.10_A2_T15 #2');
    string = "Boston, MA 02134";
    re = /([\d]{5})([-\ ]?[\d]{4})?$/g;
    re.lastIndex = string.lastIndexOf('0') + 1;
    assert.strictEqual(string.match(re).length, 1, 'S15.5.4.10_A2_T16 #1');
    assert.strictEqual(string.match(re)[0], '02134', 'S15.5.4.10_A2_T16 #2');
    re = /0./;
    num = 10203040506070809000;
    assert.strictEqual(''.match.call(num, re)[0], '02', 'S15.5.4.10_A2_T17 #1');
    assert.strictEqual(''.match.call(num, re).length, 1, 'S15.5.4.10_A2_T17 #2');
    assert.strictEqual(''.match.call(num, re).index, 1, 'S15.5.4.10_A2_T17 #3');
    assert.strictEqual(''.match.call(num, re).input, String(num), 'S15.5.4.10_A2_T17 #4');
    re = /0./;
    re.lastIndex = 0;
    num = 10203040506070809000;
    assert.strictEqual(''.match.call(num, re)[0], '02', 'S15.5.4.10_A2_T18 #1');
    assert.strictEqual(''.match.call(num, re).length, 1, 'S15.5.4.10_A2_T18 #2');
    assert.strictEqual(''.match.call(num, re).index, 1, 'S15.5.4.10_A2_T18 #3');
    return assert.strictEqual(''.match.call(num, re).input, String(num), 'S15.5.4.10_A2_T18 #4');
  });
  test('RegExp#@@match', function(assert){
    var string, matches, i$, len$, i, results$ = [];
    assert.ok(toString$.call(/./[Symbol.match]).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(/./[Symbol.match].length, 1, 'arity is 1');
    string = "Boston, MA 02134";
    matches = ['02134', '02134', void 8];
    assert.strictEqual(/([\d]{5})([-\ ]?[\d]{4})?$/[Symbol.match](string).length, 3);
    assert.strictEqual(/([\d]{5})([-\ ]?[\d]{4})?$/[Symbol.match](string).index, string.lastIndexOf('0'));
    for (i$ = 0, len$ = matches.length; i$ < len$; ++i$) {
      i = matches[i$];
      results$.push(assert.strictEqual(/([\d]{5})([-\ ]?[\d]{4})?$/[Symbol.match](string)[i], matches[i]));
    }
    return results$;
  });
  test('@@match logic', function(assert){
    'use strict';
    var strict, str, num, O, ref$, re;
    strict = !function(){
      return this;
    }();
    str = strict
      ? 'qwe'
      : Object('qwe');
    num = strict
      ? 123
      : Object(123);
    O = (ref$ = {}, ref$[Symbol.match] = function(it){
      return {
        value: it
      };
    }, ref$);
    assert.strictEqual(str.match(O).value, str);
    assert.strictEqual(''.match.call(num, O).value, num);
    re = /./;
    re[Symbol.match] = function(it){
      return {
        value: it
      };
    };
    assert.strictEqual(str.match(re).value, str);
    return assert.strictEqual(''.match.call(num, re).value, num);
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('String#replace regression', function(assert){
    var instance, e;
    assert.ok(toString$.call(''.replace).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(''.replace.length, 2, 'arity is 2');
    assert.ok(/native code/.test(''.replace), 'looks like native');
    assert.strictEqual(''.replace.name, 'replace', 'name is "replace"');
    instance = Object(true);
    instance.replace = String.prototype.replace;
    assert.strictEqual(instance.replace(true, 1), '1', 'S15.5.4.11_A1_T1');
    instance = Object(false);
    instance.replace = String.prototype.replace;
    assert.strictEqual(instance.replace(false, void 8), 'undefined', 'S15.5.4.11_A1_T2');
    assert.strictEqual('gnulluna'.replace(null, function(a1, a2, a3){
      return a2 + '';
    }), 'g1una', 'S15.5.4.11_A1_T4');
    assert.strictEqual('gnulluna'.replace(null, function(){}), 'gundefineduna', 'S15.5.4.11_A1_T5');
    assert.strictEqual(Object('undefined').replace(void 8, function(){
      return arguments[1] + 42;
    }), '42', 'S15.5.4.11_A1_T6');
    assert.strictEqual('undefined'.replace('e', void 8), 'undundefinedfined', 'S15.5.4.11_A1_T7');
    assert.strictEqual(String({
      toString: function(){}
    }).replace(/e/g, void 8), 'undundefinedfinundefinedd', 'S15.5.4.11_A1_T8');
    assert.strictEqual(new String({
      valueOf: function(){},
      toString: void 8
    }).replace(function(){}(), function(a1, a2, a3){
      return a1 + a2 + a3;
    }), 'undefined0undefined', 'S15.5.4.11_A1_T9');
    assert.strictEqual('ABB\u0041BABAB'.replace({
      toString: function(){
        return '\u0041B';
      }
    }, function(){}), 'undefinedBABABAB', 'S15.5.4.11_A1_T10');
    /* wrong order in some old environments
    try
      'ABB\u0041BABAB'replace {toString: -> throw \insearchValue}, {toString: -> throw \inreplaceValue}
      assert.ok no, 'S15.5.4.11_A1_T11 #1 lead to throwing exception'
    catch e
      assert.strictEqual e, \insearchValue, 'S15.5.4.11_A1_T11 #2'
    try
      Object('ABB\u0041BABAB')replace {toString: (->{}), valueOf: -> throw \insearchValue}, {toString: -> throw \inreplaceValue}
      assert.ok no, 'S15.5.4.11_A1_T12 #1 lead to throwing exception'
    catch e
      assert.strictEqual e, \insearchValue, 'S15.5.4.11_A1_T12 #2'
    */
    try {
      'ABB\u0041BABAB\u0031BBAA'.replace({
        toString: function(){
          return {};
        },
        valueOf: function(){
          throw 'insearchValue';
        }
      }, {
        toString: function(){
          return 1;
        }
      });
      assert.ok(false, 'S15.5.4.11_A1_T13 #1 lead to throwing exception');
    } catch (e$) {
      e = e$;
      assert.strictEqual(e, 'insearchValue', 'S15.5.4.11_A1_T13 #2');
    }
    assert.strictEqual('ABB\u0041BABAB\u0037\u0037BBAA'.replace(new RegExp('77'), 1), 'ABBABABAB\u0031BBAA', 'S15.5.4.11_A1_T14');
    instance = Object(1100.00777001);
    instance.replace = String.prototype.replace;
    try {
      instance.replace({
        toString: function(){
          return /77/;
        }
      }, 1);
      assert.ok(false, 'S15.5.4.11_A1_T15 #1 lead to throwing exception');
    } catch (e$) {
      e = e$;
      assert.ok(e instanceof TypeError, 'S15.5.4.11_A1_T15 #2');
    }
    instance = Object(1100.00777001);
    instance.replace = String.prototype.replace;
    try {
      instance.replace(/77/, {
        toString: function(){
          return function(a1, a2, a3){
            return a2 + 'z';
          };
        }
      });
      assert.ok(false, 'S15.5.4.11_A1_T16 #1 lead to throwing exception');
    } catch (e$) {
      e = e$;
      assert.ok(e instanceof TypeError, 'S15.5.4.11_A1_T16 #2');
    }
    assert.strictEqual('asdf'.replace(RegExp('', 'g'), '1'), '1a1s1d1f1', 'S15.5.4.11_A1_T17');
    assert.strictEqual('She sells seashells by the seashore.'.replace(/sh/g, 'sch'), 'She sells seaschells by the seaschore.', 'S15.5.4.11_A2_T1');
    assert.strictEqual('She sells seashells by the seashore.'.replace(/sh/g, '$$sch'), 'She sells sea$schells by the sea$schore.', 'S15.5.4.11_A2_T2');
    assert.strictEqual('She sells seashells by the seashore.'.replace(/sh/g, '$&sch'), 'She sells seashschells by the seashschore.', 'S15.5.4.11_A2_T3');
    assert.strictEqual('She sells seashells by the seashore.'.replace(/sh/g, '$`sch'), 'She sells seaShe sells seaschells by the seaShe sells seashells by the seaschore.', 'S15.5.4.11_A2_T4');
    assert.strictEqual('She sells seashells by the seashore.'.replace(/sh/g, "$'sch"), 'She sells seaells by the seashore.schells by the seaore.schore.', 'S15.5.4.11_A2_T5');
    assert.strictEqual('She sells seashells by the seashore.'.replace(/sh/, 'sch'), 'She sells seaschells by the seashore.', 'S15.5.4.11_A2_T6');
    assert.strictEqual('She sells seashells by the seashore.'.replace(/sh/, '$$sch'), 'She sells sea$schells by the seashore.', 'S15.5.4.11_A2_T7');
    assert.strictEqual('She sells seashells by the seashore.'.replace(/sh/, '$&sch'), 'She sells seashschells by the seashore.', 'S15.5.4.11_A2_T8');
    assert.strictEqual('She sells seashells by the seashore.'.replace(/sh/, '$`sch'), 'She sells seaShe sells seaschells by the seashore.', 'S15.5.4.11_A2_T9');
    assert.strictEqual('She sells seashells by the seashore.'.replace(/sh/, "$'sch"), 'She sells seaells by the seashore.schells by the seashore.', 'S15.5.4.11_A2_T10');
    assert.strictEqual('uid=31'.replace(/(uid=)(\d+)/, '$1115'), 'uid=115', 'S15.5.4.11_A3_T1');
    assert.strictEqual('uid=31'.replace(/(uid=)(\d+)/, '$11A15'), 'uid=1A15', 'S15.5.4.11_A3_T3');
    assert.strictEqual('abc12 def34'.replace(/([a-z]+)([0-9]+)/, function(){
      return arguments[2] + arguments[1];
    }), '12abc def34', 'S15.5.4.11_A4_T1');
    return assert.strictEqual('aaaaaaaaaa,aaaaaaaaaaaaaaa'.replace(/^(a+)\1*,\1+$/, '$1'), 'aaaaa', 'S15.5.4.11_A5_T1');
  });
  test('RegExp#@@replace', function(assert){
    assert.ok(toString$.call(/./[Symbol.replace]).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(/./[Symbol.replace].length, 2, 'arity is 2');
    return assert.strictEqual(/([a-z]+)([0-9]+)/[Symbol.replace]('abc12 def34', function(){
      return arguments[2] + arguments[1];
    }), '12abc def34');
  });
  test('@@replace logic', function(assert){
    'use strict';
    var strict, str, num, O, ref$, re;
    strict = !function(){
      return this;
    }();
    str = strict
      ? 'qwe'
      : Object('qwe');
    num = strict
      ? 123
      : Object(123);
    O = (ref$ = {}, ref$[Symbol.replace] = function(a, b){
      return {
        a: a,
        b: b
      };
    }, ref$);
    assert.strictEqual(str.replace(O, 42).a, str);
    assert.strictEqual(str.replace(O, 42).b, 42);
    assert.strictEqual(''.replace.call(num, O, 42).a, num);
    assert.strictEqual(''.replace.call(num, O, 42).b, 42);
    re = /./;
    re[Symbol.replace] = function(a, b){
      return {
        a: a,
        b: b
      };
    };
    assert.strictEqual(str.replace(re, 42).a, str);
    assert.strictEqual(str.replace(re, 42).b, 42);
    assert.strictEqual(''.replace.call(num, re, 42).a, num);
    return assert.strictEqual(''.replace.call(num, re, 42).b, 42);
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('String#search regression', function(assert){
    var instance, e, aString;
    assert.ok(toString$.call(''.search).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(''.search.length, 1, 'arity is 1');
    assert.ok(/native code/.test(''.search), 'looks like native');
    assert.strictEqual(''.search.name, 'search', 'name is "search"');
    instance = Object(true);
    instance.search = String.prototype.search;
    assert.strictEqual(instance.search(true), 0, 'S15.5.4.12_A1_T1');
    instance = Object(false);
    instance.search = String.prototype.search;
    assert.strictEqual(instance.search(false), 0, 'S15.5.4.12_A1_T2');
    assert.strictEqual(''.search(), 0, 'S15.5.4.12_A1_T4 #1');
    assert.strictEqual('--undefined--'.search(), 0, 'S15.5.4.12_A1_T4 #2');
    assert.strictEqual('gnulluna'.search(null), 1, 'S15.5.4.12_A1_T5');
    assert.strictEqual(Object('undefined').search(void 8), 0, 'S15.5.4.12_A1_T6');
    assert.strictEqual('undefined'.search(void 8), 0, 'S15.5.4.12_A1_T7');
    assert.strictEqual(String({
      toString: function(){}
    }).search(void 8), 0, 'S15.5.4.12_A1_T8');
    assert.strictEqual('ssABB\u0041BABAB'.search({
      toString: function(){
        return '\u0041B';
      }
    }), 2, 'S15.5.4.12_A1_T10');
    try {
      'ABB\u0041BABAB'.search({
        toString: function(){
          throw 'intostr';
        }
      });
      assert.ok(false, 'S15.5.4.12_A1_T11 #1 lead to throwing exception');
    } catch (e$) {
      e = e$;
      assert.strictEqual(e, 'intostr', 'S15.5.4.12_A1_T11 #2');
    }
    try {
      Object('ABB\u0041BABAB').search({
        toString: function(){
          return {};
        },
        valueOf: function(){
          throw 'intostr';
        }
      });
      assert.ok(false, 'S15.5.4.12_A1_T12 #1 lead to throwing exception');
    } catch (e$) {
      e = e$;
      assert.strictEqual(e, 'intostr', 'S15.5.4.12_A1_T12 #2');
    }
    assert.strictEqual('ABB\u0041B\u0031ABAB\u0031BBAA'.search({
      toString: function(){
        return {};
      },
      valueOf: function(){
        return 1;
      }
    }), 5, 'S15.5.4.12_A1_T13');
    assert.strictEqual('ABB\u0041BABAB\u0037\u0037BBAA'.search(RegExp('77')), 9, 'S15.5.4.12_A1_T14');
    assert.strictEqual(Object('test string').search('string'), 5, 'S15.5.4.12_A2_T1');
    assert.strictEqual(Object('test string').search('String'), -1, 'S15.5.4.12_A2_T2');
    assert.strictEqual(Object('test string').search(/String/i), 5, 'S15.5.4.12_A2_T3');
    assert.strictEqual(Object('test string').search(/Four/), -1, 'S15.5.4.12_A2_T4');
    assert.strictEqual(Object('one two three four five').search(/four/), 14, 'S15.5.4.12_A2_T5');
    assert.strictEqual(Object('test string').search('notexist'), -1, 'S15.5.4.12_A2_T6');
    assert.strictEqual(Object('test string probe').search('string pro'), 5, 'S15.5.4.12_A2_T7');
    aString = Object('power of the power of the power of the power of the power of the power of the great sword');
    assert.strictEqual(aString.search(/the/), aString.search(/the/g), 'S15.5.4.12_A3_T1');
    aString = Object('power \u006F\u0066 the power of the power \u006F\u0066 the power of the power \u006F\u0066 the power of the great sword');
    return assert.strictEqual(aString.search(/of/), aString.search(/of/g), 'S15.5.4.12_A3_T2');
  });
  test('RegExp#@@search', function(assert){
    assert.ok(toString$.call(/./[Symbol.search]).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(/./[Symbol.search].length, 1, 'arity is 1');
    assert.strictEqual(/four/[Symbol.search]('one two three four five'), 14);
    return assert.strictEqual(/Four/[Symbol.search]('one two three four five'), -1);
  });
  test('@@search logic', function(assert){
    'use strict';
    var strict, str, num, O, ref$, re;
    strict = !function(){
      return this;
    }();
    str = strict
      ? 'qwe'
      : Object('qwe');
    num = strict
      ? 123
      : Object(123);
    O = (ref$ = {}, ref$[Symbol.search] = function(it){
      return {
        value: it
      };
    }, ref$);
    assert.strictEqual(str.search(O).value, str);
    assert.strictEqual(''.search.call(num, O).value, num);
    re = /./;
    re[Symbol.search] = function(it){
      return {
        value: it
      };
    };
    assert.strictEqual(str.search(re).value, str);
    return assert.strictEqual(''.search.call(num, re).value, num);
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('String#split regression', function(assert){
    var instance, split, e, string, i$, to$, i, expected, results$ = [];
    assert.ok(toString$.call(''.split).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(''.split.length, 2, 'arity is 2');
    assert.ok(/native code/.test(''.split), 'looks like native');
    assert.strictEqual(''.split.name, 'split', 'name is "split"');
    instance = Object(true);
    instance.split = String.prototype.split;
    split = instance.split(true, false);
    assert.strictEqual(typeof split, 'object', 'S15.5.4.14_A1_T1 #1');
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A1_T1 #2');
    assert.strictEqual(split.length, 0, 'S15.5.4.14_A1_T1 #3');
    instance = Object(false);
    instance.split = String.prototype.split;
    split = instance.split(false, 0, null);
    assert.strictEqual(typeof split, 'object', 'S15.5.4.14_A1_T2 #1');
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A1_T2 #2');
    assert.strictEqual(split.length, 0, 'S15.5.4.14_A1_T2 #3');
    split = ''.split();
    assert.strictEqual(typeof split, 'object', 'S15.5.4.14_A1_T4 #1');
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A1_T4 #2');
    assert.strictEqual(split.length, 1, 'S15.5.4.14_A1_T4 #3');
    assert.strictEqual(split[0], '', 'S15.5.4.14_A1_T4 #4');
    split = 'gnulluna'.split(null);
    assert.strictEqual(typeof split, 'object', 'S15.5.4.14_A1_T5 #1');
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A1_T5 #2');
    assert.strictEqual(split.length, 2, 'S15.5.4.14_A1_T5 #3');
    assert.strictEqual(split[0], 'g', 'S15.5.4.14_A1_T5 #4');
    assert.strictEqual(split[1], 'una', 'S15.5.4.14_A1_T5 #5');
    /* wrong behavior in some old browsers
    split = Object(\1undefined)split void
    assert.strictEqual typeof split, \object, 'S15.5.4.14_A1_T6 #1'
    assert.strictEqual split@@, Array, 'S15.5.4.14_A1_T6 #2'
    assert.strictEqual split.length, 1, 'S15.5.4.14_A1_T6 #3'
    assert.strictEqual split.0, \1undefined, 'S15.5.4.14_A1_T6 #4'
    split = 'undefinedd'split void
    assert.strictEqual typeof split, \object, 'S15.5.4.14_A1_T7 #1'
    assert.strictEqual split@@, Array, 'S15.5.4.14_A1_T7 #2'
    assert.strictEqual split.length, 1, 'S15.5.4.14_A1_T7 #3'
    assert.strictEqual split.0, \undefinedd, 'S15.5.4.14_A1_T7 #4'
    split = String({toString: ->})split void
    assert.strictEqual typeof split, \object, 'S15.5.4.14_A1_T8 #1'
    assert.strictEqual split@@, Array, 'S15.5.4.14_A1_T8 #2'
    assert.strictEqual split.length, 1, 'S15.5.4.14_A1_T8 #3'
    assert.strictEqual split.0, \undefined, 'S15.5.4.14_A1_T8 #4'
    */
    split = new String({
      valueOf: function(){},
      toString: void 8
    }).split(function(){});
    assert.strictEqual(typeof split, 'object', 'S15.5.4.14_A1_T9 #1');
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A1_T9 #2');
    assert.strictEqual(split.length, 1, 'S15.5.4.14_A1_T9 #3');
    assert.strictEqual(split[0], 'undefined', 'S15.5.4.14_A1_T9 #4');
    split = 'ABB\u0041BABAB'.split({
      toString: function(){
        return '\u0042B';
      }
    }, {
      valueOf: function(){
        return true;
      }
    });
    assert.strictEqual(typeof split, 'object', 'S15.5.4.14_A1_T10 #1');
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A1_T10 #2');
    assert.strictEqual(split.length, 1, 'S15.5.4.14_A1_T10 #3');
    assert.strictEqual(split[0], 'A', 'S15.5.4.14_A1_T10 #4');
    try {
      'ABB\u0041BABAB'.split({
        toString: function(){
          return '\u0041B';
        }
      }, {
        valueOf: (function(){
          throw 'intointeger';
        }())
      });
      assert.ok(false, 'S15.5.4.14_A1_T11 #1 lead to throwing exception');
    } catch (e$) {
      e = e$;
      assert.strictEqual(e, 'intointeger', 'S15.5.4.14_A1_T11 #2');
    }
    /* wrong behavior in old IE
    try
      new String('ABB\u0041BABAB')split {toString: -> '\u0041B'}, {valueOf: (-> {}), toString: -> throw \intointeger}
      assert.ok no, 'S15.5.4.14_A1_T12 #1 lead to throwing exception'
    catch e
      assert.strictEqual e, \intointeger, 'S15.5.4.14_A1_T12 #2'
    */
    split = 'ABB\u0041BABAB\u0042cc^^\u0042Bvv%%B\u0042xxx'.split({
      toString: function(){
        return '\u0042\u0042';
      }
    }, {
      valueOf: function(){
        return {};
      },
      toString: function(){
        return '2';
      }
    });
    assert.strictEqual(typeof split, 'object', 'S15.5.4.14_A1_T13 #1');
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A1_T13 #2');
    assert.strictEqual(split.length, 2, 'S15.5.4.14_A1_T13 #3');
    assert.strictEqual(split[0], 'A', 'S15.5.4.14_A1_T13 #4');
    assert.strictEqual(split[1], 'ABABA', 'S15.5.4.14_A1_T13 #5');
    /* wrong behavior in old IE
    try
      instance = Object 10001.10001
      instance.split = String::split
      instance.split {toString: -> throw \intostr}, {valueOf: -> throw \intoint}
      assert.ok no, 'S15.5.4.14_A1_T14 #1 lead to throwing exception'
    catch e
      assert.strictEqual e, \intoint, 'S15.5.4.14_A1_T14 #2'
    try
      class F
        costructor: (@value)->
        valueOf: -> ''+@value
        toString: -> new Number
        split: String::split
      new F!split {toString: (-> {}), valueOf: -> throw \intostr}, {valueOf: -> throw \intoint}
      assert.ok no, 'S15.5.4.14_A1_T15 #1 lead to throwing exception'
    catch e
      assert.strictEqual e, \intoint, 'S15.5.4.14_A1_T15 #2'
    */
    try {
      String.prototype.split.call(6776767677.006771122677555, {
        toString: function(){
          return /\u0037\u0037/g;
        }
      });
      assert.ok(false, 'S15.5.4.14_A1_T16 #1 lead to throwing exception');
    } catch (e$) {
      e = e$;
      assert.ok(e instanceof TypeError, 'S15.5.4.14_A1_T16 #2');
    }
    split = String.prototype.split.call(6776767677.006771122677555, /\u0037\u0037/g);
    assert.strictEqual(typeof split, 'object', 'S15.5.4.14_A1_T17 #1');
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A1_T17 #2');
    assert.strictEqual(split.length, 4, 'S15.5.4.14_A1_T17 #3');
    assert.strictEqual(split[0], '6', 'S15.5.4.14_A1_T17 #4');
    assert.strictEqual(split[1], '67676', 'S15.5.4.14_A1_T17 #5');
    assert.strictEqual(split[2], '.006', 'S15.5.4.14_A1_T17 #6');
    assert.strictEqual(split[3], '1', 'S15.5.4.14_A1_T17 #7');
    split = String.prototype.split.call(6776767677.006771122677555, /00/, 1);
    assert.strictEqual(typeof split, 'object', 'S15.5.4.14_A1_T18 #1');
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A1_T18 #2');
    assert.strictEqual(split.length, 1, 'S15.5.4.14_A1_T18 #3');
    assert.strictEqual(split[0], '6776767677.', 'S15.5.4.14_A1_T18 #4');
    split = Object('one,two,three,four,five').split(',');
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A2_T1 #1');
    assert.strictEqual(split.length, 5, 'S15.5.4.14_A2_T1 #2');
    assert.strictEqual(split[0], 'one', 'S15.5.4.14_A2_T1 #3');
    assert.strictEqual(split[1], 'two', 'S15.5.4.14_A2_T1 #4');
    assert.strictEqual(split[2], 'three', 'S15.5.4.14_A2_T1 #5');
    assert.strictEqual(split[3], 'four', 'S15.5.4.14_A2_T1 #6');
    assert.strictEqual(split[4], 'five', 'S15.5.4.14_A2_T1 #7');
    split = Object('one two three four five').split(' ');
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A2_T2 #1');
    assert.strictEqual(split.length, 5, 'S15.5.4.14_A2_T2 #2');
    assert.strictEqual(split[0], 'one', 'S15.5.4.14_A2_T2 #3');
    assert.strictEqual(split[1], 'two', 'S15.5.4.14_A2_T2 #4');
    assert.strictEqual(split[2], 'three', 'S15.5.4.14_A2_T2 #5');
    assert.strictEqual(split[3], 'four', 'S15.5.4.14_A2_T2 #6');
    assert.strictEqual(split[4], 'five', 'S15.5.4.14_A2_T2 #7');
    split = Object('one two three four five').split(RegExp(' '), 2);
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A2_T3 #1');
    assert.strictEqual(split.length, 2, 'S15.5.4.14_A2_T3 #2');
    assert.strictEqual(split[0], 'one', 'S15.5.4.14_A2_T3 #3');
    assert.strictEqual(split[1], 'two', 'S15.5.4.14_A2_T3 #4');
    split = Object('one two three').split('');
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A2_T4 #1');
    assert.strictEqual(split.length, 'one two three'.length, 'S15.5.4.14_A2_T4 #2');
    assert.strictEqual(split[0], 'o', 'S15.5.4.14_A2_T4 #3');
    assert.strictEqual(split[1], 'n', 'S15.5.4.14_A2_T4 #4');
    assert.strictEqual(split[11], 'e', 'S15.5.4.14_A2_T4 #5');
    assert.strictEqual(split[12], 'e', 'S15.5.4.14_A2_T4 #6');
    split = Object('one-1,two-2,four-4').split(/,/);
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A2_T5 #1');
    assert.strictEqual(split.length, 3, 'S15.5.4.14_A2_T5 #2');
    assert.strictEqual(split[0], 'one-1', 'S15.5.4.14_A2_T5 #3');
    assert.strictEqual(split[1], 'two-2', 'S15.5.4.14_A2_T5 #4');
    assert.strictEqual(split[2], 'four-4', 'S15.5.4.14_A2_T5 #5');
    string = Object('one-1 two-2 three-3');
    split = string.split('');
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A2_T6 #1');
    assert.strictEqual(split.length, string.length, 'S15.5.4.14_A2_T6 #2');
    for (i$ = 0, to$ = split.length; i$ < to$; ++i$) {
      i = i$;
      assert.strictEqual(split[i], string.charAt(i), "S15.5.4.14_A2_T6 #" + (i + 3));
    }
    /* wrong behavior in some old browsers
    string = 'thisundefinedisundefinedaundefinedstringundefinedobject'
    split = string.split void
    assert.strictEqual split@@, Array, 'S15.5.4.14_A2_T7 #1'
    assert.strictEqual split.length, 1, 'S15.5.4.14_A2_T7 #2'
    assert.strictEqual split.0, string, 'S15.5.4.14_A2_T7 #3'
    */
    string = 'thisnullisnullanullstringnullobject';
    expected = ['this', 'is', 'a', 'string', 'object'];
    split = string.split(null);
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A2_T8 #1');
    assert.strictEqual(split.length, expected.length, 'S15.5.4.14_A2_T8 #2');
    for (i$ = 0, to$ = expected.length; i$ < to$; ++i$) {
      i = i$;
      assert.strictEqual(expected[i], split[i], "S15.5.4.14_A2_T8 #" + (i + 3));
    }
    string = 'thistrueistrueatruestringtrueobject';
    expected = ['this', 'is', 'a', 'string', 'object'];
    split = string.split(true);
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A2_T9 #1');
    assert.strictEqual(split.length, expected.length, 'S15.5.4.14_A2_T9 #2');
    for (i$ = 0, to$ = expected.length; i$ < to$; ++i$) {
      i = i$;
      assert.strictEqual(expected[i], split[i], "S15.5.4.14_A2_T9 #" + (i + 3));
    }
    string = 'this123is123a123string123object';
    expected = ['this', 'is', 'a', 'string', 'object'];
    split = string.split(123);
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A2_T10 #1');
    assert.strictEqual(split.length, expected.length, 'S15.5.4.14_A2_T10 #2');
    for (i$ = 0, to$ = expected.length; i$ < to$; ++i$) {
      i = i$;
      assert.strictEqual(expected[i], split[i], "S15.5.4.14_A2_T10 #" + (i + 3));
    }
    split = Object('one-1,two-2,four-4').split(':');
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A2_T11 #1');
    assert.strictEqual(split.length, 1, 'S15.5.4.14_A2_T11 #2');
    assert.strictEqual(split[0], 'one-1,two-2,four-4', 'S15.5.4.14_A2_T11 #3');
    split = Object('one-1 two-2 four-4').split('r-42');
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A2_T12 #1');
    assert.strictEqual(split.length, 1, 'S15.5.4.14_A2_T12 #2');
    assert.strictEqual(split[0], 'one-1 two-2 four-4', 'S15.5.4.14_A2_T12 #3');
    split = Object('one-1 two-2 four-4').split('-4');
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A2_T13 #1');
    assert.strictEqual(split.length, 2, 'S15.5.4.14_A2_T13 #2');
    assert.strictEqual(split[0], 'one-1 two-2 four', 'S15.5.4.14_A2_T13 #3');
    assert.strictEqual(split[1], '', 'S15.5.4.14_A2_T13 #4');
    split = Object('one-1 two-2 four-4').split('on');
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A2_T14 #1');
    assert.strictEqual(split.length, 2, 'S15.5.4.14_A2_T14 #2');
    assert.strictEqual(split[0], '', 'S15.5.4.14_A2_T14 #3');
    assert.strictEqual(split[1], 'e-1 two-2 four-4', 'S15.5.4.14_A2_T14 #4');
    split = new String().split('');
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A2_T15 #1');
    assert.strictEqual(split.length, 0, 'S15.5.4.14_A2_T15 #2');
    assert.strictEqual(split[0], void 8, 'S15.5.4.14_A2_T15 #3');
    split = new String().split(' ');
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A2_T16 #1');
    assert.strictEqual(split.length, 1, 'S15.5.4.14_A2_T16 #2');
    assert.strictEqual(split[0], '', 'S15.5.4.14_A2_T16 #3');
    split = Object(' ').split('');
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A2_T18 #1');
    assert.strictEqual(split.length, 1, 'S15.5.4.14_A2_T18 #2');
    assert.strictEqual(split[0], ' ', 'S15.5.4.14_A2_T18 #3');
    split = Object(' ').split(' ');
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A2_T19 #1');
    assert.strictEqual(split.length, 2, 'S15.5.4.14_A2_T19 #2');
    assert.strictEqual(split[0], '', 'S15.5.4.14_A2_T19 #3');
    assert.strictEqual(split[1], '', 'S15.5.4.14_A2_T19 #4');
    split = ''.split('x');
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A2_T19 #1');
    assert.strictEqual(split.length, 1, 'S15.5.4.14_A2_T19 #2');
    assert.strictEqual(split[0], '', 'S15.5.4.14_A2_T19 #3');
    string = Object('one-1 two-2 three-3');
    split = string.split(new RegExp);
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A2_T20 #1');
    assert.strictEqual(split.length, string.length, 'S15.5.4.14_A2_T20 #2');
    for (i$ = 0, to$ = split.length; i$ < to$; ++i$) {
      i = i$;
      assert.strictEqual(split[i], string.charAt(i), "S15.5.4.14_A2_T20 #" + (i + 3));
    }
    split = Object('hello').split('ll');
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A2_T21 #1');
    assert.strictEqual(split.length, 2, 'S15.5.4.14_A2_T21 #2');
    assert.strictEqual(split[0], 'he', 'S15.5.4.14_A2_T21 #3');
    assert.strictEqual(split[1], 'o', 'S15.5.4.14_A2_T21 #4');
    split = Object('hello').split('l');
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A2_T22 #1');
    assert.strictEqual(split.length, 3, 'S15.5.4.14_A2_T22 #2');
    assert.strictEqual(split[0], 'he', 'S15.5.4.14_A2_T22 #3');
    assert.strictEqual(split[1], '', 'S15.5.4.14_A2_T22 #4');
    assert.strictEqual(split[2], 'o', 'S15.5.4.14_A2_T22 #5');
    split = Object('hello').split('x');
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A2_T23 #1');
    assert.strictEqual(split.length, 1, 'S15.5.4.14_A2_T23 #2');
    assert.strictEqual(split[0], 'hello', 'S15.5.4.14_A2_T23 #3');
    split = Object('hello').split('h');
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A2_T24 #1');
    assert.strictEqual(split.length, 2, 'S15.5.4.14_A2_T24 #2');
    assert.strictEqual(split[0], '', 'S15.5.4.14_A2_T24 #3');
    assert.strictEqual(split[1], 'ello', 'S15.5.4.14_A2_T24 #4');
    split = Object('hello').split('o');
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A2_T25 #1');
    assert.strictEqual(split.length, 2, 'S15.5.4.14_A2_T25 #2');
    assert.strictEqual(split[0], 'hell', 'S15.5.4.14_A2_T25 #3');
    assert.strictEqual(split[1], '', 'S15.5.4.14_A2_T25 #4');
    split = Object('hello').split('hello');
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A2_T26 #1');
    assert.strictEqual(split.length, 2, 'S15.5.4.14_A2_T26 #2');
    assert.strictEqual(split[0], '', 'S15.5.4.14_A2_T26 #3');
    assert.strictEqual(split[1], '', 'S15.5.4.14_A2_T26 #4');
    split = Object('hello').split(void 8);
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A2_T27 #1');
    assert.strictEqual(split.length, 1, 'S15.5.4.14_A2_T27 #2');
    assert.strictEqual(split[0], 'hello', 'S15.5.4.14_A2_T27 #3');
    split = Object('hello').split('hellothere');
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A2_T28 #1');
    assert.strictEqual(split.length, 1, 'S15.5.4.14_A2_T28 #2');
    assert.strictEqual(split[0], 'hello', 'S15.5.4.14_A2_T28 #3');
    instance = Object(100111122133144155);
    instance.split = String.prototype.split;
    split = instance.split(1);
    expected = ['', '00', '', '', '', '22', '33', '44', '60'];
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A2_T29 #1');
    assert.strictEqual(split.length, expected.length, 'S15.5.4.14_A2_T29 #2');
    for (i$ = 0, to$ = expected.length; i$ < to$; ++i$) {
      i = i$;
      assert.strictEqual(expected[i], split[i], "S15.5.4.14_A2_T29 #" + (i + 3));
    }
    instance = Object(100111122133144155);
    instance.split = String.prototype.split;
    split = instance.split(1, 1);
    expected = [''];
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A2_T30 #1');
    assert.strictEqual(split.length, expected.length, 'S15.5.4.14_A2_T30 #2');
    for (i$ = 0, to$ = expected.length; i$ < to$; ++i$) {
      i = i$;
      assert.strictEqual(expected[i], split[i], "S15.5.4.14_A2_T30 #" + (i + 3));
    }
    instance = Object(100111122133144155);
    instance.split = String.prototype.split;
    split = instance.split(1, 2);
    expected = ['', '00'];
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A2_T31 #1');
    assert.strictEqual(split.length, expected.length, 'S15.5.4.14_A2_T31 #2');
    for (i$ = 0, to$ = expected.length; i$ < to$; ++i$) {
      i = i$;
      assert.strictEqual(expected[i], split[i], "S15.5.4.14_A2_T31 #" + (i + 3));
    }
    instance = Object(100111122133144155);
    instance.split = String.prototype.split;
    split = instance.split(1, 0);
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A2_T32 #1');
    assert.strictEqual(split.length, 0, 'S15.5.4.14_A2_T32 #2');
    instance = Object(100111122133144155);
    instance.split = String.prototype.split;
    split = instance.split(1, 100);
    expected = ['', '00', '', '', '', '22', '33', '44', '60'];
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A2_T33 #1');
    assert.strictEqual(split.length, expected.length, 'S15.5.4.14_A2_T33 #2');
    for (i$ = 0, to$ = expected.length; i$ < to$; ++i$) {
      i = i$;
      assert.strictEqual(expected[i], split[i], "S15.5.4.14_A2_T33 #" + (i + 3));
    }
    instance = Object(100111122133144155);
    instance.split = String.prototype.split;
    split = instance.split(1, void 8);
    expected = ['', '00', '', '', '', '22', '33', '44', '60'];
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A2_T34 #1');
    assert.strictEqual(split.length, expected.length, 'S15.5.4.14_A2_T34 #2');
    for (i$ = 0, to$ = expected.length; i$ < to$; ++i$) {
      i = i$;
      assert.strictEqual(expected[i], split[i], "S15.5.4.14_A2_T34 #" + (i + 3));
    }
    instance = Object(100111122133144155);
    instance.split = String.prototype.split;
    split = instance.split(1, Math.pow(2, 32) - 1);
    expected = ['', '00', '', '', '', '22', '33', '44', '60'];
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A2_T35 #1');
    assert.strictEqual(split.length, expected.length, 'S15.5.4.14_A2_T35 #2');
    for (i$ = 0, to$ = expected.length; i$ < to$; ++i$) {
      i = i$;
      assert.strictEqual(expected[i], split[i], "S15.5.4.14_A2_T35 #" + (i + 3));
    }
    instance = Object(100111122133144155);
    instance.split = String.prototype.split;
    split = instance.split(1, 'boo');
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A2_T36 #1');
    assert.strictEqual(split.length, 0, 'S15.5.4.14_A2_T36 #2');
    /* wrong behavior in most browsers
    instance = Object 100111122133144155
    instance.split = String::split
    split = instance.split 1, -Math.pow(2 32) + 1
    assert.strictEqual split@@, Array, 'S15.5.4.14_A2_T37 #1'
    assert.strictEqual split.length, 0, 'S15.5.4.14_A2_T37 #2'
    */
    instance = Object(100111122133144155);
    instance.split = String.prototype.split;
    split = instance.split(1, NaN);
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A2_T38 #1');
    assert.strictEqual(split.length, 0, 'S15.5.4.14_A2_T38 #2');
    instance = Object('hello').split('l', 0);
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A2_T39 #1');
    assert.strictEqual(split.length, 0, 'S15.5.4.14_A2_T39 #2');
    split = Object('hello').split('l', 1);
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A2_T40 #1');
    assert.strictEqual(split.length, 1, 'S15.5.4.14_A2_T40 #2');
    assert.strictEqual(split[0], 'he', 'S15.5.4.14_A2_T40 #3');
    split = Object('hello').split('l', 2);
    expected = ['he', ''];
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A2_T41 #1');
    assert.strictEqual(split.length, expected.length, 'S15.5.4.14_A2_T41 #2');
    for (i$ = 0, to$ = expected.length; i$ < to$; ++i$) {
      i = i$;
      assert.strictEqual(expected[i], split[i], "S15.5.4.14_A2_T41 #" + (i + 3));
    }
    split = Object('hello').split('l', 3);
    expected = ['he', '', 'o'];
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A2_T42 #1');
    assert.strictEqual(split.length, expected.length, 'S15.5.4.14_A2_T42 #2');
    for (i$ = 0, to$ = expected.length; i$ < to$; ++i$) {
      i = i$;
      assert.strictEqual(expected[i], split[i], "S15.5.4.14_A2_T42 #" + (i + 3));
    }
    split = Object('hello').split('l', 4);
    expected = ['he', '', 'o'];
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A2_T43 #1');
    assert.strictEqual(split.length, expected.length, 'S15.5.4.14_A2_T43 #2');
    for (i$ = 0, to$ = expected.length; i$ < to$; ++i$) {
      i = i$;
      assert.strictEqual(expected[i], split[i], "S15.5.4.14_A2_T43 #" + (i + 3));
    }
    split = Object('one,two,three,four,five').split();
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A3_T1 #1');
    assert.strictEqual(split.length, 1, 'S15.5.4.14_A3_T1 #2');
    assert.strictEqual(split[0], 'one,two,three,four,five', 'S15.5.4.14_A3_T1 #3');
    split = String.prototype.split.call({});
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A3_T2 #1');
    assert.strictEqual(split.length, 1, 'S15.5.4.14_A3_T2 #2');
    assert.strictEqual(split[0], '[object Object]', 'S15.5.4.14_A3_T2 #3');
    split = String.prototype.split.call({
      toString: function(){
        return 'function(){}';
      }
    });
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A3_T3 #1');
    assert.strictEqual(split.length, 1, 'S15.5.4.14_A3_T3 #2');
    assert.strictEqual(split[0], 'function(){}', 'S15.5.4.14_A3_T3 #3');
    split = String.prototype.split.call(Object(NaN));
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A3_T4 #1');
    assert.strictEqual(split.length, 1, 'S15.5.4.14_A3_T4 #2');
    assert.strictEqual(split[0], 'NaN', 'S15.5.4.14_A3_T4 #3');
    split = String.prototype.split.call(Object(-1234567890));
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A3_T5 #1');
    assert.strictEqual(split.length, 1, 'S15.5.4.14_A3_T5 #2');
    assert.strictEqual(split[0], '-1234567890', 'S15.5.4.14_A3_T5 #3');
    instance = Object(-1e21);
    split = String.prototype.split.call(instance);
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A3_T6 #1');
    assert.strictEqual(split.length, 1, 'S15.5.4.14_A3_T6 #2');
    assert.strictEqual(split[0], instance.toString(), 'S15.5.4.14_A3_T6 #3');
    split = String.prototype.split.call(Math);
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A3_T7 #1');
    assert.strictEqual(split.length, 1, 'S15.5.4.14_A3_T7 #2');
    assert.strictEqual(split[0], '[object Math]', 'S15.5.4.14_A3_T7 #3');
    split = String.prototype.split.call([1, 2, 3, 4, 5]);
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A3_T8 #1');
    assert.strictEqual(split.length, 1, 'S15.5.4.14_A3_T8 #2');
    assert.strictEqual(split[0], '1,2,3,4,5', 'S15.5.4.14_A3_T8 #3');
    split = String.prototype.split.call(Object(false));
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A3_T9 #1');
    assert.strictEqual(split.length, 1, 'S15.5.4.14_A3_T9 #2');
    assert.strictEqual(split[0], 'false', 'S15.5.4.14_A3_T9 #3');
    split = String.prototype.split.call(new String);
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A3_T10 #1');
    assert.strictEqual(split.length, 1, 'S15.5.4.14_A3_T10 #2');
    assert.strictEqual(split[0], '', 'S15.5.4.14_A3_T10 #3');
    split = String.prototype.split.call(Object(' '));
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A3_T11 #1');
    assert.strictEqual(split.length, 1, 'S15.5.4.14_A3_T11 #2');
    assert.strictEqual(split[0], ' ', 'S15.5.4.14_A3_T11 #3');
    /* wrong behavior in old IE
    split = Object(\hello)split /l/
    assert.strictEqual split@@, Array, 'S15.5.4.14_A4_T1 #1'
    assert.strictEqual split.length, 3, 'S15.5.4.14_A4_T1 #2'
    assert.strictEqual split.0, 'he', 'S15.5.4.14_A4_T1 #3'
    assert.strictEqual split.1, '', 'S15.5.4.14_A4_T1 #4'
    assert.strictEqual split.2, 'o', 'S15.5.4.14_A4_T1 #5'
    */
    split = Object('hello').split(/l/, 0);
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A4_T2 #1');
    assert.strictEqual(split.length, 0, 'S15.5.4.14_A4_T2 #2');
    split = Object('hello').split(/l/, 1);
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A4_T3 #1');
    assert.strictEqual(split.length, 1, 'S15.5.4.14_A4_T3 #2');
    assert.strictEqual(split[0], 'he', 'S15.5.4.14_A4_T3 #3');
    /* wrong behavior in old IE
    split = Object(\hello)split /l/, 2
    assert.strictEqual split@@, Array, 'S15.5.4.14_A4_T4 #1'
    assert.strictEqual split.length, 2, 'S15.5.4.14_A4_T4 #2'
    assert.strictEqual split.0, 'he', 'S15.5.4.14_A4_T4 #3'
    assert.strictEqual split.1, '', 'S15.5.4.14_A4_T4 #4'
    split = Object(\hello)split /l/, 3
    assert.strictEqual split@@, Array, 'S15.5.4.14_A4_T5 #1'
    assert.strictEqual split.length, 3, 'S15.5.4.14_A4_T5 #2'
    assert.strictEqual split.0, 'he', 'S15.5.4.14_A4_T5 #3'
    assert.strictEqual split.1, '', 'S15.5.4.14_A4_T5 #4'
    assert.strictEqual split.2, 'o', 'S15.5.4.14_A4_T5 #5'
    split = Object(\hello)split /l/, 4
    assert.strictEqual split@@, Array, 'S15.5.4.14_A4_T6 #1'
    assert.strictEqual split.length, 3, 'S15.5.4.14_A4_T6 #2'
    assert.strictEqual split.0, 'he', 'S15.5.4.14_A4_T6 #3'
    assert.strictEqual split.1, '', 'S15.5.4.14_A4_T6 #4'
    assert.strictEqual split.2, 'o', 'S15.5.4.14_A4_T6 #5'
    split = Object(\hello)split /l/, void
    assert.strictEqual split@@, Array, 'S15.5.4.14_A4_T7 #1'
    assert.strictEqual split.length, 3, 'S15.5.4.14_A4_T7 #2'
    assert.strictEqual split.0, 'he', 'S15.5.4.14_A4_T7 #3'
    assert.strictEqual split.1, '', 'S15.5.4.14_A4_T7 #4'
    assert.strictEqual split.2, 'o', 'S15.5.4.14_A4_T7 #5'
    */
    split = Object('hello').split(/l/, 'hi');
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A4_T8 #1');
    assert.strictEqual(split.length, 0, 'S15.5.4.14_A4_T8 #2');
    split = Object('hello').split(new RegExp);
    expected = ['h', 'e', 'l', 'l', 'o'];
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A4_T10 #1');
    assert.strictEqual(split.length, expected.length, 'S15.5.4.14_A4_T10 #2');
    for (i$ = 0, to$ = expected.length; i$ < to$; ++i$) {
      i = i$;
      assert.strictEqual(expected[i], split[i], "S15.5.4.14_A4_T10 #" + (i + 3));
    }
    split = Object('hello').split(new RegExp(), 0);
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A4_T11 #1');
    assert.strictEqual(split.length, 0, 'S15.5.4.14_A4_T11 #2');
    split = Object('hello').split(new RegExp(), 1);
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A4_T12 #1');
    assert.strictEqual(split.length, 1, 'S15.5.4.14_A4_T12 #2');
    assert.strictEqual(split[0], 'h', 'S15.5.4.14_A4_T12 #3');
    split = Object('hello').split(new RegExp(), 2);
    expected = ['h', 'e'];
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A4_T13 #1');
    assert.strictEqual(split.length, expected.length, 'S15.5.4.14_A4_T13 #2');
    for (i$ = 0, to$ = expected.length; i$ < to$; ++i$) {
      i = i$;
      assert.strictEqual(expected[i], split[i], "S15.5.4.14_A4_T13 #" + (i + 3));
    }
    split = Object('hello').split(new RegExp(), 3);
    expected = ['h', 'e', 'l'];
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A4_T14 #1');
    assert.strictEqual(split.length, expected.length, 'S15.5.4.14_A4_T14 #2');
    for (i$ = 0, to$ = expected.length; i$ < to$; ++i$) {
      i = i$;
      assert.strictEqual(expected[i], split[i], "S15.5.4.14_A4_T14 #" + (i + 3));
    }
    split = Object('hello').split(new RegExp(), 4);
    expected = ['h', 'e', 'l', 'l'];
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A4_T15 #1');
    assert.strictEqual(split.length, expected.length, 'S15.5.4.14_A4_T15 #2');
    for (i$ = 0, to$ = expected.length; i$ < to$; ++i$) {
      i = i$;
      assert.strictEqual(expected[i], split[i], "S15.5.4.14_A4_T15 #" + (i + 3));
    }
    split = Object('hello').split(new RegExp(), void 8);
    expected = ['h', 'e', 'l', 'l', 'o'];
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A4_T16 #1');
    assert.strictEqual(split.length, expected.length, 'S15.5.4.14_A4_T16 #2');
    for (i$ = 0, to$ = expected.length; i$ < to$; ++i$) {
      i = i$;
      assert.strictEqual(expected[i], split[i], "S15.5.4.14_A4_T16 #" + (i + 3));
    }
    split = Object('hello').split(new RegExp(), 'hi');
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A4_T18 #1');
    assert.strictEqual(split.length, 0, 'S15.5.4.14_A4_T18 #2');
    split = Object('a b c de f').split(/\s/);
    expected = ['a', 'b', 'c', 'de', 'f'];
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A4_T19 #1');
    assert.strictEqual(split.length, expected.length, 'S15.5.4.14_A4_T19 #2');
    for (i$ = 0, to$ = expected.length; i$ < to$; ++i$) {
      i = i$;
      assert.strictEqual(expected[i], split[i], "S15.5.4.14_A4_T19 #" + (i + 3));
    }
    split = Object('a b c de f').split(/\s/, 3);
    expected = ['a', 'b', 'c'];
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A4_T20 #1');
    assert.strictEqual(split.length, expected.length, 'S15.5.4.14_A4_T20 #2');
    for (i$ = 0, to$ = expected.length; i$ < to$; ++i$) {
      i = i$;
      assert.strictEqual(expected[i], split[i], "S15.5.4.14_A4_T20 #" + (i + 3));
    }
    split = Object('a b c de f').split(/X/);
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A4_T21 #1');
    assert.strictEqual(split.length, 1, 'S15.5.4.14_A4_T21 #2');
    assert.strictEqual(split[0], 'a b c de f', "S15.5.4.14_A4_T21 #3");
    split = Object('dfe23iu 34 =+65--').split(/\d+/);
    expected = ['dfe', 'iu ', ' =+', '--'];
    assert.strictEqual(split.constructor, Array, 'S15.5.4.14_A4_T22 #1');
    assert.strictEqual(split.length, expected.length, 'S15.5.4.14_A4_T22 #2');
    for (i$ = 0, to$ = expected.length; i$ < to$; ++i$) {
      i = i$;
      results$.push(assert.strictEqual(expected[i], split[i], "S15.5.4.14_A4_T22 #" + (i + 3)));
    }
    return results$;
  });
  test('RegExp#@@split', function(assert){
    assert.ok(toString$.call(/./[Symbol.split]).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(/./[Symbol.split].length, 2, 'arity is 2');
    assert.strictEqual(/\s/[Symbol.split]('a b c de f').length, 5);
    assert.strictEqual(/\s/[Symbol.split]('a b c de f', void 8).length, 5);
    assert.strictEqual(/\s/[Symbol.split]('a b c de f', 1).length, 1);
    return assert.strictEqual(/\s/[Symbol.split]('a b c de f', 10).length, 5);
  });
  test('@@split logic', function(assert){
    'use strict';
    var strict, str, num, O, ref$, re;
    strict = !function(){
      return this;
    }();
    str = strict
      ? 'qwe'
      : Object('qwe');
    num = strict
      ? 123
      : Object(123);
    O = (ref$ = {}, ref$[Symbol.split] = function(a, b){
      return {
        a: a,
        b: b
      };
    }, ref$);
    assert.strictEqual(str.split(O, 42).a, str);
    assert.strictEqual(str.split(O, 42).b, 42);
    assert.strictEqual(''.split.call(num, O, 42).a, num);
    assert.strictEqual(''.split.call(num, O, 42).b, 42);
    re = /./;
    re[Symbol.split] = function(a, b){
      return {
        a: a,
        b: b
      };
    };
    assert.strictEqual(str.split(re, 42).a, str);
    assert.strictEqual(str.split(re, 42).b, 42);
    assert.strictEqual(''.split.call(num, re, 42).a, num);
    return assert.strictEqual(''.split.call(num, re, 42).b, 42);
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, isFunction, isIterator, same, getOwnPropertyDescriptor, freeze, iterator, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  isFunction = function(it){
    return toString$.call(it).slice(8, -1) === 'Function';
  };
  isIterator = function(it){
    return typeof it === 'object' && isFunction(it.next);
  };
  same = function(a, b){
    if (a === b) {
      return a !== 0 || 1 / a === 1 / b;
    } else {
      return a != a && b != b;
    }
  };
  getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor, freeze = Object.freeze;
  iterator = Symbol.iterator;
  test('Set', function(assert){
    var S, r, done, iter, _add, a;
    assert.ok(isFunction(Set), 'is function');
    assert.ok(/native code/.test(Set), 'looks like native');
    assert.strictEqual(Set.name, 'Set', 'name is "Set"');
    assert.strictEqual(Set.length, 0, 'arity is 0');
    assert.ok('add' in Set.prototype, 'add in Set.prototype');
    assert.ok('clear' in Set.prototype, 'clear in Set.prototype');
    assert.ok('delete' in Set.prototype, 'delete in Set.prototype');
    assert.ok('forEach' in Set.prototype, 'forEach in Set.prototype');
    assert.ok('has' in Set.prototype, 'has in Set.prototype');
    assert.ok(new Set instanceof Set, 'new Set instanceof Set');
    assert.strictEqual(new Set([1, 2, 3, 2, 1].values()).size, 3, 'Init from iterator #1');
    assert.strictEqual(new Set([1, 2, 3, 2, 1]).size, 3, 'Init Set from iterator #2');
    assert.strictEqual(new Set([freeze({}), 1]).size, 2, 'Support frozen objects');
    S = new Set([1, 2, 3, 2, 1]);
    assert.strictEqual(S.size, 3);
    r = [];
    S.forEach(function(v){
      return r.push(v);
    });
    assert.deepEqual(r, [1, 2, 3]);
    assert.strictEqual(new Set([NaN, NaN, NaN]).size, 1);
    if (Array.from) {
      assert.deepEqual(Array.from(new Set([3, 4]).add(2).add(1)), [3, 4, 2, 1]);
    }
    done = false;
    iter = [null, 1, 2].values();
    iter['return'] = function(){
      return done = true;
    };
    _add = Set.prototype.add;
    Set.prototype.add = function(){
      throw 42;
    };
    try {
      new Set(iter);
    } catch (e$) {}
    Set.prototype.add = _add;
    assert.ok(done, '.return #throw');
    a = [];
    done = false;
    a[iterator] = function(){
      done = true;
      return [][iterator].call(this);
    };
    new Set(a);
    return assert.ok(done);
  });
  test('Set#add', function(assert){
    var a, S, chain, f;
    assert.ok(isFunction(Set.prototype.add), 'is function');
    assert.strictEqual(Set.prototype.add.name, 'add', 'name is "add"');
    assert.strictEqual(Set.prototype.add.length, 1, 'arity is 1');
    assert.ok(/native code/.test(Set.prototype.add), 'looks like native');
    a = [];
    S = new Set([NaN, 2, 3, 2, 1, a]);
    assert.strictEqual(S.size, 5);
    chain = S.add(NaN);
    assert.strictEqual(chain, S);
    assert.strictEqual(S.size, 5);
    S.add(2);
    assert.strictEqual(S.size, 5);
    S.add(a);
    assert.strictEqual(S.size, 5);
    S.add([]);
    assert.strictEqual(S.size, 6);
    S.add(4);
    assert.strictEqual(S.size, 7);
    S = new Set().add(freeze(f = {}));
    return assert.ok(S.has(f));
  });
  test('Set#clear', function(assert){
    var S, f;
    assert.ok(isFunction(Set.prototype.clear), 'is function');
    assert.strictEqual(Set.prototype.clear.name, 'clear', 'name is "clear"');
    assert.strictEqual(Set.prototype.clear.length, 0, 'arity is 0');
    assert.ok(/native code/.test(Set.prototype.clear), 'looks like native');
    S = new Set;
    S.clear();
    assert.strictEqual(S.size, 0);
    S = new Set([1, 2, 3, 2, 1]);
    S.clear();
    assert.strictEqual(S.size, 0);
    assert.ok(!S.has(1));
    assert.ok(!S.has(2));
    assert.ok(!S.has(3));
    S = new Set([1, f = freeze({})]);
    S.clear();
    assert.strictEqual(S.size, 0, 'Support frozen objects');
    assert.ok(!S.has(1));
    return assert.ok(!S.has(f));
  });
  test('Set#delete', function(assert){
    var a, S, f;
    assert.ok(isFunction(Set.prototype['delete']), 'is function');
    assert.strictEqual(Set.prototype['delete'].length, 1, 'arity is 1');
    assert.ok(/native code/.test(Set.prototype['delete']), 'looks like native');
    a = [];
    S = new Set([NaN, 2, 3, 2, 1, a]);
    assert.strictEqual(S.size, 5);
    assert.strictEqual(S['delete'](NaN), true);
    assert.strictEqual(S.size, 4);
    assert.strictEqual(S['delete'](4), false);
    assert.strictEqual(S.size, 4);
    S['delete']([]);
    assert.strictEqual(S.size, 4);
    S['delete'](a);
    assert.strictEqual(S.size, 3);
    S.add(freeze(f = {}));
    assert.strictEqual(S.size, 4);
    S['delete'](f);
    return assert.strictEqual(S.size, 3);
  });
  test('Set#forEach', function(assert){
    var r, count, S, set, s;
    assert.ok(isFunction(Set.prototype.forEach), 'is function');
    assert.strictEqual(Set.prototype.forEach.name, 'forEach', 'name is "forEach"');
    assert.strictEqual(Set.prototype.forEach.length, 1, 'arity is 1');
    assert.ok(/native code/.test(Set.prototype.forEach), 'looks like native');
    r = [];
    count = 0;
    S = new Set([1, 2, 3, 2, 1]);
    S.forEach(function(value){
      count++;
      r.push(value);
    });
    assert.strictEqual(count, 3);
    assert.deepEqual(r, [1, 2, 3]);
    set = new Set(['0', '1', '2', '3']);
    s = "";
    set.forEach(function(it){
      s += it;
      if (it === '2') {
        set['delete']('2');
        set['delete']('3');
        set['delete']('1');
        return set.add('4');
      }
    });
    assert.strictEqual(s, '0124');
    set = new Set(['0']);
    s = "";
    set.forEach(function(it){
      set['delete']('0');
      if (s !== '') {
        throw '!!!';
      }
      return s += it;
    });
    return assert.strictEqual(s, '0');
  });
  test('Set#has', function(assert){
    var a, f, S;
    assert.ok(isFunction(Set.prototype.has), 'is function');
    assert.strictEqual(Set.prototype.has.name, 'has', 'name is "has"');
    assert.strictEqual(Set.prototype.has.length, 1, 'arity is 1');
    assert.ok(/native code/.test(Set.prototype.has), 'looks like native');
    a = [];
    f = freeze({});
    S = new Set([NaN, 2, 3, 2, 1, f, a]);
    assert.ok(S.has(NaN));
    assert.ok(S.has(a));
    assert.ok(S.has(f));
    assert.ok(S.has(2));
    assert.ok(!S.has(4));
    return assert.ok(!S.has([]));
  });
  test('Set#size', function(assert){
    var size, sizeDesc;
    size = new Set([1]).size;
    assert.strictEqual(typeof size, 'number', 'size is number');
    assert.strictEqual(size, 1, 'size is correct');
    if (function(){
      try {
        return 2 === Object.defineProperty({}, 'a', {
          get: function(){
            return 2;
          }
        }).a;
      } catch (e$) {}
    }()) {
      sizeDesc = getOwnPropertyDescriptor(Set.prototype, 'size');
      assert.ok(sizeDesc && sizeDesc.get, 'size is getter');
      assert.ok(sizeDesc && !sizeDesc.set, 'size isnt setter');
      return assert.throws(function(){
        return Set.prototype.size;
      }, TypeError);
    }
  });
  test('Set & -0', function(assert){
    var set;
    set = new Set;
    set.add(-0);
    assert.strictEqual(set.size, 1);
    assert.ok(set.has(0));
    assert.ok(set.has(-0));
    set.forEach(function(it){
      return assert.ok(!same(it, -0));
    });
    set['delete'](-0);
    assert.strictEqual(set.size, 0);
    set = new Set([-0]);
    return set.forEach(function(key){
      return assert.ok(!same(key, -0));
    });
  });
  test('Set#@@toStringTag', function(assert){
    return assert.strictEqual(Set.prototype[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.toStringTag : void 8], 'Set', 'Set::@@toStringTag is `Set`');
  });
  test('Set Iterator', function(assert){
    var set, keys, iterator;
    set = new Set(['a', 'b', 'c', 'd']);
    keys = [];
    iterator = set.keys();
    keys.push(iterator.next().value);
    assert.ok(set['delete']('a'));
    assert.ok(set['delete']('b'));
    assert.ok(set['delete']('c'));
    set.add('e');
    keys.push(iterator.next().value);
    keys.push(iterator.next().value);
    assert.ok(iterator.next().done);
    set.add('f');
    assert.ok(iterator.next().done);
    return assert.deepEqual(keys, ['a', 'd', 'e']);
  });
  test('Set#keys', function(assert){
    var iter;
    assert.ok(typeof Set.prototype.keys === 'function', 'is function');
    assert.strictEqual(Set.prototype.keys.name, 'values', 'name is "values"');
    assert.strictEqual(Set.prototype.keys.length, 0, 'arity is 0');
    assert.ok(/native code/.test(Set.prototype.keys), 'looks like native');
    assert.strictEqual(Set.prototype.keys, Set.prototype.values);
    iter = new Set(['q', 'w', 'e']).keys();
    assert.ok(isIterator(iter), 'Return iterator');
    assert.strictEqual(iter[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.toStringTag : void 8], 'Set Iterator');
    assert.deepEqual(iter.next(), {
      value: 'q',
      done: false
    });
    assert.deepEqual(iter.next(), {
      value: 'w',
      done: false
    });
    assert.deepEqual(iter.next(), {
      value: 'e',
      done: false
    });
    return assert.deepEqual(iter.next(), {
      value: void 8,
      done: true
    });
  });
  test('Set#values', function(assert){
    var iter;
    assert.ok(typeof Set.prototype.values === 'function', 'is function');
    assert.strictEqual(Set.prototype.values.name, 'values', 'name is "values"');
    assert.strictEqual(Set.prototype.values.length, 0, 'arity is 0');
    assert.ok(/native code/.test(Set.prototype.values), 'looks like native');
    iter = new Set(['q', 'w', 'e']).values();
    assert.ok(isIterator(iter), 'Return iterator');
    assert.strictEqual(iter[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.toStringTag : void 8], 'Set Iterator');
    assert.deepEqual(iter.next(), {
      value: 'q',
      done: false
    });
    assert.deepEqual(iter.next(), {
      value: 'w',
      done: false
    });
    assert.deepEqual(iter.next(), {
      value: 'e',
      done: false
    });
    return assert.deepEqual(iter.next(), {
      value: void 8,
      done: true
    });
  });
  test('Set#entries', function(assert){
    var iter;
    assert.ok(typeof Set.prototype.entries === 'function', 'is function');
    assert.strictEqual(Set.prototype.entries.name, 'entries', 'name is "entries"');
    assert.strictEqual(Set.prototype.entries.length, 0, 'arity is 0');
    assert.ok(/native code/.test(Set.prototype.entries), 'looks like native');
    iter = new Set(['q', 'w', 'e']).entries();
    assert.ok(isIterator(iter), 'Return iterator');
    assert.strictEqual(iter[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.toStringTag : void 8], 'Set Iterator');
    assert.deepEqual(iter.next(), {
      value: ['q', 'q'],
      done: false
    });
    assert.deepEqual(iter.next(), {
      value: ['w', 'w'],
      done: false
    });
    assert.deepEqual(iter.next(), {
      value: ['e', 'e'],
      done: false
    });
    return assert.deepEqual(iter.next(), {
      value: void 8,
      done: true
    });
  });
  test('Set#@@iterator', function(assert){
    var iter;
    assert.ok(typeof Set.prototype[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.iterator : void 8] === 'function', 'is function');
    assert.strictEqual(Set.prototype[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.iterator : void 8].name, 'values', 'name is "values"');
    assert.strictEqual(Set.prototype[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.iterator : void 8].length, 0, 'arity is 0');
    assert.ok(/native code/.test(Set.prototype[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.iterator : void 8]), 'looks like native');
    assert.strictEqual(Set.prototype[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.iterator : void 8], Set.prototype.values);
    iter = new Set(['q', 'w', 'e'])[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.iterator : void 8]();
    assert.ok(isIterator(iter), 'Return iterator');
    assert.strictEqual(iter[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.toStringTag : void 8], 'Set Iterator');
    assert.deepEqual(iter.next(), {
      value: 'q',
      done: false
    });
    assert.deepEqual(iter.next(), {
      value: 'w',
      done: false
    });
    assert.deepEqual(iter.next(), {
      value: 'e',
      done: false
    });
    return assert.deepEqual(iter.next(), {
      value: void 8,
      done: true
    });
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  'use strict';
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('String#codePointAt', function(assert){
    assert.ok(toString$.call(String.prototype.codePointAt).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(String.prototype.codePointAt.length, 1, 'arity is 1');
    assert.ok(/native code/.test(String.prototype.codePointAt), 'looks like native');
    assert.strictEqual(String.prototype.codePointAt.name, 'codePointAt', 'name is "codePointAt"');
    assert.strictEqual('abc\uD834\uDF06def'.codePointAt(''), 0x61);
    assert.strictEqual('abc\uD834\uDF06def'.codePointAt('_'), 0x61);
    assert.strictEqual('abc\uD834\uDF06def'.codePointAt(), 0x61);
    assert.strictEqual('abc\uD834\uDF06def'.codePointAt(-Infinity), void 8);
    assert.strictEqual('abc\uD834\uDF06def'.codePointAt(-1), void 8);
    assert.strictEqual('abc\uD834\uDF06def'.codePointAt(-0), 0x61);
    assert.strictEqual('abc\uD834\uDF06def'.codePointAt(0), 0x61);
    assert.strictEqual('abc\uD834\uDF06def'.codePointAt(3), 0x1D306);
    assert.strictEqual('abc\uD834\uDF06def'.codePointAt(4), 0xDF06);
    assert.strictEqual('abc\uD834\uDF06def'.codePointAt(5), 0x64);
    assert.strictEqual('abc\uD834\uDF06def'.codePointAt(42), void 8);
    assert.strictEqual('abc\uD834\uDF06def'.codePointAt(Infinity), void 8);
    assert.strictEqual('abc\uD834\uDF06def'.codePointAt(Infinity), void 8);
    assert.strictEqual('abc\uD834\uDF06def'.codePointAt(NaN), 0x61);
    assert.strictEqual('abc\uD834\uDF06def'.codePointAt(false), 0x61);
    assert.strictEqual('abc\uD834\uDF06def'.codePointAt(null), 0x61);
    assert.strictEqual('abc\uD834\uDF06def'.codePointAt(void 8), 0x61);
    assert.strictEqual('\uD834\uDF06def'.codePointAt(''), 0x1D306);
    assert.strictEqual('\uD834\uDF06def'.codePointAt('1'), 0xDF06);
    assert.strictEqual('\uD834\uDF06def'.codePointAt('_'), 0x1D306);
    assert.strictEqual('\uD834\uDF06def'.codePointAt(), 0x1D306);
    assert.strictEqual('\uD834\uDF06def'.codePointAt(-1), void 8);
    assert.strictEqual('\uD834\uDF06def'.codePointAt(-0), 0x1D306);
    assert.strictEqual('\uD834\uDF06def'.codePointAt(0), 0x1D306);
    assert.strictEqual('\uD834\uDF06def'.codePointAt(1), 0xDF06);
    assert.strictEqual('\uD834\uDF06def'.codePointAt(42), void 8);
    assert.strictEqual('\uD834\uDF06def'.codePointAt(false), 0x1D306);
    assert.strictEqual('\uD834\uDF06def'.codePointAt(null), 0x1D306);
    assert.strictEqual('\uD834\uDF06def'.codePointAt(void 8), 0x1D306);
    assert.strictEqual('\uD834abc'.codePointAt(''), 0xD834);
    assert.strictEqual('\uD834abc'.codePointAt('_'), 0xD834);
    assert.strictEqual('\uD834abc'.codePointAt(), 0xD834);
    assert.strictEqual('\uD834abc'.codePointAt(-1), void 8);
    assert.strictEqual('\uD834abc'.codePointAt(-0), 0xD834);
    assert.strictEqual('\uD834abc'.codePointAt(0), 0xD834);
    assert.strictEqual('\uD834abc'.codePointAt(false), 0xD834);
    assert.strictEqual('\uD834abc'.codePointAt(NaN), 0xD834);
    assert.strictEqual('\uD834abc'.codePointAt(null), 0xD834);
    assert.strictEqual('\uD834abc'.codePointAt(void 8), 0xD834);
    assert.strictEqual('\uDF06abc'.codePointAt(''), 0xDF06);
    assert.strictEqual('\uDF06abc'.codePointAt('_'), 0xDF06);
    assert.strictEqual('\uDF06abc'.codePointAt(), 0xDF06);
    assert.strictEqual('\uDF06abc'.codePointAt(-1), void 8);
    assert.strictEqual('\uDF06abc'.codePointAt(-0), 0xDF06);
    assert.strictEqual('\uDF06abc'.codePointAt(0), 0xDF06);
    assert.strictEqual('\uDF06abc'.codePointAt(false), 0xDF06);
    assert.strictEqual('\uDF06abc'.codePointAt(NaN), 0xDF06);
    assert.strictEqual('\uDF06abc'.codePointAt(null), 0xDF06);
    assert.strictEqual('\uDF06abc'.codePointAt(void 8), 0xDF06);
    if (!function(){
      return this;
    }()) {
      assert.throws(function(){
        return String.prototype.codePointAt.call(null, 0);
      }, TypeError);
      return assert.throws(function(){
        return String.prototype.codePointAt.call(void 8, 0);
      }, TypeError);
    }
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  'use strict';
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('String#endsWith', function(assert){
    var re, e, O;
    assert.ok(toString$.call(String.prototype.endsWith).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(String.prototype.endsWith.length, 1, 'arity is 1');
    assert.ok(/native code/.test(String.prototype.endsWith), 'looks like native');
    assert.strictEqual(String.prototype.endsWith.name, 'endsWith', 'name is "endsWith"');
    assert.ok('undefined'.endsWith());
    assert.ok(!'undefined'.endsWith(null));
    assert.ok('abc'.endsWith(''));
    assert.ok('abc'.endsWith('c'));
    assert.ok('abc'.endsWith('bc'));
    assert.ok(!'abc'.endsWith('ab'));
    assert.ok('abc'.endsWith('', NaN));
    assert.ok(!'abc'.endsWith('c', -1));
    assert.ok('abc'.endsWith('a', 1));
    assert.ok('abc'.endsWith('c', Infinity));
    assert.ok('abc'.endsWith('a', true));
    assert.ok(!'abc'.endsWith('c', 'x'));
    assert.ok(!'abc'.endsWith('a', 'x'));
    if (!function(){
      return this;
    }()) {
      assert.throws(function(){
        return String.prototype.endsWith.call(null, '.');
      }, TypeError);
      assert.throws(function(){
        return String.prototype.endsWith.call(void 8, '.');
      }, TypeError);
    }
    re = /./;
    assert.throws(function(){
      return '/./'.endsWith(re);
    }, TypeError);
    re[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.match : void 8] = false;
    assert.ok((function(){
      try {
        return '/./'.endsWith(re);
      } catch (e$) {
        e = e$;
        return false;
      }
    }()));
    O = {};
    assert.ok((function(){
      try {
        return '[object Object]'.endsWith(O);
      } catch (e$) {
        e = e$;
        return false;
      }
    }()));
    O[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.match : void 8] = true;
    return assert.throws(function(){
      return '[object Object]'.endsWith(O);
    }, TypeError);
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('String.fromCodePoint', function(assert){
    var fromCodePoint, tmp, counter, result;
    fromCodePoint = String.fromCodePoint;
    assert.ok(toString$.call(fromCodePoint).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(fromCodePoint.length, 1, 'arity is 1');
    assert.ok(/native code/.test(fromCodePoint), 'looks like native');
    assert.strictEqual(fromCodePoint.name, 'fromCodePoint', 'name is "fromCodePoint"');
    assert.strictEqual(fromCodePoint(''), '\0');
    assert.strictEqual(fromCodePoint(), '');
    assert.strictEqual(fromCodePoint(-0), '\0');
    assert.strictEqual(fromCodePoint(0), '\0');
    assert.strictEqual(fromCodePoint(0x1D306), '\uD834\uDF06');
    assert.strictEqual(fromCodePoint(0x1D306, 0x61, 0x1D307), '\uD834\uDF06a\uD834\uDF07');
    assert.strictEqual(fromCodePoint(0x61, 0x62, 0x1D307), 'ab\uD834\uDF07');
    assert.strictEqual(fromCodePoint(false), '\0');
    assert.strictEqual(fromCodePoint(null), '\0');
    assert.throws(function(){
      return fromCodePoint('_');
    }, RangeError);
    assert.throws(function(){
      return fromCodePoint('+Infinity');
    }, RangeError);
    assert.throws(function(){
      return fromCodePoint('-Infinity');
    }, RangeError);
    assert.throws(function(){
      return fromCodePoint(-1);
    }, RangeError);
    assert.throws(function(){
      return fromCodePoint(0x10FFFF + 1);
    }, RangeError);
    assert.throws(function(){
      return fromCodePoint(3.14);
    }, RangeError);
    assert.throws(function(){
      return fromCodePoint(3e-2);
    }, RangeError);
    assert.throws(function(){
      return fromCodePoint(-Infinity);
    }, RangeError);
    assert.throws(function(){
      return fromCodePoint(Infinity);
    }, RangeError);
    assert.throws(function(){
      return fromCodePoint(NaN);
    }, RangeError);
    assert.throws(function(){
      return fromCodePoint(void 8);
    }, RangeError);
    assert.throws(function(){
      return fromCodePoint({});
    }, RangeError);
    assert.throws(function(){
      return fromCodePoint(/./);
    }, RangeError);
    tmp = 0x60;
    assert.strictEqual(fromCodePoint({
      valueOf: function(){
        return ++tmp;
      }
    }), 'a');
    assert.strictEqual(tmp, 0x61);
    counter = Math.pow(2, 15) * 3 / 2;
    result = [];
    while (--counter >= 0) {
      result.push(0);
    }
    fromCodePoint.apply(null, result);
    counter = Math.pow(2, 15) * 3 / 2;
    result = [];
    while (--counter >= 0) {
      result.push(0xFFFF + 1);
    }
    return fromCodePoint.apply(null, result);
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  'use strict';
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('String#includes', function(assert){
    var re, e, O;
    assert.ok(toString$.call(String.prototype.includes).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(String.prototype.includes.length, 1, 'arity is 1');
    assert.ok(/native code/.test(String.prototype.includes), 'looks like native');
    assert.strictEqual(String.prototype.includes.name, 'includes', 'name is "includes"');
    assert.ok(!'abc'.includes());
    assert.ok('aundefinedb'.includes());
    assert.ok('abcd'.includes('b', 1));
    assert.ok(!'abcd'.includes('b', 2));
    if (!function(){
      return this;
    }()) {
      assert.throws(function(){
        return String.prototype.includes.call(null, '.');
      }, TypeError);
      assert.throws(function(){
        return String.prototype.includes.call(void 8, '.');
      }, TypeError);
    }
    re = /./;
    assert.throws(function(){
      return '/./'.includes(re);
    }, TypeError);
    re[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.match : void 8] = false;
    assert.ok((function(){
      try {
        return '/./'.includes(re);
      } catch (e$) {
        e = e$;
        return false;
      }
    }()));
    O = {};
    assert.ok((function(){
      try {
        return '[object Object]'.includes(O);
      } catch (e$) {
        e = e$;
        return false;
      }
    }()));
    O[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.match : void 8] = true;
    return assert.throws(function(){
      return '[object Object]'.includes(O);
    }, TypeError);
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, isFunction, isIterator, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  isFunction = function(it){
    return toString$.call(it).slice(8, -1) === 'Function';
  };
  isIterator = function(it){
    return typeof it === 'object' && isFunction(it.next);
  };
  test('String#@@iterator', function(assert){
    var iter;
    assert.ok(isFunction(String.prototype[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.iterator : void 8]), 'is function');
    iter = 'qwe'[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.iterator : void 8]();
    assert.ok(isIterator(iter), 'Return iterator');
    assert.strictEqual(iter[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.toStringTag : void 8], 'String Iterator');
    assert.deepEqual(iter.next(), {
      value: 'q',
      done: false
    });
    assert.deepEqual(iter.next(), {
      value: 'w',
      done: false
    });
    assert.deepEqual(iter.next(), {
      value: 'e',
      done: false
    });
    assert.deepEqual(iter.next(), {
      value: void 8,
      done: true
    });
    assert.strictEqual(Array.from('𠮷𠮷𠮷').length, 3);
    iter = '𠮷𠮷𠮷'[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.iterator : void 8]();
    assert.deepEqual(iter.next(), {
      value: '𠮷',
      done: false
    });
    assert.deepEqual(iter.next(), {
      value: '𠮷',
      done: false
    });
    assert.deepEqual(iter.next(), {
      value: '𠮷',
      done: false
    });
    return assert.deepEqual(iter.next(), {
      value: void 8,
      done: true
    });
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('String.raw', function(assert){
    var raw;
    raw = String.raw;
    assert.ok(toString$.call(raw).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(raw.length, 1, 'arity is 1');
    assert.ok(/native code/.test(raw), 'looks like native');
    assert.strictEqual(raw.name, 'raw', 'name is "raw"');
    assert.strictEqual(raw({
      raw: ['Hi\\n', '!']
    }, 'Bob'), 'Hi\\nBob!', 'raw is array');
    assert.strictEqual(raw({
      raw: 'test'
    }, 0, 1, 2), 't0e1s2t', 'raw is string');
    assert.strictEqual(raw({
      raw: 'test'
    }, 0), 't0est', 'lacks substituting');
    assert.throws(function(){
      return raw({});
    }, TypeError);
    return assert.throws(function(){
      return raw({
        raw: null
      });
    }, TypeError);
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  'use strict';
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('String#repeat', function(assert){
    assert.ok(toString$.call(String.prototype.repeat).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(String.prototype.repeat.length, 1, 'arity is 1');
    assert.ok(/native code/.test(String.prototype.repeat), 'looks like native');
    assert.strictEqual(String.prototype.repeat.name, 'repeat', 'name is "repeat"');
    assert.strictEqual('qwe'.repeat(3), 'qweqweqwe');
    assert.strictEqual('qwe'.repeat(2.5), 'qweqwe');
    assert.throws(function(){
      return 'qwe'.repeat(-1);
    }, RangeError);
    assert.throws(function(){
      return 'qwe'.repeat(Infinity);
    }, RangeError);
    if (!function(){
      return this;
    }()) {
      assert.throws(function(){
        return String.prototype.repeat.call(null, 1);
      }, TypeError);
      return assert.throws(function(){
        return String.prototype.repeat.call(void 8, 1);
      }, TypeError);
    }
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  'use strict';
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('String#startsWith', function(assert){
    var re, e, O;
    assert.ok(toString$.call(String.prototype.startsWith).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(String.prototype.startsWith.length, 1, 'arity is 1');
    assert.ok(/native code/.test(String.prototype.startsWith), 'looks like native');
    assert.strictEqual(String.prototype.startsWith.name, 'startsWith', 'name is "startsWith"');
    assert.ok('undefined'.startsWith());
    assert.ok(!'undefined'.startsWith(null));
    assert.ok('abc'.startsWith(''));
    assert.ok('abc'.startsWith('a'));
    assert.ok('abc'.startsWith('ab'));
    assert.ok(!'abc'.startsWith('bc'));
    assert.ok('abc'.startsWith('', NaN));
    assert.ok('abc'.startsWith('a', -1));
    assert.ok(!'abc'.startsWith('a', 1));
    assert.ok(!'abc'.startsWith('a', Infinity));
    assert.ok('abc'.startsWith('b', true));
    assert.ok('abc'.startsWith('a', 'x'));
    if (!function(){
      return this;
    }()) {
      assert.throws(function(){
        return String.prototype.startsWith.call(null, '.');
      }, TypeError);
      assert.throws(function(){
        return String.prototype.startsWith.call(void 8, '.');
      }, TypeError);
    }
    re = /./;
    assert.throws(function(){
      return '/./'.startsWith(re);
    }, TypeError);
    re[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.match : void 8] = false;
    assert.ok((function(){
      try {
        return '/./'.startsWith(re);
      } catch (e$) {
        e = e$;
        return false;
      }
    }()));
    O = {};
    assert.ok((function(){
      try {
        return '[object Object]'.startsWith(O);
      } catch (e$) {
        e = e$;
        return false;
      }
    }()));
    O[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.match : void 8] = true;
    return assert.throws(function(){
      return '[object Object]'.startsWith(O);
    }, TypeError);
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  'use strict';
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  test('String#trim', function(assert){
    assert.ok(toString$.call(''.trim).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(String.prototype.trim.length, 0, 'arity is 0');
    assert.ok(/native code/.test(String.prototype.trim), 'looks like native');
    assert.strictEqual(String.prototype.trim.name, 'trim', 'name is "trim"');
    assert.strictEqual(' \n  q w e \n  '.trim(), 'q w e', 'removes whitespaces at left & right side of string');
    assert.strictEqual('\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF'.trim(), '', 'removes all whitespaces');
    assert.strictEqual('\u200b\u0085'.trim(), '\u200b\u0085', "shouldn't remove this symbols");
    if (!function(){
      return this;
    }()) {
      assert.throws(function(){
        return String.prototype.trim.call(null, 0);
      }, TypeError);
      return assert.throws(function(){
        return String.prototype.trim.call(void 8, 0);
      }, TypeError);
    }
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, defineProperty, getOwnPropertyDescriptor, create, isFunction, isNative, descriptors, G, i$, ref$, len$, key, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  defineProperty = Object.defineProperty, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor, create = Object.create;
  isFunction = function(it){
    return toString$.call(it).slice(8, -1) === 'Function';
  };
  isNative = function(it){
    return /\[native code\]\s*\}\s*$/.test(it);
  };
  descriptors = function(){
    try {
      return 2 === Object.defineProperty({}, 'a', {
        get: function(){
          return 2;
        }
      }).a;
    } catch (e$) {}
  }();
  G = (typeof global != 'undefined' && global !== null) && global || window;
  test('Symbol', function(assert){
    var s1, s2, O, count, i;
    assert.ok(isFunction(Symbol), 'is function');
    assert.strictEqual(Symbol.name, 'Symbol', 'name is "Symbol"');
    assert.ok(/native code/.test(Symbol), 'looks like native');
    s1 = Symbol('foo');
    s2 = Symbol('foo');
    assert.ok(s1 !== s2, 'Symbol("foo") !== Symbol("foo")');
    O = {};
    O[s1] = 42;
    assert.ok(O[s1] === 42, 'Symbol() work as key');
    assert.ok(O[s2] !== 42, 'Various symbols from one description are various keys');
    if (descriptors) {
      count = 0;
      for (i in O) {
        count++;
      }
      return assert.ok(count === 0, 'object[Symbol()] is not enumerable');
    }
  });
  test('Well-known Symbols', function(assert){
    var i$, x$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = ['hasInstance', 'isConcatSpreadable', 'iterator', 'match', 'replace', 'search', 'species', 'split', 'toPrimitive', 'toStringTag', 'unscopables']).length; i$ < len$; ++i$) {
      x$ = ref$[i$];
      assert.ok(x$ in Symbol, "Symbol." + x$ + " available");
      results$.push(assert.ok(Object(Symbol[x$]) instanceof Symbol, "Symbol." + x$ + " is symbol"));
    }
    return results$;
  });
  test('Global symbol registry', function(assert){
    var symbol;
    assert.ok(isFunction(Symbol['for']), 'Symbol.for is function');
    assert.strictEqual(Symbol['for'].length, 1, 'Symbol.for arity is 1');
    assert.ok(/native code/.test(Symbol['for']), 'Symbol.for looks like native');
    assert.ok(isFunction(Symbol.keyFor), 'Symbol.keyFor is function');
    assert.strictEqual(Symbol.keyFor.length, 1, 'Symbol.keyFor arity is 1');
    assert.strictEqual(Symbol.keyFor.name, 'keyFor', 'Symbol.keyFor.name is "keyFor"');
    assert.ok(/native code/.test(Symbol.keyFor), 'Symbol.keyFor looks like native');
    symbol = Symbol['for']('foo');
    assert.strictEqual(Symbol['for']('foo'), symbol);
    return assert.strictEqual(Symbol.keyFor(symbol), 'foo');
  });
  test('Symbol#@@toStringTag', function(assert){
    return assert.ok(Symbol.prototype[Symbol.toStringTag] === 'Symbol', 'Symbol::@@toStringTag is `Symbol`');
  });
  test('Object.getOwnPropertySymbols', function(assert){
    var getOwnPropertySymbols, getOwnPropertyNames, obj, foo, ref$;
    getOwnPropertySymbols = Object.getOwnPropertySymbols, getOwnPropertyNames = Object.getOwnPropertyNames;
    assert.ok(isFunction(getOwnPropertySymbols), 'is function');
    assert.strictEqual(getOwnPropertySymbols.length, 1, 'arity is 1');
    assert.strictEqual(getOwnPropertySymbols.name, 'getOwnPropertySymbols', 'name is "getOwnPropertySymbols"');
    assert.ok(/native code/.test(getOwnPropertySymbols), 'looks like native');
    obj = {
      q: 1,
      w: 2,
      e: 3
    };
    obj[Symbol()] = 42;
    obj[Symbol()] = 43;
    assert.deepEqual(getOwnPropertyNames(obj).sort(), ['e', 'q', 'w']);
    assert.strictEqual(getOwnPropertySymbols(obj).length, 2);
    foo = (ref$ = clone$(obj), ref$.a = 1, ref$.s = 2, ref$.d = 3, ref$);
    foo[Symbol()] = 44;
    assert.deepEqual(getOwnPropertyNames(foo).sort(), ['a', 'd', 's']);
    return assert.strictEqual(getOwnPropertySymbols(foo).length, 1);
  });
  if (typeof JSON != 'undefined' && JSON !== null) {
    test('Symbols & JSON.stringify', function(assert){
      var ref$;
      assert.strictEqual(JSON.stringify([1, Symbol('foo'), false, Symbol('bar'), {}]), '[1,null,false,null,{}]', 'array value');
      if (descriptors) {
        return assert.strictEqual(JSON.stringify((ref$ = {}, ref$[Symbol('foo')] = 1, ref$.bar = 2, ref$)), '{"bar":2}', 'object key');
      }
    });
  }
  if (descriptors) {
    test('Symbols & descriptors', function(assert){
      var create, defineProperty, getOwnPropertyDescriptor, keys, getOwnPropertyNames, getOwnPropertySymbols, d, e, f, i, j, proto, ref$, O, desc;
      create = Object.create, defineProperty = Object.defineProperty, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor, keys = Object.keys, getOwnPropertyNames = Object.getOwnPropertyNames, getOwnPropertySymbols = Object.getOwnPropertySymbols;
      d = Symbol('d');
      e = Symbol('e');
      f = Symbol('f');
      i = Symbol('i');
      j = Symbol('j');
      proto = (ref$ = {
        g: 'g'
      }, ref$[i] = 'i', ref$);
      defineProperty(proto, 'h', {
        value: 'h'
      });
      defineProperty(proto, 'j', {
        value: 'j'
      });
      O = create(proto);
      O.a = 'a';
      O[d] = 'd';
      defineProperty(O, 'b', {
        value: 'b'
      });
      defineProperty(O, 'c', {
        value: 'c',
        enumerable: true
      });
      defineProperty(O, e, {
        configurable: true,
        writable: true,
        value: 'e'
      });
      desc = {
        value: 'f',
        enumerable: true
      };
      defineProperty(O, f, desc);
      assert.strictEqual(desc.enumerable, true, 'defineProperty not changes descriptor object');
      assert.deepEqual(getOwnPropertyDescriptor(O, 'a'), {
        configurable: true,
        writable: true,
        enumerable: true,
        value: 'a'
      }, 'getOwnPropertyDescriptor a');
      assert.deepEqual(getOwnPropertyDescriptor(O, 'b'), {
        configurable: false,
        writable: false,
        enumerable: false,
        value: 'b'
      }, 'getOwnPropertyDescriptor b');
      assert.deepEqual(getOwnPropertyDescriptor(O, 'c'), {
        configurable: false,
        writable: false,
        enumerable: true,
        value: 'c'
      }, 'getOwnPropertyDescriptor c');
      assert.deepEqual(getOwnPropertyDescriptor(O, d), {
        configurable: true,
        writable: true,
        enumerable: true,
        value: 'd'
      }, 'getOwnPropertyDescriptor d');
      assert.deepEqual(getOwnPropertyDescriptor(O, e), {
        configurable: true,
        writable: true,
        enumerable: false,
        value: 'e'
      }, 'getOwnPropertyDescriptor e');
      assert.deepEqual(getOwnPropertyDescriptor(O, f), {
        configurable: false,
        writable: false,
        enumerable: true,
        value: 'f'
      }, 'getOwnPropertyDescriptor f');
      assert.strictEqual(getOwnPropertyDescriptor(O, 'g'), void 8, 'getOwnPropertyDescriptor g');
      assert.strictEqual(getOwnPropertyDescriptor(O, 'h'), void 8, 'getOwnPropertyDescriptor h');
      assert.strictEqual(getOwnPropertyDescriptor(O, i), void 8, 'getOwnPropertyDescriptor i');
      assert.strictEqual(getOwnPropertyDescriptor(O, j), void 8, 'getOwnPropertyDescriptor j');
      assert.strictEqual(getOwnPropertyDescriptor(O, 'k'), void 8, 'getOwnPropertyDescriptor k');
      assert.strictEqual(O.propertyIsEnumerable('a'), true, 'propertyIsEnumerable a');
      assert.strictEqual(O.propertyIsEnumerable('b'), false, 'propertyIsEnumerable b');
      assert.strictEqual(O.propertyIsEnumerable('c'), true, 'propertyIsEnumerable c');
      assert.strictEqual(O.propertyIsEnumerable(d), true, 'propertyIsEnumerable d');
      assert.strictEqual(O.propertyIsEnumerable(e), false, 'propertyIsEnumerable e');
      assert.strictEqual(O.propertyIsEnumerable(f), true, 'propertyIsEnumerable f');
      assert.strictEqual(O.propertyIsEnumerable('g'), false, 'propertyIsEnumerable g');
      assert.strictEqual(O.propertyIsEnumerable('h'), false, 'propertyIsEnumerable h');
      assert.strictEqual(O.propertyIsEnumerable(i), false, 'propertyIsEnumerable i');
      assert.strictEqual(O.propertyIsEnumerable(j), false, 'propertyIsEnumerable j');
      assert.strictEqual(O.propertyIsEnumerable('k'), false, 'propertyIsEnumerable k');
      assert.strictEqual(keys(O).length, 2, 'Object.keys');
      assert.strictEqual(getOwnPropertyNames(O).length, 3, 'Object.getOwnPropertyNames');
      assert.strictEqual(getOwnPropertySymbols(O).length, 3, 'Object.getOwnPropertySymbols');
      assert.strictEqual(Reflect.ownKeys(O).length, 6, 'Reflect.ownKeys');
      delete O[e];
      O[e] = 'e';
      return assert.deepEqual(getOwnPropertyDescriptor(O, e), {
        configurable: true,
        writable: true,
        enumerable: true,
        value: 'e'
      }, 'redefined non-enum key');
    });
    test('Symbols & Object.defineProperties', function(assert){
      var defineProperty, defineProperties, c, d, D, ref$, O;
      defineProperty = Object.defineProperty, defineProperties = Object.defineProperties;
      c = Symbol('c');
      d = Symbol('d');
      D = (ref$ = {
        a: {
          value: 'a'
        }
      }, ref$[c] = {
        value: 'c'
      }, ref$);
      defineProperty(D, 'b', {
        value: {
          value: 'b'
        }
      });
      defineProperty(D, d, {
        value: {
          value: 'd'
        }
      });
      O = defineProperties({}, D);
      assert.strictEqual(O.a, 'a', 'a');
      assert.strictEqual(O.b, void 8, 'b');
      assert.strictEqual(O[c], 'c', 'c');
      return assert.strictEqual(O[d], void 8, 'd');
    });
    test('Symbols & Object.create', function(assert){
      var defineProperty, create, c, d, D, ref$, O;
      defineProperty = Object.defineProperty, create = Object.create;
      c = Symbol('c');
      d = Symbol('d');
      D = (ref$ = {
        a: {
          value: 'a'
        }
      }, ref$[c] = {
        value: 'c'
      }, ref$);
      defineProperty(D, 'b', {
        value: {
          value: 'b'
        }
      });
      defineProperty(D, d, {
        value: {
          value: 'd'
        }
      });
      O = create(null, D);
      assert.strictEqual(O.a, 'a', 'a');
      assert.strictEqual(O.b, void 8, 'b');
      assert.strictEqual(O[c], 'c', 'c');
      return assert.strictEqual(O[d], void 8, 'd');
    });
    for (i$ = 0, len$ = (ref$ = ['Array', 'RegExp', 'Map', 'Set', 'WeakMap', 'WeakSet', 'Promise']).length; i$ < len$; ++i$) {
      key = ref$[i$];
      test(key + "@@species", fn$);
    }
  }
  function clone$(it){
    function fun(){} fun.prototype = it;
    return new fun;
  }
  function fn$(assert){
    var C;
    assert.strictEqual(G[key][Symbol.species], G[key], key + "@@species === " + key);
    C = Object.create(G[key]);
    return assert.strictEqual(C[Symbol.species], C, key + " sub");
  }
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, isFunction, freeze, iterator, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  isFunction = function(it){
    return toString$.call(it).slice(8, -1) === 'Function';
  };
  freeze = Object.freeze;
  iterator = Symbol.iterator;
  test('WeakMap', function(assert){
    var a, b, f, M, done, iter;
    assert.ok(isFunction(WeakMap), 'is function');
    assert.ok(/native code/.test(WeakMap), 'looks like native');
    assert.strictEqual(WeakMap.name, 'WeakMap', 'name is "WeakMap"');
    assert.strictEqual(WeakMap.length, 0, 'arity is 0');
    assert.ok('delete' in WeakMap.prototype, 'delete in WeakMap.prototype');
    assert.ok('get' in WeakMap.prototype, 'get in WeakMap.prototype');
    assert.ok('has' in WeakMap.prototype, 'has in WeakMap.prototype');
    assert.ok('set' in WeakMap.prototype, 'set in WeakMap.prototype');
    assert.ok(new WeakMap instanceof WeakMap, 'new WeakMap instanceof WeakMap');
    assert.strictEqual(new WeakMap([[a = {}, b = {}]].values()).get(a), b, 'Init WeakMap from iterator #1');
    assert.strictEqual(new WeakMap(new Map([[a = {}, b = {}]])).get(a), b, 'Init WeakMap from iterator #2');
    assert.strictEqual(new WeakMap([[f = freeze({}), 42]]).get(f), 42, 'Support frozen objects');
    M = new WeakMap;
    M.set(freeze(f = {}), 42);
    assert.strictEqual(M.has(f), true);
    assert.strictEqual(M.get(f), 42);
    M['delete'](f);
    assert.strictEqual(M.has(f), false);
    assert.strictEqual(M.get(f), void 8);
    done = false;
    iter = [null, 1, 2].values();
    iter['return'] = function(){
      return done = true;
    };
    try {
      new WeakMap(iter);
    } catch (e$) {}
    assert.ok(done, '.return #throw');
    assert.ok(!('clear' in WeakMap.prototype), 'should not contains `.clear` method');
    a = [];
    done = false;
    a[iterator] = function(){
      done = true;
      return [][iterator].call(this);
    };
    new WeakMap(a);
    return assert.ok(done);
  });
  test('WeakMap#delete', function(assert){
    var M, a, b;
    assert.ok(isFunction(WeakMap.prototype['delete']), 'is function');
    assert.ok(/native code/.test(WeakMap.prototype['delete']), 'looks like native');
    M = new WeakMap().set(a = {}, 42).set(b = {}, 21);
    assert.ok(M.has(a) && M.has(b), 'WeakMap has values before .delete()');
    M['delete'](a);
    return assert.ok(!M.has(a) && M.has(b), 'WeakMap hasn`t value after .delete()');
  });
  test('WeakMap#get', function(assert){
    var M, a;
    assert.ok(isFunction(WeakMap.prototype.get), 'is function');
    assert.strictEqual(WeakMap.prototype.get.name, 'get', 'name is "get"');
    assert.ok(/native code/.test(WeakMap.prototype.get), 'looks like native');
    M = new WeakMap();
    assert.strictEqual(M.get({}), void 8, 'WeakMap .get() before .set() return undefined');
    M.set(a = {}, 42);
    assert.strictEqual(M.get(a), 42, 'WeakMap .get() return value');
    M['delete'](a);
    return assert.strictEqual(M.get(a), void 8, 'WeakMap .get() after .delete() return undefined');
  });
  test('WeakMap#has', function(assert){
    var M, a;
    assert.ok(isFunction(WeakMap.prototype.has), 'is function');
    assert.strictEqual(WeakMap.prototype.has.name, 'has', 'name is "has"');
    assert.ok(/native code/.test(WeakMap.prototype.has), 'looks like native');
    M = new WeakMap();
    assert.ok(!M.has({}), 'WeakMap .has() before .set() return false');
    M.set(a = {}, 42);
    assert.ok(M.has(a), 'WeakMap .has() return true');
    M['delete'](a);
    return assert.ok(!M.has(a), 'WeakMap .has() after .delete() return false');
  });
  test('WeakMap#set', function(assert){
    var a, e;
    assert.ok(isFunction(WeakMap.prototype.set), 'is function');
    assert.strictEqual(WeakMap.prototype.set.name, 'set', 'name is "set"');
    assert.strictEqual(WeakMap.prototype.set.length, 2, 'arity is 2');
    assert.ok(/native code/.test(WeakMap.prototype.set), 'looks like native');
    assert.ok(new WeakMap().set(a = {}, 42), 'WeakMap.prototype.set works with object as keys');
    return assert.ok((function(){
      try {
        new WeakMap().set(42, 42);
        return false;
      } catch (e$) {
        e = e$;
        return true;
      }
    }()), 'WeakMap.prototype.set throw with primitive keys');
  });
  test('WeakMap#@@toStringTag', function(assert){
    return assert.strictEqual(WeakMap.prototype[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.toStringTag : void 8], 'WeakMap', 'WeakMap::@@toStringTag is `WeakMap`');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, isFunction, freeze, iterator, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES6');
  isFunction = function(it){
    return toString$.call(it).slice(8, -1) === 'Function';
  };
  freeze = Object.freeze;
  iterator = Symbol.iterator;
  test('WeakSet', function(assert){
    var a, f, S, done, iter;
    assert.ok(isFunction(WeakSet), 'is function');
    assert.ok(/native code/.test(WeakSet), 'looks like native');
    assert.strictEqual(WeakSet.name, 'WeakSet', 'name is "WeakSet"');
    assert.strictEqual(WeakSet.length, 0, 'arity is 0');
    assert.ok('add' in WeakSet.prototype, 'add in WeakSet.prototype');
    assert.ok('delete' in WeakSet.prototype, 'delete in WeakSet.prototype');
    assert.ok('has' in WeakSet.prototype, 'has in WeakSet.prototype');
    assert.ok(new WeakSet instanceof WeakSet, 'new WeakSet instanceof WeakSet');
    assert.ok(new WeakSet([a = {}].values()).has(a), 'Init WeakSet from iterator #1');
    assert.ok(new WeakSet([a = {}]).has(a), 'Init WeakSet from iterator #2');
    assert.ok(new WeakSet([freeze(f = {})]).has(f), 'Support frozen objects');
    S = new WeakSet;
    S.add(freeze(f = {}));
    assert.strictEqual(S.has(f), true);
    S['delete'](f);
    assert.strictEqual(S.has(f), false);
    done = false;
    iter = [null, 1, 2].values();
    iter['return'] = function(){
      return done = true;
    };
    try {
      new WeakSet(iter);
    } catch (e$) {}
    assert.ok(done, '.return #throw');
    assert.ok(!('clear' in WeakSet.prototype), 'should not contains `.clear` method');
    a = [];
    done = false;
    a[iterator] = function(){
      done = true;
      return [][iterator].call(this);
    };
    new WeakSet(a);
    return assert.ok(done);
  });
  test('WeakSet#add', function(assert){
    var a, e;
    assert.ok(isFunction(WeakSet.prototype.add), 'is function');
    assert.strictEqual(WeakSet.prototype.add.name, 'add', 'name is "add"');
    assert.strictEqual(WeakSet.prototype.add.length, 1, 'arity is 1');
    assert.ok(/native code/.test(WeakSet.prototype.add), 'looks like native');
    assert.ok(new WeakSet().add(a = {}), 'WeakSet.prototype.add works with object as keys');
    return assert.ok((function(){
      try {
        new WeakSet().add(42);
        return false;
      } catch (e$) {
        e = e$;
        return true;
      }
    }()), 'WeakSet.prototype.add throw with primitive keys');
  });
  test('WeakSet#delete', function(assert){
    var S, a, b;
    assert.ok(isFunction(WeakSet.prototype['delete']), 'is function');
    assert.strictEqual(WeakSet.prototype['delete'].length, 1, 'arity is 1');
    assert.ok(/native code/.test(WeakSet.prototype['delete']), 'looks like native');
    S = new WeakSet().add(a = {}).add(b = {});
    assert.ok(S.has(a) && S.has(b), 'WeakSet has values before .delete()');
    S['delete'](a);
    return assert.ok(!S.has(a) && S.has(b), 'WeakSet has`nt value after .delete()');
  });
  test('WeakSet#has', function(assert){
    var M, a;
    assert.ok(isFunction(WeakSet.prototype.has), 'is function');
    assert.strictEqual(WeakSet.prototype.has.name, 'has', 'name is "has"');
    assert.strictEqual(WeakSet.prototype.has.length, 1, 'arity is 1');
    assert.ok(/native code/.test(WeakSet.prototype.has), 'looks like native');
    M = new WeakSet();
    assert.ok(!M.has({}), 'WeakSet has`nt value');
    M.add(a = {});
    assert.ok(M.has(a), 'WeakSet has value after .add()');
    M['delete'](a);
    return assert.ok(!M.has(a), 'WeakSet has`nt value after .delete()');
  });
  test('WeakSet::@@toStringTag', function(assert){
    return assert.strictEqual(WeakSet.prototype[typeof Symbol != 'undefined' && Symbol !== null ? Symbol.toStringTag : void 8], 'WeakSet', 'WeakSet::@@toStringTag is `WeakSet`');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  'use strict';
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES7');
  test('Array#includes', function(assert){
    var arr, o;
    assert.ok(toString$.call(Array.prototype.includes).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(Array.prototype.includes.name, 'includes', 'name is "includes"');
    assert.strictEqual(Array.prototype.includes.length, 1, 'arity is 1');
    assert.ok(/native code/.test(Array.prototype.includes), 'looks like native');
    arr = [1, 2, 3, -0, o = {}];
    assert.ok(arr.includes(1));
    assert.ok(arr.includes(-0));
    assert.ok(arr.includes(0));
    assert.ok(arr.includes(o));
    assert.ok(!arr.includes(4));
    assert.ok(!arr.includes(-0.5));
    assert.ok(!arr.includes({}));
    assert.ok(Array(1).includes(void 8));
    assert.ok([NaN].includes(NaN));
    if (!function(){
      return this;
    }()) {
      assert.throws(function(){
        return Array.prototype.includes.call(null, 0);
      }, TypeError);
      assert.throws(function(){
        return Array.prototype.includes.call(void 8, 0);
      }, TypeError);
    }
    return assert.ok('includes' in Array.prototype[Symbol.unscopables], 'In Array#@@unscopables');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES7');
  test('Map#toJSON', function(assert){
    assert.ok(toString$.call(Map.prototype.toJSON).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(Map.prototype.toJSON.name, 'toJSON', 'name is "toJSON"');
    assert.strictEqual(Map.prototype.toJSON.length, 0, 'arity is 0');
    assert.ok(/native code/.test(Map.prototype.toJSON), 'looks like native');
    if (typeof JSON != 'undefined' && JSON !== null) {
      return assert.strictEqual(JSON.stringify(new Map([['a', 'b'], ['c', 'd']])), '[["a","b"],["c","d"]]', 'Works');
    }
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES7');
  test('Object.entries', function(assert){
    var entries, create, assign;
    entries = Object.entries, create = Object.create, assign = Object.assign;
    assert.ok(toString$.call(entries).slice(8, -1) === 'Function', 'is function');
    assert.ok(/native code/.test(entries), 'looks like native');
    assert.strictEqual(entries.length, 1, 'arity is 1');
    assert.strictEqual(entries.name, 'entries', 'name is "entries"');
    assert.deepEqual(entries({
      q: 1,
      w: 2,
      e: 3
    }), [['q', 1], ['w', 2], ['e', 3]]);
    assert.deepEqual(entries(new String('qwe')), [['0', 'q'], ['1', 'w'], ['2', 'e']]);
    assert.deepEqual(entries(assign(create({
      q: 1,
      w: 2,
      e: 3
    }), {
      a: 4,
      s: 5,
      d: 6
    })), [['a', 4], ['s', 5], ['d', 6]]);
    try {
      return assert.deepEqual(Function('return Object.entries({a: 1, get b(){delete this.c;return 2},c: 3})')(), [['a', 1], ['b', 2]]);
    } catch (e$) {}
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, descriptors, create, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES7');
  descriptors = function(){
    try {
      return 2 === Object.defineProperty({}, 'a', {
        get: function(){
          return 2;
        }
      }).a;
    } catch (e$) {}
  }();
  create = Object.create;
  test('Object.getOwnPropertyDescriptors', function(assert){
    var getOwnPropertyDescriptors, O, s, descs;
    getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors;
    assert.ok(toString$.call(getOwnPropertyDescriptors).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(getOwnPropertyDescriptors.length, 1, 'arity is 1');
    assert.strictEqual(getOwnPropertyDescriptors.name, 'getOwnPropertyDescriptors', 'name is "getOwnPropertyDescriptors"');
    assert.ok(/native code/.test(getOwnPropertyDescriptors), 'looks like native');
    O = create({
      q: 1
    }, {
      e: {
        value: 3
      }
    });
    O.w = 2;
    s = Symbol('s');
    O[s] = 4;
    descs = getOwnPropertyDescriptors(O);
    assert.strictEqual(descs.q, void 8);
    assert.deepEqual(descs.w, {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 2
    });
    if (descriptors) {
      assert.deepEqual(descs.e, {
        enumerable: false,
        configurable: false,
        writable: false,
        value: 3
      });
    } else {
      assert.deepEqual(descs.e, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 3
      });
    }
    return assert.strictEqual(descs[s].value, 4);
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES7');
  test('Object.values', function(assert){
    var values, create, assign;
    values = Object.values, create = Object.create, assign = Object.assign;
    assert.ok(toString$.call(values).slice(8, -1) === 'Function', 'is function');
    assert.ok(/native code/.test(values), 'looks like native');
    assert.strictEqual(values.length, 1, 'arity is 1');
    assert.strictEqual(values.name, 'values', 'name is "values"');
    assert.deepEqual(values({
      q: 1,
      w: 2,
      e: 3
    }), [1, 2, 3]);
    assert.deepEqual(values(new String('qwe')), ['q', 'w', 'e']);
    assert.deepEqual(values(assign(create({
      q: 1,
      w: 2,
      e: 3
    }), {
      a: 4,
      s: 5,
      d: 6
    })), [4, 5, 6]);
    try {
      return assert.deepEqual(Function('return Object.values({a: 1, get b(){delete this.c;return 2},c: 3})')(), [1, 2]);
    } catch (e$) {}
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES7');
  test('RegExp.escape', function(assert){
    var escape;
    escape = RegExp.escape;
    assert.ok(toString$.call(escape).slice(8, -1) === 'Function', 'is function');
    assert.ok(/native code/.test(escape), 'looks like native');
    assert.strictEqual(escape.length, 1, 'arity is 1');
    assert.strictEqual(escape.name, 'escape', 'name is "escape"');
    assert.strictEqual(escape('qwe asd'), 'qwe asd', "Don't change simple string");
    return assert.strictEqual(escape('\\[]{}()*+?.^$|'), '\\\\\\[\\]\\{\\}\\(\\)\\*\\+\\?\\.\\^\\$\\|', 'Escape all RegExp special chars');
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES7');
  test('Set#toJSON', function(assert){
    assert.ok(toString$.call(Set.prototype.toJSON).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(Set.prototype.toJSON.name, 'toJSON', 'name is "toJSON"');
    assert.strictEqual(Set.prototype.toJSON.length, 0, 'arity is 0');
    assert.ok(/native code/.test(Set.prototype.toJSON), 'looks like native');
    if (typeof JSON != 'undefined' && JSON !== null) {
      return assert.strictEqual(JSON.stringify(new Set([1, 2, 3, 2, 1])), '[1,2,3]', 'Works');
    }
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  'use strict';
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES7');
  test('String#at', function(assert){
    var at;
    assert.ok(toString$.call(String.prototype.at).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(String.prototype.at.length, 1, 'arity is 1');
    assert.ok(/native code/.test(String.prototype.at), 'looks like native');
    assert.strictEqual(String.prototype.at.name, 'at', 'name is "at"');
    assert.strictEqual('abc\uD834\uDF06def'.at(-Infinity), '');
    assert.strictEqual('abc\uD834\uDF06def'.at(-1), '');
    assert.strictEqual('abc\uD834\uDF06def'.at(-0), 'a');
    assert.strictEqual('abc\uD834\uDF06def'.at(+0), 'a');
    assert.strictEqual('abc\uD834\uDF06def'.at(1), 'b');
    assert.strictEqual('abc\uD834\uDF06def'.at(3), '\uD834\uDF06');
    assert.strictEqual('abc\uD834\uDF06def'.at(4), '\uDF06');
    assert.strictEqual('abc\uD834\uDF06def'.at(5), 'd');
    assert.strictEqual('abc\uD834\uDF06def'.at(42), '');
    assert.strictEqual('abc\uD834\uDF06def'.at(Infinity), '');
    assert.strictEqual('abc\uD834\uDF06def'.at(null), 'a');
    assert.strictEqual('abc\uD834\uDF06def'.at(void 8), 'a');
    assert.strictEqual('abc\uD834\uDF06def'.at(), 'a');
    assert.strictEqual('abc\uD834\uDF06def'.at(false), 'a');
    assert.strictEqual('abc\uD834\uDF06def'.at(NaN), 'a');
    assert.strictEqual('abc\uD834\uDF06def'.at(''), 'a');
    assert.strictEqual('abc\uD834\uDF06def'.at('_'), 'a');
    assert.strictEqual('abc\uD834\uDF06def'.at('1'), 'b');
    assert.strictEqual('abc\uD834\uDF06def'.at([]), 'a');
    assert.strictEqual('abc\uD834\uDF06def'.at({}), 'a');
    assert.strictEqual('abc\uD834\uDF06def'.at(-0.9), 'a');
    assert.strictEqual('abc\uD834\uDF06def'.at(1.9), 'b');
    assert.strictEqual('abc\uD834\uDF06def'.at(7.9), 'f');
    assert.strictEqual('abc\uD834\uDF06def'.at(Math.pow(2, 32)), '');
    assert.strictEqual('\uD834\uDF06def'.at(-Infinity), '');
    assert.strictEqual('\uD834\uDF06def'.at(-1), '');
    assert.strictEqual('\uD834\uDF06def'.at(-0), '\uD834\uDF06');
    assert.strictEqual('\uD834\uDF06def'.at(0), '\uD834\uDF06');
    assert.strictEqual('\uD834\uDF06def'.at(1), '\uDF06');
    assert.strictEqual('\uD834\uDF06def'.at(2), 'd');
    assert.strictEqual('\uD834\uDF06def'.at(3), 'e');
    assert.strictEqual('\uD834\uDF06def'.at(4), 'f');
    assert.strictEqual('\uD834\uDF06def'.at(42), '');
    assert.strictEqual('\uD834\uDF06def'.at(Infinity), '');
    assert.strictEqual('\uD834\uDF06def'.at(null), '\uD834\uDF06');
    assert.strictEqual('\uD834\uDF06def'.at(void 8), '\uD834\uDF06');
    assert.strictEqual('\uD834\uDF06def'.at(), '\uD834\uDF06');
    assert.strictEqual('\uD834\uDF06def'.at(false), '\uD834\uDF06');
    assert.strictEqual('\uD834\uDF06def'.at(NaN), '\uD834\uDF06');
    assert.strictEqual('\uD834\uDF06def'.at(''), '\uD834\uDF06');
    assert.strictEqual('\uD834\uDF06def'.at('_'), '\uD834\uDF06');
    assert.strictEqual('\uD834\uDF06def'.at('1'), '\uDF06');
    assert.strictEqual('\uD834abc'.at(-Infinity), '');
    assert.strictEqual('\uD834abc'.at(-1), '');
    assert.strictEqual('\uD834abc'.at(-0), '\uD834');
    assert.strictEqual('\uD834abc'.at(0), '\uD834');
    assert.strictEqual('\uD834abc'.at(1), 'a');
    assert.strictEqual('\uD834abc'.at(42), '');
    assert.strictEqual('\uD834abc'.at(Infinity), '');
    assert.strictEqual('\uD834abc'.at(null), '\uD834');
    assert.strictEqual('\uD834abc'.at(void 8), '\uD834');
    assert.strictEqual('\uD834abc'.at(), '\uD834');
    assert.strictEqual('\uD834abc'.at(false), '\uD834');
    assert.strictEqual('\uD834abc'.at(NaN), '\uD834');
    assert.strictEqual('\uD834abc'.at(''), '\uD834');
    assert.strictEqual('\uD834abc'.at('_'), '\uD834');
    assert.strictEqual('\uD834abc'.at('1'), 'a');
    assert.strictEqual('\uDF06abc'.at(-Infinity), '');
    assert.strictEqual('\uDF06abc'.at(-1), '');
    assert.strictEqual('\uDF06abc'.at(-0), '\uDF06');
    assert.strictEqual('\uDF06abc'.at(0), '\uDF06');
    assert.strictEqual('\uDF06abc'.at(1), 'a');
    assert.strictEqual('\uDF06abc'.at(42), '');
    assert.strictEqual('\uDF06abc'.at(Infinity), '');
    assert.strictEqual('\uDF06abc'.at(null), '\uDF06');
    assert.strictEqual('\uDF06abc'.at(void 8), '\uDF06');
    assert.strictEqual('\uDF06abc'.at(), '\uDF06');
    assert.strictEqual('\uDF06abc'.at(false), '\uDF06');
    assert.strictEqual('\uDF06abc'.at(NaN), '\uDF06');
    assert.strictEqual('\uDF06abc'.at(''), '\uDF06');
    assert.strictEqual('\uDF06abc'.at('_'), '\uDF06');
    assert.strictEqual('\uDF06abc'.at('1'), 'a');
    at = String.prototype.at;
    assert.strictEqual(at.call(42, 0), '4');
    assert.strictEqual(at.call(42, 1), '2');
    assert.strictEqual(at.call({
      toString: function(){
        return 'abc';
      }
    }, 2), 'c');
    if (!function(){
      return this;
    }()) {
      assert.throws(function(){
        return String.prototype.at.call(null, 0);
      }, TypeError);
      return assert.throws(function(){
        return String.prototype.at.call(void 8, 0);
      }, TypeError);
    }
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  'use strict';
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES7');
  test('String#padLeft', function(assert){
    assert.ok(toString$.call(String.prototype.padLeft).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(String.prototype.padLeft.length, 1, 'arity is 1');
    assert.ok(/native code/.test(String.prototype.padLeft), 'looks like native');
    assert.strictEqual(String.prototype.padLeft.name, 'padLeft', 'name is "padLeft"');
    assert.strictEqual('abc'.padLeft(5), '  abc');
    assert.strictEqual('abc'.padLeft(4, 'de'), 'dabc');
    assert.strictEqual('abc'.padLeft(), 'abc');
    assert.strictEqual('abc'.padLeft(5, '_'), '__abc');
    assert.strictEqual(''.padLeft(0), '');
    assert.strictEqual('foo'.padLeft(1), 'foo');
    if (!function(){
      return this;
    }()) {
      assert.throws(function(){
        return String.prototype.padLeft.call(null, 0);
      }, TypeError);
      return assert.throws(function(){
        return String.prototype.padLeft.call(void 8, 0);
      }, TypeError);
    }
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  'use strict';
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES7');
  test('String#padRight', function(assert){
    assert.ok(toString$.call(String.prototype.padRight).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(String.prototype.padRight.length, 1, 'arity is 1');
    assert.ok(/native code/.test(String.prototype.padRight), 'looks like native');
    assert.strictEqual(String.prototype.padRight.name, 'padRight', 'name is "padRight"');
    assert.strictEqual('abc'.padRight(5), 'abc  ');
    assert.strictEqual('abc'.padRight(4, 'de'), 'abcd');
    assert.strictEqual('abc'.padRight(), 'abc');
    assert.strictEqual('abc'.padRight(5, '_'), 'abc__');
    assert.strictEqual(''.padRight(0), '');
    assert.strictEqual('foo'.padRight(1), 'foo');
    if (!function(){
      return this;
    }()) {
      assert.throws(function(){
        return String.prototype.padRight.call(null, 0);
      }, TypeError);
      return assert.throws(function(){
        return String.prototype.padRight.call(void 8, 0);
      }, TypeError);
    }
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  'use strict';
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES7');
  test('String#trimLeft', function(assert){
    assert.ok(toString$.call(''.trimLeft).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(String.prototype.trimLeft.length, 0, 'arity is 0');
    assert.ok(/native code/.test(String.prototype.trimLeft), 'looks like native');
    assert.strictEqual(String.prototype.trimLeft.name, 'trimLeft', 'name is "trimLeft"');
    assert.strictEqual(' \n  q w e \n  '.trimLeft(), 'q w e \n  ', 'removes whitespaces at left side of string');
    assert.strictEqual('\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF'.trimLeft(), '', 'removes all whitespaces');
    assert.strictEqual('\u200b\u0085'.trimLeft(), '\u200b\u0085', "shouldn't remove this symbols");
    if (!function(){
      return this;
    }()) {
      assert.throws(function(){
        return String.prototype.trimLeft.call(null, 0);
      }, TypeError);
      return assert.throws(function(){
        return String.prototype.trimLeft.call(void 8, 0);
      }, TypeError);
    }
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  'use strict';
  var module, test, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('ES7');
  test('String#trimRight', function(assert){
    assert.ok(toString$.call(''.trimRight).slice(8, -1) === 'Function', 'is function');
    assert.strictEqual(String.prototype.trimRight.length, 0, 'arity is 0');
    assert.ok(/native code/.test(String.prototype.trimRight), 'looks like native');
    assert.strictEqual(String.prototype.trimRight.name, 'trimRight', 'name is "trimRight"');
    assert.strictEqual(' \n  q w e \n  '.trimRight(), ' \n  q w e', 'removes whitespaces at right side of string');
    assert.strictEqual('\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF'.trimRight(), '', 'removes all whitespaces');
    assert.strictEqual('\u200b\u0085'.trimRight(), '\u200b\u0085', "shouldn't remove this symbols");
    if (!function(){
      return this;
    }()) {
      assert.throws(function(){
        return String.prototype.trimRight.call(null, 0);
      }, TypeError);
      return assert.throws(function(){
        return String.prototype.trimRight.call(void 8, 0);
      }, TypeError);
    }
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, isFunction, slice, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('Mozilla JavaScript Array statics');
  isFunction = function(it){
    return toString$.call(it).slice(8, -1) === 'Function';
  };
  slice = Array.prototype.slice;
  test('are functions', function(assert){
    var i$, x$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = ['concat', 'join', 'pop', 'push', 'reverse', 'shift', 'slice', 'sort', 'splice', 'unshift', 'indexOf', 'lastIndexOf', 'every', 'some', 'forEach', 'map', 'filter', 'reduce', 'reduceRight', 'copyWithin', 'fill', 'find', 'findIndex', 'keys', 'values', 'entries', 'includes']).length; i$ < len$; ++i$) {
      x$ = ref$[i$];
      results$.push(assert.ok(isFunction(Array[x$]), "Array." + x$ + " is function"));
    }
    return results$;
  });
  test('.join', function(assert){
    var join;
    join = Array.join;
    assert.ok(join('123') === '1,2,3');
    assert.ok(join('123', '|') === '1|2|3');
    return assert.ok(join(function(){
      return arguments;
    }(3, 2, 1), '|') === '3|2|1');
  });
  test('.pop', function(assert){
    var pop, args;
    pop = Array.pop;
    assert.ok(pop(args = {
      0: 1,
      1: 2,
      2: 3,
      length: 3
    }) === 3);
    return assert.deepEqual(args, {
      0: 1,
      1: 2,
      length: 2
    });
  });
  test('.push', function(assert){
    var push, args;
    push = Array.push;
    push(args = function(){
      return arguments;
    }(1, 2, 3), 4, 5);
    return assert.deepEqual(slice.call(args), [1, 2, 3, 4, 5]);
  });
  test('.reverse', function(assert){
    var reverse;
    reverse = Array.reverse;
    return assert.deepEqual(reverse(function(){
      return arguments;
    }(1, 2, 3)), function(){
      return arguments;
    }(3, 2, 1));
  });
  test('.shift', function(assert){
    var shift, args;
    shift = Array.shift;
    assert.ok(shift(args = {
      0: 1,
      1: 2,
      2: 3,
      length: 3
    }) === 1);
    return assert.deepEqual(args, {
      0: 2,
      1: 3,
      length: 2
    });
  });
  test('.unshift', function(assert){
    var unshift, args;
    unshift = Array.unshift;
    unshift(args = function(){
      return arguments;
    }(1, 2, 3), 4, 5);
    return assert.deepEqual(slice.call(args), [4, 5, 1, 2, 3]);
  });
  test('.slice', function(assert){
    var slice;
    slice = Array.slice;
    assert.deepEqual(slice('123'), ['1', '2', '3']);
    assert.deepEqual(slice('123', 1), ['2', '3']);
    assert.deepEqual(slice('123', 1, 2), ['2']);
    assert.deepEqual(slice('123', 1, -1), ['2']);
    assert.deepEqual(slice(function(){
      return arguments;
    }(1, 2, 3)), [1, 2, 3]);
    assert.deepEqual(slice(function(){
      return arguments;
    }(1, 2, 3), 1), [2, 3]);
    assert.deepEqual(slice(function(){
      return arguments;
    }(1, 2, 3), 1, 2), [2]);
    return assert.deepEqual(slice(function(){
      return arguments;
    }(1, 2, 3), 1, -1), [2]);
  });
  test('.splice', function(assert){
    var splice, args;
    splice = Array.splice;
    splice(args = function(){
      return arguments;
    }(1, 2, 3), 1, 0, 4, 5);
    assert.deepEqual(slice.call(args), [1, 4, 5, 2, 3]);
    splice(args = function(){
      return arguments;
    }(1, 2, 3), 1, 1, 4);
    assert.deepEqual(slice.call(args), [1, 4, 3]);
    splice(args = function(){
      return arguments;
    }(1, 2, 3), 1, 1);
    return assert.deepEqual(slice.call(args), [1, 3]);
  });
  test('.sort', function(assert){
    var sort;
    sort = Array.sort;
    assert.deepEqual(sort(function(){
      return arguments;
    }(2, 1, 3)), function(){
      return arguments;
    }(1, 2, 3));
    assert.deepEqual(sort(function(){
      return arguments;
    }(11, 2, 3)), function(){
      return arguments;
    }(11, 2, 3));
    return assert.deepEqual(sort(function(){
      return arguments;
    }(11, 2, 3), function(a, b){
      return a - b;
    }), function(){
      return arguments;
    }(2, 3, 11));
  });
  test('.indexOf', function(assert){
    var indexOf;
    indexOf = Array.indexOf;
    assert.ok(indexOf('111', '1') === 0);
    assert.ok(indexOf('123', '1', 1) === -1);
    assert.ok(indexOf('123', '2', 1) === 1);
    assert.ok(indexOf(function(){
      return arguments;
    }(1, 1, 1), 1) === 0);
    assert.ok(indexOf(function(){
      return arguments;
    }(1, 2, 3), 1, 1) === -1);
    return assert.ok(indexOf(function(){
      return arguments;
    }(1, 2, 3), 2, 1) === 1);
  });
  test('.lastIndexOf', function(assert){
    var lastIndexOf;
    lastIndexOf = Array.lastIndexOf;
    assert.ok(lastIndexOf('111', '1') === 2);
    assert.ok(lastIndexOf('123', '3', 1) === -1);
    assert.ok(lastIndexOf('123', '2', 1) === 1);
    assert.ok(lastIndexOf(function(){
      return arguments;
    }(1, 1, 1), 1) === 2);
    assert.ok(lastIndexOf(function(){
      return arguments;
    }(1, 2, 3), 3, 1) === -1);
    return assert.ok(lastIndexOf(function(){
      return arguments;
    }(1, 2, 3), 2, 1) === 1);
  });
  test('.every', function(assert){
    var every, al, ctx;
    every = Array.every;
    every(al = function(){
      return arguments;
    }(1), function(val, key, that){
      assert.ok(this === ctx);
      assert.ok(val === 1);
      assert.ok(key === 0);
      return assert.ok(that === al);
    }, ctx = {});
    assert.ok(every('123', function(it){
      return toString$.call(it).slice(8, -1) === 'String';
    }));
    assert.ok(every('123', function(){
      return arguments[1] < 3;
    }));
    assert.ok(!every('123', function(it){
      return toString$.call(it).slice(8, -1) === 'Number';
    }));
    assert.ok(!every('123', function(){
      return arguments[1] < 2;
    }));
    assert.ok(every('123', function(){
      return arguments[2] == '123';
    }));
    return assert.ok(every(function(){
      return arguments;
    }(1, 2, 3), function(it){
      return toString$.call(it).slice(8, -1) === 'Number';
    }));
  });
  test('.some', function(assert){
    var some, al, ctx;
    some = Array.some;
    some(al = function(){
      return arguments;
    }(1), function(val, key, that){
      assert.ok(this === ctx);
      assert.ok(val === 1);
      assert.ok(key === 0);
      return assert.ok(that === al);
    }, ctx = {});
    assert.ok(some('123', function(it){
      return toString$.call(it).slice(8, -1) === 'String';
    }));
    assert.ok(some('123', function(){
      return arguments[1] > 1;
    }));
    assert.ok(!some('123', function(it){
      return toString$.call(it).slice(8, -1) === 'Number';
    }));
    assert.ok(!some('123', function(){
      return arguments[1] > 3;
    }));
    assert.ok(some('123', function(){
      return arguments[2] == '123';
    }));
    return assert.ok(some(function(){
      return arguments;
    }(1, 2, 3), function(it){
      return toString$.call(it).slice(8, -1) === 'Number';
    }));
  });
  test('.forEach', function(assert){
    var forEach, al, ctx, val;
    forEach = Array.forEach;
    forEach(al = function(){
      return arguments;
    }(1), function(val, key, that){
      assert.ok(this === ctx);
      assert.ok(val === 1);
      assert.ok(key === 0);
      assert.ok(that === al);
    }, ctx = {});
    val = '';
    forEach('123', function(v, k, t){
      val += v + k + t;
    });
    assert.ok(val === '101232112332123');
    val = '';
    forEach(function(){
      return arguments;
    }(1, 2, 3), function(v, k, t){
      val += v + k + t['2'];
    });
    assert.ok(val === '468');
    val = '';
    forEach('123', function(v, k, t){
      val += v + k + t + this;
    }, 1);
    return assert.ok(val === '101231211231321231');
  });
  test('.map', function(assert){
    var map, al, ctx;
    map = Array.map;
    map(al = function(){
      return arguments;
    }(1), function(val, key, that){
      assert.ok(this === ctx);
      assert.ok(val === 1);
      assert.ok(key === 0);
      return assert.ok(that === al);
    }, ctx = {});
    assert.deepEqual(map('123', (function(it){
      return Math.pow(it, 2);
    })), [1, 4, 9]);
    return assert.deepEqual(map(function(){
      return arguments;
    }(1, 2, 3), (function(it){
      return Math.pow(it, 2);
    })), [1, 4, 9]);
  });
  test('.filter', function(assert){
    var filter, al, ctx;
    filter = Array.filter;
    filter(al = function(){
      return arguments;
    }(1), function(val, key, that){
      assert.ok(this === ctx);
      assert.ok(val === 1);
      assert.ok(key === 0);
      return assert.ok(that === al);
    }, ctx = {});
    assert.deepEqual(filter('123', function(it){
      return it > 1;
    }), ['2', '3']);
    assert.deepEqual(filter(function(){
      return arguments;
    }(1, 2, 3), function(it){
      return it < 3;
    }), [1, 2]);
    return assert.deepEqual(filter('123', function(){
      return arguments[1] !== 1;
    }), ['1', '3']);
  });
  test('.reduce', function(assert){
    var reduce, al, ctx;
    reduce = Array.reduce;
    reduce(al = function(){
      return arguments;
    }(1), function(memo, val, key, that){
      assert.ok(memo === ctx);
      assert.ok(val === 1);
      assert.ok(key === 0);
      return assert.ok(that === al);
    }, ctx = {});
    reduce(al = function(){
      return arguments;
    }(1, 2), function(memo){
      return assert.ok(memo === 1);
    });
    assert.ok(reduce('123', function(a, b){
      a = +a;
      b = +b;
      return a + b;
    }) === 6);
    assert.ok(reduce(function(){
      return arguments;
    }(1, 2, 3), function(a, b){
      return '' + b * b + a;
    }) === '941');
    return assert.ok(reduce('123', function(a, b){
      a = +a;
      b = +b;
      return a + b;
    }, 1) === 7);
  });
  test('.reduceRight', function(assert){
    var reduceRight, al, ctx;
    reduceRight = Array.reduceRight;
    reduceRight(al = function(){
      return arguments;
    }(1), function(memo, val, key, that){
      assert.ok(memo === ctx);
      assert.ok(val === 1);
      assert.ok(key === 0);
      return assert.ok(that === al);
    }, ctx = {});
    reduceRight(al = function(){
      return arguments;
    }(1, 2), function(memo){
      return assert.ok(memo === 2);
    });
    assert.ok(reduceRight('123', function(a, b){
      a = +a;
      b = +b;
      return a + b;
    }) === 6);
    assert.ok(reduceRight(function(){
      return arguments;
    }(1, 2, 3), function(a, b){
      return '' + b * b + a;
    }) === '143');
    return assert.ok(reduceRight('123', function(a, b){
      a = +a;
      b = +b;
      return a + b;
    }, 1) === 7);
  });
  test('.copyWithin', function(assert){
    var copyWithin, a;
    copyWithin = Array.copyWithin;
    assert.ok(copyWithin(a = function(){
      return arguments;
    }(1, 2, 3), 0) === a);
    assert.deepEqual(copyWithin(function(){
      return arguments;
    }(1, 2, 3), -2), function(){
      return arguments;
    }(1, 1, 2));
    assert.deepEqual(copyWithin(function(){
      return arguments;
    }(1, 2, 3), 0, 1), function(){
      return arguments;
    }(2, 3, 3));
    return assert.deepEqual(copyWithin(function(){
      return arguments;
    }(1, 2, 3), 0, 1, 2), function(){
      return arguments;
    }(2, 2, 3));
  });
  test('.fill', function(assert){
    var fill, a;
    fill = Array.fill;
    assert.ok(fill(a = function(){
      return arguments;
    }(1, 2, 3), 0) === a);
    return assert.deepEqual(fill(Array(3), 5), [5, 5, 5]);
  });
  test('.find', function(assert){
    var find, al, ctx;
    find = Array.find;
    find(al = function(){
      return arguments;
    }(1), function(val, key, that){
      assert.ok(this === ctx);
      assert.ok(val === 1);
      assert.ok(key === 0);
      return assert.ok(that === al);
    }, ctx = {});
    assert.ok(find(function(){
      return arguments;
    }(1, 3, NaN, 42, {}), (function(it){
      return it === 42;
    })) === 42);
    assert.ok(find('123', (function(it){
      return it === '2';
    })) === '2');
    return assert.ok(find('123', (function(it){
      return it === '4';
    })) === void 8);
  });
  test('.findIndex', function(assert){
    var findIndex, al, ctx;
    findIndex = Array.findIndex;
    findIndex(al = function(){
      return arguments;
    }(1), function(val, key, that){
      assert.ok(this === ctx);
      assert.ok(val === 1);
      assert.ok(key === 0);
      return assert.ok(that === al);
    }, ctx = {});
    assert.ok(findIndex(function(){
      return arguments;
    }(1, 3, NaN, 42, {}), (function(it){
      return it === 42;
    })) === 3);
    assert.ok(findIndex('123', (function(it){
      return it === '2';
    })) === 1);
    return assert.ok(findIndex('123', (function(it){
      return it === '4';
    })) === -1);
  });
  test('.keys', function(assert){
    var keys, iter1, iter2;
    keys = Array.keys;
    assert.ok(typeof keys === 'function', 'is function');
    iter1 = keys(function(){
      return arguments;
    }('q', 'w', 'e'));
    assert.ok(typeof iter1 === 'object', 'Iterator is object');
    assert.ok(typeof iter1.next === 'function', 'Iterator has .next method');
    assert.deepEqual(iter1.next(), {
      value: 0,
      done: false
    });
    assert.deepEqual(iter1.next(), {
      value: 1,
      done: false
    });
    assert.deepEqual(iter1.next(), {
      value: 2,
      done: false
    });
    assert.deepEqual(iter1.next(), {
      value: void 8,
      done: true
    });
    iter2 = keys('qwe');
    assert.deepEqual(iter2.next(), {
      value: 0,
      done: false
    });
    assert.deepEqual(iter2.next(), {
      value: 1,
      done: false
    });
    assert.deepEqual(iter2.next(), {
      value: 2,
      done: false
    });
    return assert.deepEqual(iter2.next(), {
      value: void 8,
      done: true
    });
  });
  test('.values', function(assert){
    var values, iter1, iter2;
    values = Array.values;
    assert.ok(typeof values === 'function', 'is function');
    iter1 = values(function(){
      return arguments;
    }('q', 'w', 'e'));
    assert.ok(typeof iter1 === 'object', 'Iterator is object');
    assert.ok(typeof iter1.next === 'function', 'Iterator has .next method');
    assert.deepEqual(iter1.next(), {
      value: 'q',
      done: false
    });
    assert.deepEqual(iter1.next(), {
      value: 'w',
      done: false
    });
    assert.deepEqual(iter1.next(), {
      value: 'e',
      done: false
    });
    assert.deepEqual(iter1.next(), {
      value: void 8,
      done: true
    });
    iter2 = values('qwe');
    assert.deepEqual(iter2.next(), {
      value: 'q',
      done: false
    });
    assert.deepEqual(iter2.next(), {
      value: 'w',
      done: false
    });
    assert.deepEqual(iter2.next(), {
      value: 'e',
      done: false
    });
    return assert.deepEqual(iter2.next(), {
      value: void 8,
      done: true
    });
  });
  test('.entries', function(assert){
    var entries, iter1, iter2;
    entries = Array.entries;
    assert.ok(typeof entries === 'function', 'is function');
    iter1 = entries(function(){
      return arguments;
    }('q', 'w', 'e'));
    assert.ok(typeof iter1 === 'object', 'Iterator is object');
    assert.ok(typeof iter1.next === 'function', 'Iterator has .next method');
    assert.deepEqual(iter1.next(), {
      value: [0, 'q'],
      done: false
    });
    assert.deepEqual(iter1.next(), {
      value: [1, 'w'],
      done: false
    });
    assert.deepEqual(iter1.next(), {
      value: [2, 'e'],
      done: false
    });
    assert.deepEqual(iter1.next(), {
      value: void 8,
      done: true
    });
    iter2 = entries('qwe');
    assert.deepEqual(iter2.next(), {
      value: [0, 'q'],
      done: false
    });
    assert.deepEqual(iter2.next(), {
      value: [1, 'w'],
      done: false
    });
    assert.deepEqual(iter2.next(), {
      value: [2, 'e'],
      done: false
    });
    return assert.deepEqual(iter2.next(), {
      value: void 8,
      done: true
    });
  });
  test('.includes', function(assert){
    var includes, args, o, str;
    includes = Array.includes;
    assert.ok(isFunction(includes), 'is function');
    args = function(){
      return arguments;
    }(1, 2, 3, -0, NaN, o = {});
    assert.ok(includes(args, 1));
    assert.ok(includes(args, -0));
    assert.ok(includes(args, 0));
    assert.ok(includes(args, NaN));
    assert.ok(includes(args, o));
    assert.ok(!includes(args, 4));
    assert.ok(!includes(args, -0.5));
    assert.ok(!includes(args, {}));
    str = 'qwe';
    assert.ok(includes(str, 'q'));
    return assert.ok(!includes(str, 'r'));
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, isFunction, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('DOM iterable');
  isFunction = function(it){
    return toString$.call(it).slice(8, -1) === 'Function';
  };
  if ((typeof NodeList != 'undefined' && NodeList !== null) && ((typeof document != 'undefined' && document !== null) && document.querySelectorAll) && document.querySelectorAll('div') instanceof NodeList) {
    test('NodeList.prototype@@iterator', function(assert){
      return assert.ok(isFunction(document.querySelectorAll('div')[Symbol.iterator]), 'is function');
    });
  }
  if ((typeof HTMLCollection != 'undefined' && HTMLCollection !== null) && ((typeof document != 'undefined' && document !== null) && document.getElementsByTagName) && document.getElementsByTagName('div') instanceof HTMLCollection) {
    test('HTMLCollection.prototype@@iterator', function(assert){
      return assert.ok(isFunction(document.getElementsByTagName('div')[Symbol.iterator]), 'is function');
    });
  }
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, isFunction, timeLimitedPromise, toString$ = {}.toString;
  module = QUnit.module, test = QUnit.test;
  module('Immediate');
  isFunction = function(it){
    return toString$.call(it).slice(8, -1) === 'Function';
  };
  timeLimitedPromise = function(time, fn){
    return Promise.race([
      new Promise(fn), new Promise(function(res, rej){
        return setTimeout(rej, time);
      })
    ]);
  };
  test('setImmediate / clearImmediate', function(assert){
    var def;
    assert.expect(10);
    assert.ok(isFunction(setImmediate), 'setImmediate is function');
    assert.ok(isFunction(clearImmediate), 'clearImmediate is function');
    assert.ok(/native code/.test(setImmediate), 'setImmediate looks like native');
    assert.ok(/native code/.test(clearImmediate), 'clearImmediate looks like native');
    assert.strictEqual(setImmediate.name, 'setImmediate', 'setImmediate.name is "setImmediate"');
    assert.strictEqual(clearImmediate.name, 'clearImmediate', 'clearImmediate.name is "clearImmediate"');
    timeLimitedPromise(1e3, function(res){
      return setImmediate(function(){
        def = 'a';
        return res();
      });
    }).then(function(){
      return assert.ok(true, 'setImmediate works');
    })['catch'](function(){
      return assert.ok(false, 'setImmediate works');
    }).then(assert.async());
    assert.strictEqual(def, void 8, 'setImmediate is async');
    timeLimitedPromise(1e3, function(res){
      return setImmediate(function(a, b){
        return res(a + b);
      }, 'a', 'b');
    }).then(function(it){
      return assert.strictEqual(it, 'ab', 'setImmediate works with additional args');
    })['catch'](function(){
      return assert.ok(false, 'setImmediate works with additional args');
    }).then(assert.async());
    return timeLimitedPromise(50, function(res){
      return clearImmediate(setImmediate(res));
    }).then(function(){
      return assert.ok(false, 'clearImmediate works');
    })['catch'](function(){
      return assert.ok(true, 'clearImmediate works');
    }).then(assert.async());
  });
  (function(it){
    if (typeof window != 'undefined' && window !== null) {
      return window.onload = it;
    } else {
      return it();
    }
  })(function(){
    return setTimeout(function(){
      var x, now, inc;
      x = 0;
      now = Date.now();
      return (inc = function(){
        return setImmediate(function(){
          x = x + 1;
          if (Date.now() - now < 5e3) {
            return inc();
          } else {
            return typeof console != 'undefined' && console !== null ? console.log("setImmediate: " + x / 5 + " per second") : void 8;
          }
        });
      })();
    }, 5e3);
  });
}).call(this);

// Generated by LiveScript 1.3.1
(function(){
  var module, test, timeLimitedPromise, global;
  module = QUnit.module, test = QUnit.test;
  module('Timers');
  timeLimitedPromise = function(time, fn){
    return Promise.race([
      new Promise(fn), new Promise(function(res, rej){
        return setTimeout(rej, time);
      })
    ]);
  };
  global = Function('return this')();
  test('setTimeout / clearTimeout', function(assert){
    assert.expect(2);
    timeLimitedPromise(1e3, function(res){
      return global.setTimeout(function(a, b){
        return res(a + b);
      }, 10, 'a', 'b');
    }).then(function(it){
      return assert.strictEqual(it, 'ab', 'setTimeout works with additional args');
    })['catch'](function(){
      return assert.ok(false, 'setTimeout works with additional args');
    }).then(assert.async());
    return timeLimitedPromise(50, function(res){
      return clearTimeout(setTimeout(res, 10));
    }).then(function(){
      return assert.ok(false, 'clearImmediate works with wraped setTimeout');
    })['catch'](function(){
      return assert.ok(true, 'clearImmediate works with wraped setTimeout');
    }).then(assert.async());
  });
  test('setInterval / clearInterval', function(assert){
    var i;
    assert.expect(1);
    i = 0;
    return timeLimitedPromise(1e4, function(res, rej){
      var interval;
      return interval = global.setInterval(function(a, b){
        if (a + b !== 'ab' || i > 2) {
          rej({
            a: a,
            b: b,
            i: i
          });
        }
        if (i++ === 2) {
          global.clearInterval(interval);
          return global.setTimeout(res, 30);
        }
      }, 5, 'a', 'b');
    }).then(function(){
      return assert.ok(true, 'setInterval & clearInterval works with additional args');
    })['catch'](function(arg$){
      var ref$, a, b, i;
      ref$ = arg$ != null
        ? arg$
        : {}, a = ref$.a, b = ref$.b, i = ref$.i;
      return assert.ok(false, "setInterval & clearInterval works with additional args: " + a + ", " + b + ", times: " + i);
    }).then(assert.async());
  });
}).call(this);
